<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://xxyr.cc").hostname,root:"/",scheme:"Gemini",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="《Redis开发与运维》学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="《Redis开发与运维》笔记"><meta property="og:url" content="http://xxyr.cc/post/Redis/redis-notes/index.html"><meta property="og:site_name" content="不负骤雨"><meta property="og:description" content="《Redis开发与运维》学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rjAmUx.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rjnP8x.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF3wuT.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rvp9KI.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rvEkCV.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF8CPs.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF8WJs.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/03/s9MDTP.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sFG9eO.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sFG1Yj.png"><meta property="article:published_time" content="2020-12-29T03:31:00.000Z"><meta property="article:modified_time" content="2021-01-09T00:16:28.866Z"><meta property="article:author" content="不负骤雨"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.ax1x.com/2020/12/31/rjAmUx.png"><link rel="canonical" href="http://xxyr.cc/post/Redis/redis-notes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>《Redis开发与运维》笔记 | 不负骤雨</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" style="margin:10px"><div class="container use-motion"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不负骤雨</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">围城</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">13</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">14</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://xxyr.cc/post/Redis/redis-notes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://i.loli.net/2019/12/15/ev4RZy7Iakn9WHl.jpg"><meta itemprop="name" content="不负骤雨"><meta itemprop="description" content="reading coding keeping"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="不负骤雨"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Redis开发与运维》笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-29 11:31:00" itemprop="dateCreated datePublished" datetime="2020-12-29T11:31:00+08:00">2020-12-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-01-09 08:16:28" itemprop="dateModified" datetime="2021-01-09T08:16:28+08:00">2021-01-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span> </a></span></span><span id="/post/Redis/redis-notes/" class="post-meta-item leancloud_visitors" data-flag-title="《Redis开发与运维》笔记" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论次数：</span> <a title="valine" href="/post/Redis/redis-notes/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/Redis/redis-notes/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>《Redis开发与运维》学习笔记<a id="more"></a></p><h2 id="Ch-1-初识Redis"><a href="#Ch-1-初识Redis" class="headerlink" title="Ch 1 初识Redis"></a>Ch 1 初识Redis</h2><p>Redis（REmote Dictionary Server）——一种基于键值对的NoSQL数据库。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul><li><strong>速度快</strong><ul><li>所有数据存放在内存中。</li><li>基于C语言实现。</li><li>单线程架构。</li><li>源代码优化好。</li></ul></li><li><strong>基于键值对的数据结构服务器</strong><ul><li>Redis的值主要支持5种数据结构：字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）。</li><li>同时在字符串基础上演变了位图（Bitmaps）、HyperLogLog以及GEO（地理信息定位）等数据结构。</li></ul></li><li><strong>丰富的功能</strong><ul><li>键过期功能，实现缓存。</li><li>发布订阅功能，实现消息系统。</li><li>支持LUA脚本功能，用LUA创造出新的Redis命令。</li><li>简单的事务功能。</li><li>流水线功能，客户端能将命令一次性传到Redis。</li></ul></li><li><strong>简单稳定</strong><ul><li>源码相对较少。</li><li>使用单线程模型。</li><li>不依赖OS中的类库。</li><li>自己实现了事件处理的相关功能。</li></ul></li><li><strong>客户端语言多</strong><ul><li>提供简单的TCP通信协议</li><li>支持Java、PHP、Python、C、C++、Nodejs等. <a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a></li></ul></li><li><strong>持久化</strong><ul><li>RDB和AOF。</li></ul></li><li><strong>主从复制</strong><ul><li>分布式Redis的基础，实现多个相同数据的Redis副本。</li></ul></li><li><strong>高可用和分布式</strong></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>缓存</li><li>排行榜系统（列表和有序集合）</li><li>计数器应用（播放数、浏览数等）</li><li>社交网络（赞踩、粉丝、共同好友等）</li><li>消息队列系统</li><li>数据规模不宜过大、适用热数据（经常访问）</li></ul><h3 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h3><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><p><a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.redis.io/releases/redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-6.0.9 redis   <span class="comment">#创建软链接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>若显示 <code>install: 无法创建普通文件&#39;/usr/local/bin/redis-server&#39;: 权限不够</code><br>则执行<code>su root</code>获取root权限<br>不记得密码执行<code>sudo passwd root</code>修改密码<br>安装成功查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -v</span></span><br><span class="line">redis-cli 6.0.9</span><br></pre></td></tr></table></figure><h4 id="Redis配置、启动、操作和关闭"><a href="#Redis配置、启动、操作和关闭" class="headerlink" title="Redis配置、启动、操作和关闭"></a><span id="jump">Redis配置、启动、操作和关闭</span></h4><ul><li>三种启动方式<ul><li>默认配置启动<code>redis-server</code></li><li>运行启动（加上需修改的参数）<code>redis-server --port 6380</code></li><li>配置文件启动<code>redis-sever /opt/redis/redis.conf</code></li></ul></li><li>Redis命令行客户端<ul><li>交互式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set good day</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>命令方式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li></ul></li><li>停止Redis服务<br><code>redis-cli shutdown</code> （可选参数nosave|save是否生成持久化文件）</li></ul><h2 id="Ch-2-API的理解和使用"><a href="#Ch-2-API的理解和使用" class="headerlink" title="Ch 2 API的理解和使用"></a>Ch 2 API的理解和使用</h2><h3 id="基础知识、操作"><a href="#基础知识、操作" class="headerlink" title="基础知识、操作"></a>基础知识、操作</h3><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><ul><li>查看所有键<br><code>keys *</code><br>keys命令会遍历所有键，时间复杂度为O（n），线上环境禁止使用。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "good"</span><br><span class="line">2) "hello"</span><br></pre></td></tr></table></figure></li><li>键总数<br><code>dbsize</code><br>直接获取Redis内置的键总数变量，时间复杂度为O（1）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>检查键是否存在<br><code>exists key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists no_hello</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>删除键<br><code>del key1 key2 key3~</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del good hello</span><br><span class="line">(integer) 2                       #返回成功删除键的个数</span><br></pre></td></tr></table></figure></li><li>键过期<br><code>expire key seconds</code><br>对键添加过期时间，过期自动删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire hello 10   #单位：s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) 5                       #剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) -2                      #-2表示键不存在，-1表示键没有设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li>键的数据结构类型<br><code>type key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; type a</span><br><span class="line">none</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h4><p>优点：改进内部编码而不影响外部数据结构和命令，适应各种场景更加灵活，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjAmUx.png" alt=""></p><h4 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h4><ul><li>单线程首先不会出现并发问题，可以简化数据结构和算法的实现，并且避免了线程切换和竞态产生的消耗，但不适合某个命令执行时间过长的场景。</li><li>纯内存访问，重要基础。</li><li>非阻塞I/O，使用epoll作为I/O多路复用技术的实现以及自身事件模型，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjnP8x.png" alt=""></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Redis最基础的数据结构，键是字符串类型，字符串类型的值可以是字符串（JSON、XML等）、数字、二进制，值最大不能超过512MB。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>常用命令<ul><li>设置值<br><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code><br>ex seconds：为键设置秒级过期时间。<br>px milliseconds：为键设置毫秒级过期时间。<br>nx：等价于<code>setnx key value</code>，键必须不存在才能设置成功，用于添加（可以用于实现分布式锁）。<br>xx：等价于<code>setex key seconds value</code>，键必须存在才能设置成功，用于更新。</li><li>获取值<br><code>get key</code></li><li>批量设置值<br><code>mset key value key value···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>批量获取值<br><code>mget key key key···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget a b c d</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure></li><li>计数<br><code>incr key</code><br>用于对值做自增操作。<br>值必须是整数.<br>键不存在，按值为0自增，返回结果为1。<br>还有：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">decr key                    #自减</span><br><span class="line">incrby key incerement       #自增指定数字</span><br><span class="line">decrby key decrement        #自减指定数字</span><br><span class="line">incrbyfloat key incerement  #自增浮点数</span><br></pre></td></tr></table></figure></li></ul></li><li>不常用命令<ul><li>追加值<br><code>append key value</code><br>向字符串尾部追加值</li><li>字符串长度<br><code>strlen key</code><br>返回字节数</li><li>设置并返回原值<br><code>getset key value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset nice day</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset nice try</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>设置指定位置的字符<br><code>setrange key offset value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure></li><li>获取部分字符串<br><code>getrange key start end</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line">"be"</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF3wuT.png" alt=""></p><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>int<br>8个字节的长整型。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 8653</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure></li><li>embstr<br>小于等于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure></li><li>raw<br>大于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world···"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>缓存功能<br>Redis作为缓存层，MySQL作为存储层，如下图。<br><img src="https://s3.ax1x.com/2020/12/31/rvp9KI.png" alt=""><br>例如下面用于获取用户信息的伪代码。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id</span><br><span class="line">  value = redis.get(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">    userInfo = deserialize(value);    <span class="comment">#反序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo != null)</span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));   <span class="comment">#一小时过期时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">long incrVideoCounter(long id) &#123;</span><br><span class="line">  key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">  <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>共享Session<br>分布式Web服务使用Redis将用户的Session进行集中管理。<br><img src="https://s3.ax1x.com/2020/12/31/rvEkCV.png" alt=""></li><li>限速<br>例如网站限制一个IP地址在一定时间内的访问次数等。<br>用户获取验证码一分钟不超过5次的伪代码如下。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line">// SET key value EX <span class="number">60</span> NX</span><br><span class="line">isExists = redis.set(key,<span class="number">1</span>,<span class="string">"EX 60"</span>,<span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != null || redis.incr(key) &lt;=<span class="number">5</span>)&#123;</span><br><span class="line">  // 通过</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  // 限速</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>键值本身又是一对键值对结构，形如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = &#123;&#123;filed1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul><li>设置值<br><code>hset key filed value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取值<br><code>hget key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">"tom"</span><br></pre></td></tr></table></figure></li><li>删除field<br><code>hdel key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:1 name age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>计算field个数<br><code>hlen key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>批量设置或获取filed-value<br><code>hmset key filed1 value1 filed2 value2</code><br><code>hmget key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:1 name tom age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name age</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>判断filed是否存在<br><code>hexists key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取所有field<br><code>hkeys key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br></pre></td></tr></table></figure></li><li>获取所有value<br><code>hvals key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>获取所有的field-value<br><code>hgetall key</code>（个数较多会导致阻塞）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "tom"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br></pre></td></tr></table></figure></li><li>自增<br><code>hincrby key filed</code><br><code>hincrbyfloat key filed</code></li><li>计算value的字符串长度<br><code>hstrlen key filed</code>（Redis&gt;3.2）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen user:1 name</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8CPs.png" alt=""></p><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于hash-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于hash-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>hashtable（哈希表）<br>不满足ziplist时采用，O(1)。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>哈希类型是稀疏的，而关系型数据库是完全结构化的，且Redis不适合做复杂的关系查询，<br>以下为获取用户信息的伪代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  // 用户id作为key后缀</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">  // 使用hgetall获取所有用户信息映射关系</span><br><span class="line">  userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (userInfoMap != null) &#123;</span><br><span class="line">    // 将映射关系转换为UserInfo</span><br><span class="line">    userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 从MySQL中获取用户信息</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    // 将userInfo变为映射关系使用hmset保存到Redis中</span><br><span class="line">    redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">    // 添加过期时间</span><br><span class="line">    redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种缓存用户信息方法对比。</p><ul><li>原生字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 name tom</span><br><span class="line">set user:1 age 18</span><br></pre></td></tr></table></figure>每个属性一个键，简单直观，但内存占用大，用户信息内聚性差。</li><li>序列化字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 serialize(userinfo)</span><br></pre></td></tr></table></figure>简化编程，但序列化和反序列化有一定开销，且每次更新都要进行反序列化和序列化。</li><li>哈希类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset user:1 name tom age 18</span><br></pre></td></tr></table></figure>简单直观，合理使用可减少内存占用，但要注意两种内部编码的转换，hashtable会消耗更多内存。</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>可以存储多个<strong>有序</strong>、<strong>重复</strong>的字符串，每个字符串称为元素（个数不大于2^32-1），可以充当<strong>栈</strong>和<strong>队列</strong>。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul><li>添加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpush key value1 value2           #从右侧插入</span><br><span class="line">lpush key value1 value2           #从左侧插入</span><br><span class="line">linsert key before|after me you   #在me之前或之后插入you</span><br></pre></td></tr></table></figure></li><li>查找<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrange key start end              #从左至右为0到N-1，从右至左为-1到-N，end包含自身，0到-1为全部</span><br><span class="line">lindex key index                  #获取指定下标的元素</span><br><span class="line">llen key                          #获取列表长度</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpop key                          #从右侧删除</span><br><span class="line">lpop key                          #从右侧删除</span><br><span class="line">lrem key count value              #删除值等于value的元素</span><br><span class="line">                                  #count&gt;0，从左至右，最多删除count个元素</span><br><span class="line">                                  #count&lt;0，从右至左，最多删除count绝对值个元素</span><br><span class="line">                                  #count=0，删除所有</span><br><span class="line">ltrim key start end               #保留列表中start到end的元素</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure></li><li>阻塞式弹出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blpop key1 key2 timeout</span><br><span class="line">brpop key1 key2 timeout</span><br></pre></td></tr></table></figure>列表为空时，timeout=3则客户端等到3s后返回，timeout=0则一直阻塞。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 3</span><br><span class="line">(nil)</span><br><span class="line">(3.09s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">...阻塞中...</span><br></pre></td></tr></table></figure>此期间添加了数据element1，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list:test element1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br><span class="line">(90.81s)</span><br></pre></td></tr></table></figure>列表不为空，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br></pre></td></tr></table></figure>若多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取弹出的值。</li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8WJs.png" alt=""></p><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于list-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于list-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>linkedlist（链表）<br>不满足ziplist时采用。</li></ul><p>注：Redis 3.2 版本提供了quicklist编码，是以一个ziplist为节点的linkedlist，结合了两者的优势。</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>消息队列<br>使用lpush和brpop命令组合实现阻塞队列，如图。<br><img src="https://s3.ax1x.com/2021/01/03/s9MDTP.png" alt=""></li><li>文章列表<br>如分页展示文章列表。<ul><li>每篇文章使用哈希存储<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset acticle:1 title xx timestamp 1476536196 content xxxx</span><br></pre></td></tr></table></figure></li><li>向用户文章列表添加文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush user:1:acticles article:1 article:2</span><br></pre></td></tr></table></figure></li><li>分页获取用户文章列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">articles = lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">  hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush+lpop=Stack（ 栈）</span><br><span class="line">lpush+rpop=Queue（ 队列）</span><br><span class="line">lpsh+ltrim=Capped Collection（ 有限集合）</span><br><span class="line">lpush+brpop=Message Queue（ 消息队列）</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）用来保存多个<strong>无序</strong>字符串元素，且不允许有重复的元素，不支持下标索引。<br>一个集合可以存储2^32-1个元素<br>Redis支持集合内的增删改查以及集合间取交集、并集和差集。</p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内操作<ul><li>添加元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd key element1 element2</span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem key element1 element2</span><br></pre></td></tr></table></figure></li><li>计算元素个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scard key  #时间复杂度O(1)，直接调用Redis内部变量</span><br></pre></td></tr></table></figure></li><li>判断元素是否在集合中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></li><li>随机从集合返回指定个数的元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srandmember key count  #count默认为1</span><br></pre></td></tr></table></figure></li><li>从集合随机弹出count个元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop key count #Redis&gt;3.2，count默认为1</span><br></pre></td></tr></table></figure></li><li>获取所有元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间操作<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter key1 key2</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sunion key1 key2</span><br></pre></td></tr></table></figure></li><li>差集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure></li><li>将交集、并集和差集的结果保存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将key1和key2运算的结果保存在destination_key中</span></span><br><span class="line">sinterstore destination_key key1 key2</span><br><span class="line">sunionstore destination_key key1 key2</span><br><span class="line">sdiffstore destination_key key1 key2</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG9eO.png" alt=""></p><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>intset（整数集合）<br>更加节省内存。<br>使用场景：<ul><li>集合中都是整数且元素个数小于set-max-intset-entries配置（默认512个）</li></ul></li><li>hashtable（哈希表）<br>不满足intset时采用。</li></ul><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合典型的使用场景是<strong>标签</strong>（用于提升用户体验和增强用户黏度）。<br>注：用户和标签的关系维护应在一个事务内执行，防止部分命令失败造成的数据不一致。</p><ul><li>给用户添加标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>给标签添加用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>删除用户下的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>删除标签下的用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>计算用户共同感兴趣的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd=Tagging（标签）</span><br><span class="line">spop/srandmember=Random item（生成随机数， 比如抽奖）</span><br><span class="line">sadd+sinter=Social Graph（社交需求）</span><br></pre></td></tr></table></figure><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>相较于集合，有序集合中的元素依据分数进行排序，且元素不能重复但分数可以重复。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内<ul><li>添加成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 score2 member2</span><br><span class="line"></span><br><span class="line"><span class="meta">Redis&gt;</span><span class="bash">3.2，添加了如下参数：</span></span><br><span class="line">nx：member必须不存在才可以添加成功，用于添加。</span><br><span class="line">xx：member必须存在才可以添加成功，用于更新。</span><br><span class="line">ch：返回此次操作后，元素和分数发生变化的个数。</span><br><span class="line">incr：对score做增加，等于zincrby</span><br></pre></td></tr></table></figure></li><li>计算成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure></li><li>计算某个成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure></li><li>计算成员的排名<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrank key member  #分数从低到高</span><br><span class="line">zrevrank key member  #分数从高到低</span><br></pre></td></tr></table></figure></li><li>增加成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li><li>返回指定排名范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrange key start end [withscores]  #从低到高，withscores可选</span><br><span class="line">zrevrange key start end withscores</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]  #限制起始的位置和个数</span><br><span class="line">zrevrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line"></span><br><span class="line">limit offset count 可选参数，限制起始的位置和个数</span><br><span class="line">min和max支持开区间()和闭区间[]，-inf和+inf代表无穷小和无穷大</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li><li>删除成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem key member1 member2</span><br></pre></td></tr></table></figure></li><li>删除指定排名内的升序元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure></li><li>删除指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br><span class="line"></span><br><span class="line">destinatin：保存计算结果的键</span><br><span class="line">numkeys：参与计算键的个数</span><br><span class="line">weight：每个键的权重，每个键的member会将自己的分数乘以这个权重。</span><br><span class="line">aggregate sum|min|max：计算成员交集后，分数可以按照sum、min和max做汇总，默认sum。</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zunionstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG1Yj.png" alt=""></p><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于zset-max-ziplist-entries配置（默认128个）</li><li>同时所有的值小于zset-max-ziplist-value配置（默认64字节）</li></ul></li><li>skiplist（跳跃表）<br>不满足ziplist时采用。</li></ul><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景为排行榜系统。榜单的维度可以是多方面的。<br>例如视频网站对用户上传到视频做排行榜，使用赞数这个维度。</p><ul><li>添加用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd user:ranking:2021_01_05 3 mike  #用户mike上传了一个视频并获得了3个赞</span><br><span class="line">zincrby user:ranking:2021_01_05 1 mike  #之后又获得了一个赞</span><br></pre></td></tr></table></figure></li><li>取消用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li><li>展示获赞数最多前十用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrevrangebyrank user:ranking:2021_01_05 0 9</span><br></pre></td></tr></table></figure></li><li>展示用户信息及分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2021_01_05 mike</span><br><span class="line">zrank user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li></ul><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><p>关于键的一些通用命令介绍。<br>接2.1.1全局命令的一些其他命令。</p><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><ul><li><p>键重命名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure><p>（1）若rename的newkey已存在，那么该已存在的newkey的值会变成被rename的key的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set old a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set new b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rename old new</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get old</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get new</span><br><span class="line">"a"</span><br></pre></td></tr></table></figure><p>（2）为防止被强行rename，Redis提供了<code>renamenx</code>命令，只有newkey不存在时才能rename成功。<br>（3）由于重命名键期间会执行del删除旧的键，如果键对应的值较大，可能会导致阻塞。<br>（4）<code>rename key key</code>在3.2版本前会报错。</p></li><li><p>随机返回一个键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure></li><li><p>键过期</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire key seconds                      #键在seconds秒后过期</span><br><span class="line">pexpire key millionseconds              #毫秒级</span><br><span class="line">                                        #key不存在返回0</span><br><span class="line">                                        #seconds为负数，键会立即被删除</span><br><span class="line"></span><br><span class="line">expireat key timestamp                  #键在秒级时间戳timestamp后过期</span><br><span class="line">pexpireat key millionseconds-timestamp  #毫秒级</span><br><span class="line"></span><br><span class="line">ttl key                                 #查询键的剩余过期时间，单位秒。</span><br><span class="line">pttl key                                #毫秒级</span><br><span class="line">                                        #-1表示键没有设置过期时间，-2表示键不存在</span><br><span class="line"></span><br><span class="line">persist key                             #消除键的过期时间</span><br></pre></td></tr></table></figure><p>（1）无论何种方式，在Redis内部最终使用的是pexpireat。<br>（2）对于字符串类型的键，执行<code>set</code>命令会消除过期时间，详见源码中set命令的函数setKey。<br>（3）Redis不支持二级数据结构（哈希、列表等）内部元素的过期功能。<br>（4）<code>setex</code>作为set+expire的组合，不单是原子执行，且减少了一次网络通讯的时间。</p></li><li><p>迁移键</p><ul><li><p>move</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>Redis内部可以有多个数据库，且彼此相互隔离。move命令用于在Redis内部进行数据迁移。</p></li><li><p>dump+store</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value  #ttl为过期时间，=0不设置</span><br></pre></td></tr></table></figure><p>dump+store可实现不同Redis实例之间的数据迁移,整个迁移过程是非原子性的过程，且需要开启两个客户端连接。分为两步：<br>（1）在源Redis上执行dump，将键值序列化，为RDB格式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> <span class="built_in">set</span> hello world</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> dump hello</span></span><br><span class="line">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span><br></pre></td></tr></table></figure><p>（2）在目标Redis上执行restore，进行复原。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> restore hello 0 <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">"world</span><br></pre></td></tr></table></figure><p>对应伪代码为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Redis sourceRedis = new Redis("sourceMachine", 6379)</span><br><span class="line">Redis targetRedis = new Redis("targetMachine", 6379)</span><br><span class="line">targetRedis.restore("hello", 0, sourceRedis.dump(key))</span><br></pre></td></tr></table></figure></li><li><p>migrate</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key...]]</span><br><span class="line"></span><br><span class="line">host：              目标Redis的IP地址。</span><br><span class="line">port：              目标Redis的端口。</span><br><span class="line">key|""：            在Redis3.0.6版本之前，migrate只支持迁移一个键，所以此处是要迁移的键，</span><br><span class="line">                    在Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串""。</span><br><span class="line">destination-db：    目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</span><br><span class="line">timeout：           迁移的超时时间（单位为毫秒）。</span><br><span class="line">[copy]：            如果添加此选项，迁移后并不删除源键。</span><br><span class="line">[replace]：         如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</span><br><span class="line">[keys key[key...]]：迁移多个键，例如要迁移key1、key2、key3，此处填写“keys key1 key2 key3”。</span><br></pre></td></tr></table></figure><p>（1）migrate命令也是用于在Redis实例间进行数据迁移，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率。<br>（2）第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。第二，migrate命令的数据传输直接在源Redis和目标Redis上完成。第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</p><p>示例：</p><ul><li>源Redis有键hello，目标Redis没有<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis和目标Redis都有键hello<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000</span><br><span class="line">(error) ERR Target instance replied with error: BUSYKEY Target key name already exists.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000 replace</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis没有键hello。如下所示，此种情况会收到nokey的提示<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">NOKEY</span><br></pre></td></tr></table></figure></li><li>源Redis执行如下命令完成多个键的迁移<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 "" 0 5000 keys key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><ul><li><p>全量遍历键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keys pattern  #patterm使用glob风格通配符</span><br><span class="line"></span><br><span class="line">* 代表匹配所有任意字符</span><br><span class="line">? 代表匹配一个任意字符</span><br><span class="line">[1,3] 代表匹配1和3，[1-3] 代表匹配1到3的任意数字</span><br><span class="line">\x 转义字符</span><br></pre></td></tr></table></figure><p>考虑到Redis的单线程架构，keys命令一般只在以下三种情况使用：</p><ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但是会影响到主从复制。</li><li>如果确认键值总数确实比较少，可以执行该命令。</li><li>使用scan命令渐进式的遍历所有键。</li></ul></li><li><p>渐进式遍历</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br><span class="line"></span><br><span class="line">cursor：是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</span><br><span class="line">match pattern：可选参数，作用是做模式匹配。</span><br><span class="line">count number：可选参数，作用是表明每次要遍历的键个数，默认值是10，可以适当增大。</span><br></pre></td></tr></table></figure><p>Redis存储键值对实际使用hashtable作为内部编码。<br>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "15"</span><br><span class="line">2)  1) "new"</span><br><span class="line">    2) "c"</span><br><span class="line">    3) "a"</span><br><span class="line">    4) "key"</span><br><span class="line">    5) "nice"</span><br><span class="line">    6) "b"</span><br><span class="line">    7) "mylist"</span><br><span class="line">    8) "d"</span><br><span class="line">    9) "redis"</span><br><span class="line">  10) "user:1"</span><br><span class="line">127.0.0.1:6379&gt; scan 15</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "hello"</span><br></pre></td></tr></table></figure><p>除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如hgetall、smembers、zrange可能产生的阻塞问题，对应的命令分别是hscan、sscan、zscan。<br>需要注意的是scan过程中如果有键的变化，那么可能会遍历重复的键，而遍历不到新增的键。</p></li></ul><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><ul><li><p>切换数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select dbIndex</span><br></pre></td></tr></table></figure><p>Redis只用数字来标识数据库，默认有16个，各数据库独立。<br>但是该功能已逐步废弃了，原因如下：</p><ul><li>Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响。</li><li>多数据库的使用方式，会让调试和运维不同业务的数据库变的困难，假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困难。</li><li>部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱。<br>所以在需要多个数据库功能的情况下，可以在一台机器上部署多个Redis实例，以端口来区分。</li></ul></li><li><p>flushdb和flushall<br>flushdb只清除当前数据库，flushall会清除所有数据库。<br>带来的问题：</p><ul><li>flushdb/flushall命令会将所有数据清除，一旦误操作后果不堪设想。</li><li>如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能性。</li></ul></li></ul><h2 id="Ch-3-小功能大用处"><a href="#Ch-3-小功能大用处" class="headerlink" title="Ch 3 小功能大用处"></a>Ch 3 小功能大用处</h2><h3 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h3><p>发送命令&gt;命令排队&gt;命令执行&gt;返回结果<br>慢查询只统计命令执行的时间，并不反映客户端的超时问题。</p><h4 id="两个配置参数"><a href="#两个配置参数" class="headerlink" title="两个配置参数"></a>两个配置参数</h4><ul><li>预设阈值<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">单位：微秒，默认值=10000</span><br><span class="line">等于0会记录所有记录，小于0不记录任何命令</span><br></pre></td></tr></table></figure></li><li>慢查询记录存放位置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">Redis使用一个列表来存储慢查询日志（类似队列），</span><br><span class="line">slowlog-max-len指定列表最大长度</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><ul><li>获取慢查询日志<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog get [n]  #n可选，指定条数</span><br><span class="line"></span><br><span class="line">每个慢查询记录有4个属性，分别为：</span><br><span class="line">标识id、发生时间戳、命令耗时以及执行的命令和参数。</span><br></pre></td></tr></table></figure></li><li>获取慢查询日志列表当前长度<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></table></figure></li><li>慢查询日志重置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></li></ul><h4 id="实践注意事项"><a href="#实践注意事项" class="headerlink" title="实践注意事项"></a>实践注意事项</h4><ul><li><strong>slowlog-max-len配置建议</strong>：线上建议调大慢查询列表，可设置为1000以上，记录慢查询时Redis会对长命令做截断操作，并不会占用大量内存，增大慢查询列表可以减缓慢查询被剔除的可能。</li><li><strong>slowlog-log-slower-than配置建议</strong>：默认值超过10毫秒判定为慢查询，需要根据Redis并发量调整该值。由于Redis采用单线程响应命令，对于高流量的场景，如果命令执行时间在1毫秒以上，那么Redis最多可支撑OPS不到1000，因此对于高OPS场景的Redis建议设置为1毫秒。</li><li><strong>慢查询只记录命令执行时间</strong>，并不包括命令排队和网络传输时间，因此客户端执行命令的时间会大于命令实际执行时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此当客户端出现请求超时，需要检查该时间点是否有对应的慢查询，从而分析出是否为慢查询导致的命令级联阻塞。</li><li><strong>慢查询日志是一个先进先出的队列</strong>，如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化到其他存储中（例如MySQL），然后可以制作可视化界面进行查询，第13章介绍的Redis私有云CacheCloud提供了这样的功能，好的工具可以让问题排查事半功倍。</li></ul><h3 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h3><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><ul><li>-r<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 ping</span><br><span class="line"></span><br><span class="line">将ping命令执行3次</span><br></pre></td></tr></table></figure></li><li>-i（interval）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 -i 1 ping</span><br><span class="line"></span><br><span class="line">每隔几秒执行一次一次命令，单位：秒</span><br><span class="line">-i必须与-r一起用</span><br></pre></td></tr></table></figure></li><li>-x<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "world" | redis-cli -x set hello</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">-x选项代表从标准输入（stdin）读取数据作为redis-cli的最后一个参数。</span><br></pre></td></tr></table></figure></li><li>-c（cluster）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">连接Redis Cluster节点时需要使用，-c选项可以防止moved和ask异常，有关Redis Cluster将在第10章介绍。</span><br></pre></td></tr></table></figure></li><li>-a（auth）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果Redis配置了密码，可以用-a（auth）选项，有了这个选项就不需要手动输入auth命令。</span><br></pre></td></tr></table></figure></li><li>–scan和–pattern<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--scan选项和--pattern选项用于扫描指定模式的键，相当于使用scan命令。</span><br></pre></td></tr></table></figure></li><li>–slave<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--slave选项是把当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作，</span><br><span class="line">有关于Redis复制将在第6章进行详细介绍。</span><br><span class="line">合理的利用这个选项可以记录当前连接Redis节点的一些更新操作，</span><br><span class="line">这些更新操作很可能是实际开发业务时需要的数据。</span><br></pre></td></tr></table></figure></li><li>–rdb<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--rdb选项会请求Redis实例生成并发送RDB持久化文件，保存在本地。可使用它做持久化文件的定期备份。</span><br><span class="line">有关Redis持久化将在第5章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–pipe<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--pipe选项用于将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行，</span><br><span class="line">有关Redis通信协议将在第4章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–bigkeys<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--bigkeys选项使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈。</span><br></pre></td></tr></table></figure></li><li>–eval<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--eval选项用于执行指定Lua脚本，有关Lua脚本的使用将在3.4节介绍。</span><br></pre></td></tr></table></figure></li><li>–latency<br>用于检测网络延迟，有三个选项<ul><li>–lantency<br>该选项可以测试客户端到目标Redis的网络延迟，<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h &#123;server&#125; --latency</span><br></pre></td></tr></table></figure></li><li>–latency-history</li><li>-latency的执行结果只有一条，如果想以分时段的形式了解延迟信息，可以使用–latency-history选项，可以通过-i参数控制间隔时间。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.xx.xx --latency-history -i 10</span><br></pre></td></tr></table></figure></li><li>–latency-dist<br>该选项会使用统计图表的形式从控制台输出延迟统计信息。</li></ul></li><li>–stat<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--stat选项可以实时获取Redis的重要统计信息.</span><br></pre></td></tr></table></figure></li><li>–raw和–no-raw<br>–no-raw选项要求命令的返回结果必须是原始的格式，–raw返回格式化后的结果。</li></ul><h4 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h4><p>redis-server启动Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认配置启动`redis-server`</span><br><span class="line">运行启动（加上需修改的参数）`redis-server --port 6380`</span><br><span class="line">配置文件启动`redis-sever /opt/redis/redis.conf`</span><br></pre></td></tr></table></figure><p>redis-server除了启动Redis外，还有一个–test-memory选项，可以用来检测当前操作系统能否稳定地分配指定容量的内存给Redis，通过这种检测可以有效避免因为内存问题造成Redis崩溃。<br>下面的命令检测当前操作系统能否提供1G的内存给Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server --test-memory 1024</span><br></pre></td></tr></table></figure><h4 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h4><p>redis-benchmark可以为Redis做基准性能测试。</p><ul><li>-c（clients）<br>-c选项代表客户端的并发数量（默认是50）。</li><li>-n（num）<br>-n选项代表客户端请求总量（默认是100000）。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000</span><br><span class="line"></span><br><span class="line">代表测试100个客户端同时请求Redis，共执行20000次时的性能</span><br><span class="line">output：</span><br><span class="line">====== GET ======</span><br><span class="line">20000 requests completed in 0.27 seconds</span><br><span class="line">100 parallel clients</span><br><span class="line">3 bytes payload</span><br><span class="line">keep alive: 1</span><br><span class="line"></span><br><span class="line">99.11% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">73529.41 requests per second</span><br></pre></td></tr></table></figure></li><li>-q<br>-q选项仅仅显示redis-benchmark的requests per second信息。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000 -q</span><br></pre></td></tr></table></figure></li><li>-r<br>在一个空的Redis上执行了redis-benchmark会发现只有3个键：<code>counter:__rand_int__</code>、<code>mylist</code>和<code>key:__rand_int__</code>。<br>如果想向Redis插入更多的键，可以执行使用-r（random）选项，可以向Redis插入更多随机的键。<br>-r选项会在key、counter键上加一个12位的后缀，-r 10000代表只对后四位做随机处理（-r不是随机数的个数）。</li><li>-P<br>-P选项代表每个请求pipeline的数据量（默认为1）。</li><li>-k<br>-k选项代表客户端是否使用keepalive，1为使用，0为不使用，默认值为1。</li><li>-t<br>-t选项可以对指定命令进行基准测试。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set -q</span><br><span class="line">SET: 98619.32 requests per second</span><br><span class="line">GET: 97560.98 requests per second</span><br></pre></td></tr></table></figure></li><li>–csv<br>–csv选项会将结果按照csv格式输出，便于后续处理，如导出到Excel等。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set --csv</span><br><span class="line">"SET","81300.81"</span><br><span class="line">"GET","79051.38"</span><br></pre></td></tr></table></figure></li></ul><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Redis客户端从发送命令到接收到返回结果的时间为一次RTT，Redis提供的批量操作命令能减少RTT，但大部分命令并不支持批量操作。</li><li>Pipeline（流水线）机制，能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</li><li>redis-cli的–pipe选项实际上就是使用Pipeline机制，例如下面操作将set hello world和incr counter两条命令组装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -en '*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n*2\r\n$4\r\nincr\r\</span><br><span class="line">    n$7\r\ncounter\r\n' | redis-cli --pipe</span><br></pre></td></tr></table></figure></li></ul><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><ul><li>Pipeline执行速度一般比逐条执行要快。</li><li>客户端和服务端的网络延时越大，Pipeline的效果越明显。</li></ul><h4 id="原生批量命令与Pipeline对比"><a href="#原生批量命令与Pipeline对比" class="headerlink" title="原生批量命令与Pipeline对比"></a>原生批量命令与Pipeline对比</h4><ul><li>原生批量命令是原子的，Pipeline是非原子的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</li><li>Pipeline虽然只能操作一个Redis实例，但是即使在分布式Redis场景中，也可以作为批量操作的重要优化手段，具体细节见第11章。</li></ul><h3 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h3><p>为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>将一组需一起执行的命令放在<code>multi</code>和<code>exec</code>之间，若要停止事务的执行，使用<code>discard</code>命令代替<code>exec</code>。<br>若事务中出现错误，Redis有不同的处理机制：</p><ul><li>命令错误<br>命令写错造成的语法错误，整个事务无法执行。</li><li>运行时错误<br>命令写错但仍是可执行的命令，<strong>Redis不支持回滚操作</strong>，只能自行修复。<br>有些应用场景需要在事务之前，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁，其他客户端的修改会执行）。Redis提供了watch命令来解决这类问题。</li></ul><h4 id="Lua用法简述"><a href="#Lua用法简述" class="headerlink" title="Lua用法简述"></a>Lua用法简述</h4><h4 id="Redis与Lua"><a href="#Redis与Lua" class="headerlink" title="Redis与Lua"></a>Redis与Lua</h4><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h4 id="Redis如何管理Lua脚本"><a href="#Redis如何管理Lua脚本" class="headerlink" title="Redis如何管理Lua脚本"></a>Redis如何管理Lua脚本</h4><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="数据结构模型"><a href="#数据结构模型" class="headerlink" title="数据结构模型"></a>数据结构模型</h4><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><h4 id="BitMaps分析"><a href="#BitMaps分析" class="headerlink" title="BitMaps分析"></a>BitMaps分析</h4><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h4><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><h2 id="Ch-4-客户端"><a href="#Ch-4-客户端" class="headerlink" title="Ch 4 客户端"></a>Ch 4 客户端</h2><h3 id="客户端通信协议"><a href="#客户端通信协议" class="headerlink" title="客户端通信协议"></a>客户端通信协议</h3><h3 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h3><h3 id="Python客户端redis-python"><a href="#Python客户端redis-python" class="headerlink" title="Python客户端redis-python"></a>Python客户端redis-python</h3><h3 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h3><h3 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h3><h3 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h3><h2 id="Ch-5-持久化"><a href="#Ch-5-持久化" class="headerlink" title="Ch 5 持久化"></a>Ch 5 持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h3 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h3><h3 id="多实例部署"><a href="#多实例部署" class="headerlink" title="多实例部署"></a>多实例部署</h3><h2 id="Ch-6-复制"><a href="#Ch-6-复制" class="headerlink" title="Ch 6 复制"></a>Ch 6 复制</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h3><h2 id="Ch-7-阻塞"><a href="#Ch-7-阻塞" class="headerlink" title="Ch 7 阻塞"></a>Ch 7 阻塞</h2><h3 id="发现阻塞"><a href="#发现阻塞" class="headerlink" title="发现阻塞"></a>发现阻塞</h3><h3 id="内在原因"><a href="#内在原因" class="headerlink" title="内在原因"></a>内在原因</h3><h3 id="外在原因"><a href="#外在原因" class="headerlink" title="外在原因"></a>外在原因</h3><h2 id="Ch-8-理解内存"><a href="#Ch-8-理解内存" class="headerlink" title="Ch 8 理解内存"></a>Ch 8 理解内存</h2><h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>不负骤雨</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://xxyr.cc/post/Redis/redis-notes/" title="《Redis开发与运维》笔记">http://xxyr.cc/post/Redis/redis-notes/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"># Redis</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/post/Life/memories/" rel="next" title="回忆录">回忆录 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-1-初识Redis"><span class="nav-number">1.</span> <span class="nav-text">Ch 1 初识Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要特性"><span class="nav-number">1.1.</span> <span class="nav-text">主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis安装与启动"><span class="nav-number">1.3.</span> <span class="nav-text">Redis安装与启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis安装"><span class="nav-number">1.3.1.</span> <span class="nav-text">Redis安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis配置、启动、操作和关闭"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redis配置、启动、操作和关闭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-2-API的理解和使用"><span class="nav-number">2.</span> <span class="nav-text">Ch 2 API的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识、操作"><span class="nav-number">2.1.</span> <span class="nav-text">基础知识、操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">全局命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构和内部编码"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据结构和内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单线程架构"><span class="nav-number">2.1.3.</span> <span class="nav-text">单线程架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">2.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令"><span class="nav-number">2.2.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码"><span class="nav-number">2.2.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希"><span class="nav-number">2.3.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-2"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">2.4.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-3"><span class="nav-number">2.4.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">2.5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-4"><span class="nav-number">2.5.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序集合"><span class="nav-number">2.6.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-4"><span class="nav-number">2.6.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-4"><span class="nav-number">2.6.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-5"><span class="nav-number">2.6.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键管理"><span class="nav-number">2.7.</span> <span class="nav-text">键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个键管理"><span class="nav-number">2.7.1.</span> <span class="nav-text">单个键管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历键"><span class="nav-number">2.7.2.</span> <span class="nav-text">遍历键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库管理"><span class="nav-number">2.7.3.</span> <span class="nav-text">数据库管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-3-小功能大用处"><span class="nav-number">3.</span> <span class="nav-text">Ch 3 小功能大用处</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询分析"><span class="nav-number">3.1.</span> <span class="nav-text">慢查询分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两个配置参数"><span class="nav-number">3.1.1.</span> <span class="nav-text">两个配置参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作命令"><span class="nav-number">3.1.2.</span> <span class="nav-text">操作命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实践注意事项"><span class="nav-number">3.1.3.</span> <span class="nav-text">实践注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Shell"><span class="nav-number">3.2.</span> <span class="nav-text">Redis Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-cli"><span class="nav-number">3.2.1.</span> <span class="nav-text">redis-cli</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-server"><span class="nav-number">3.2.2.</span> <span class="nav-text">redis-server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-benchmark"><span class="nav-number">3.2.3.</span> <span class="nav-text">redis-benchmark</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipeline"><span class="nav-number">3.3.</span> <span class="nav-text">Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">3.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能测试"><span class="nav-number">3.3.2.</span> <span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生批量命令与Pipeline对比"><span class="nav-number">3.3.3.</span> <span class="nav-text">原生批量命令与Pipeline对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳实践"><span class="nav-number">3.3.4.</span> <span class="nav-text">最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务与Lua"><span class="nav-number">3.4.</span> <span class="nav-text">事务与Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务"><span class="nav-number">3.4.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lua用法简述"><span class="nav-number">3.4.2.</span> <span class="nav-text">Lua用法简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis与Lua"><span class="nav-number">3.4.3.</span> <span class="nav-text">Redis与Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">3.4.4.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis如何管理Lua脚本"><span class="nav-number">3.4.5.</span> <span class="nav-text">Redis如何管理Lua脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmaps"><span class="nav-number">3.5.</span> <span class="nav-text">Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构模型"><span class="nav-number">3.5.1.</span> <span class="nav-text">数据结构模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-5"><span class="nav-number">3.5.2.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BitMaps分析"><span class="nav-number">3.5.3.</span> <span class="nav-text">BitMaps分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">3.6.</span> <span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布订阅"><span class="nav-number">3.7.</span> <span class="nav-text">发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-6"><span class="nav-number">3.7.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-6"><span class="nav-number">3.7.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEO"><span class="nav-number">3.8.</span> <span class="nav-text">GEO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-4-客户端"><span class="nav-number">4.</span> <span class="nav-text">Ch 4 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端通信协议"><span class="nav-number">4.1.</span> <span class="nav-text">客户端通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java客户端Jedis"><span class="nav-number">4.2.</span> <span class="nav-text">Java客户端Jedis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python客户端redis-python"><span class="nav-number">4.3.</span> <span class="nav-text">Python客户端redis-python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端管理"><span class="nav-number">4.4.</span> <span class="nav-text">客户端管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端常见异常"><span class="nav-number">4.5.</span> <span class="nav-text">客户端常见异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端案例分析"><span class="nav-number">4.6.</span> <span class="nav-text">客户端案例分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-5-持久化"><span class="nav-number">5.</span> <span class="nav-text">Ch 5 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">5.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">5.2.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题定位与优化"><span class="nav-number">5.3.</span> <span class="nav-text">问题定位与优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多实例部署"><span class="nav-number">5.4.</span> <span class="nav-text">多实例部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-6-复制"><span class="nav-number">6.</span> <span class="nav-text">Ch 6 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">6.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑"><span class="nav-number">6.2.</span> <span class="nav-text">拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">6.3.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发与运维中的问题"><span class="nav-number">6.4.</span> <span class="nav-text">开发与运维中的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-7-阻塞"><span class="nav-number">7.</span> <span class="nav-text">Ch 7 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发现阻塞"><span class="nav-number">7.1.</span> <span class="nav-text">发现阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内在原因"><span class="nav-number">7.2.</span> <span class="nav-text">内在原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外在原因"><span class="nav-number">7.3.</span> <span class="nav-text">外在原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-8-理解内存"><span class="nav-number">8.</span> <span class="nav-text">Ch 8 理解内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存消耗"><span class="nav-number">8.1.</span> <span class="nav-text">内存消耗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-number">8.2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存优化"><span class="nav-number">8.3.</span> <span class="nav-text">内存优化</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="不负骤雨" src="https://i.loli.net/2019/12/15/ev4RZy7Iakn9WHl.jpg"><p class="site-author-name" itemprop="name">不负骤雨</p><div class="site-description" itemprop="description">reading coding keeping</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhishui1?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhishui1?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/349434614" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;349434614" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom bili"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/id/zhishui_x" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;zhishui_x" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i></a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">不负骤雨</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">71k</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: true,
      notify: true,
      appId: 'hOTS2YD4rcQy3T7bS94tywjn-gzGzoHsz',
      appKey: '4fQPAOtQk7tqm6wJ8kJxODvT',
      placeholder: "Just go go",
      avatar: 'wavatar',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html>