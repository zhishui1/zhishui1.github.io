<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://xxyr.cc").hostname,root:"/",scheme:"Gemini",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="《Redis开发与运维》学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="《Redis开发与运维》笔记"><meta property="og:url" content="https://xxyr.cc/post/Redis/redis-notes/index.html"><meta property="og:site_name" content="不负骤雨"><meta property="og:description" content="《Redis开发与运维》学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rjAmUx.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rjnP8x.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF3wuT.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rvp9KI.png"><meta property="og:image" content="https://s3.ax1x.com/2020/12/31/rvEkCV.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF8CPs.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sF8WJs.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/03/s9MDTP.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sFG9eO.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/05/sFG1Yj.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/10/s1V1QH.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/10/s1Znns.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/10/s1ZG3F.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/10/s1ZhUP.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/11/s3PLPe.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/11/s3ZWoq.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/11/s31HXV.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/ySdX1U.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/ySDgbQ.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9AMEn.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9MrG9.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9l5jI.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9q2CR.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9LGM6.png"><meta property="og:image" content="https://s3.ax1x.com/2021/01/28/y9LYqO.png"><meta property="article:published_time" content="2020-12-29T03:31:00.000Z"><meta property="article:modified_time" content="2021-01-28T13:02:35.834Z"><meta property="article:author" content="不负骤雨"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.ax1x.com/2020/12/31/rjAmUx.png"><link rel="canonical" href="https://xxyr.cc/post/Redis/redis-notes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>《Redis开发与运维》笔记 | 不负骤雨</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" style="margin:10px"><div class="container use-motion"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不负骤雨</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">围城</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">13</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">14</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xxyr.cc/post/Redis/redis-notes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s3.ax1x.com/2021/02/06/yY1Kx0.jpg"><meta itemprop="name" content="不负骤雨"><meta itemprop="description" content="reading coding keeping"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="不负骤雨"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Redis开发与运维》笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-29 11:31:00" itemprop="dateCreated datePublished" datetime="2020-12-29T11:31:00+08:00">2020-12-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-01-28 21:02:35" itemprop="dateModified" datetime="2021-01-28T21:02:35+08:00">2021-01-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span> </a></span></span><span id="/post/Redis/redis-notes/" class="post-meta-item leancloud_visitors" data-flag-title="《Redis开发与运维》笔记" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论次数：</span> <a title="valine" href="/post/Redis/redis-notes/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/Redis/redis-notes/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>《Redis开发与运维》学习笔记<a id="more"></a></p><h2 id="Ch-1-初识Redis"><a href="#Ch-1-初识Redis" class="headerlink" title="Ch 1 初识Redis"></a>Ch 1 初识Redis</h2><p>Redis（REmote Dictionary Server）——一种基于键值对的NoSQL数据库。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul><li><strong>速度快</strong><ul><li>所有数据存放在内存中。</li><li>基于C语言实现。</li><li>单线程架构。</li><li>源代码优化好。</li></ul></li><li><strong>基于键值对的数据结构服务器</strong><ul><li>Redis的值主要支持5种数据结构：字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）。</li><li>同时在字符串基础上演变了位图（Bitmaps）、HyperLogLog以及GEO（地理信息定位）等数据结构。</li></ul></li><li><strong>丰富的功能</strong><ul><li>键过期功能，实现缓存。</li><li>发布订阅功能，实现消息系统。</li><li>支持LUA脚本功能，用LUA创造出新的Redis命令。</li><li>简单的事务功能。</li><li>流水线功能，客户端能将命令一次性传到Redis。</li></ul></li><li><strong>简单稳定</strong><ul><li>源码相对较少。</li><li>使用单线程模型。</li><li>不依赖OS中的类库。</li><li>自己实现了事件处理的相关功能。</li></ul></li><li><strong>客户端语言多</strong><ul><li>提供简单的TCP通信协议</li><li>支持Java、PHP、Python、C、C++、Nodejs等. <a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a></li></ul></li><li><strong>持久化</strong><ul><li>RDB和AOF。</li></ul></li><li><strong>主从复制</strong><ul><li>分布式Redis的基础，实现多个相同数据的Redis副本。</li></ul></li><li><strong>高可用和分布式</strong></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>缓存</li><li>排行榜系统（列表和有序集合）</li><li>计数器应用（播放数、浏览数等）</li><li>社交网络（赞踩、粉丝、共同好友等）</li><li>消息队列系统</li><li>数据规模不宜过大、适用热数据（经常访问）</li></ul><h3 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h3><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><p><a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.redis.io/releases/redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-6.0.9 redis   <span class="comment">#创建软链接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>若显示 <code>install: 无法创建普通文件&#39;/usr/local/bin/redis-server&#39;: 权限不够</code><br>则执行<code>su root</code>获取root权限<br>不记得密码执行<code>sudo passwd root</code>修改密码<br>安装成功查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -v</span></span><br><span class="line">redis-cli 6.0.9</span><br></pre></td></tr></table></figure><h4 id="Redis配置、启动、操作和关闭"><a href="#Redis配置、启动、操作和关闭" class="headerlink" title="Redis配置、启动、操作和关闭"></a><span id="jump">Redis配置、启动、操作和关闭</span></h4><ul><li>三种启动方式<ul><li>默认配置启动<code>redis-server</code></li><li>运行启动（加上需修改的参数）<code>redis-server --port 6380</code></li><li>配置文件启动<code>redis-sever /opt/redis/redis.conf</code></li></ul></li><li>Redis命令行客户端<ul><li>交互式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set good day</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>命令方式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li></ul></li><li>停止Redis服务<br><code>redis-cli shutdown</code> （可选参数nosave|save是否生成持久化文件）</li></ul><h2 id="Ch-2-API的理解和使用"><a href="#Ch-2-API的理解和使用" class="headerlink" title="Ch 2 API的理解和使用"></a>Ch 2 API的理解和使用</h2><h3 id="基础知识、操作"><a href="#基础知识、操作" class="headerlink" title="基础知识、操作"></a>基础知识、操作</h3><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><ul><li>查看所有键<br><code>keys *</code><br>keys命令会遍历所有键，时间复杂度为O（n），线上环境禁止使用。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "good"</span><br><span class="line">2) "hello"</span><br></pre></td></tr></table></figure></li><li>键总数<br><code>dbsize</code><br>直接获取Redis内置的键总数变量，时间复杂度为O（1）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>检查键是否存在<br><code>exists key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists no_hello</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>删除键<br><code>del key1 key2 key3~</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del good hello</span><br><span class="line">(integer) 2                       #返回成功删除键的个数</span><br></pre></td></tr></table></figure></li><li>键过期<br><code>expire key seconds</code><br>对键添加过期时间，过期自动删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire hello 10   #单位：s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) 5                       #剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) -2                      #-2表示键不存在，-1表示键没有设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li>键的数据结构类型<br><code>type key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; type a</span><br><span class="line">none</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h4><p>优点：改进内部编码而不影响外部数据结构和命令，适应各种场景更加灵活，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjAmUx.png" alt=""></p><h4 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h4><ul><li>单线程首先不会出现并发问题，可以简化数据结构和算法的实现，并且避免了线程切换和竞态产生的消耗，但不适合某个命令执行时间过长的场景。</li><li>纯内存访问，重要基础。</li><li>非阻塞I/O，使用epoll作为I/O多路复用技术的实现以及自身事件模型，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjnP8x.png" alt=""></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Redis最基础的数据结构，键是字符串类型，字符串类型的值可以是字符串（JSON、XML等）、数字、二进制，值最大不能超过512MB。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>常用命令<ul><li>设置值<br><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code><br>ex seconds：为键设置秒级过期时间。<br>px milliseconds：为键设置毫秒级过期时间。<br>nx：等价于<code>setnx key value</code>，键必须不存在才能设置成功，用于添加（可以用于实现分布式锁）。<br>xx：等价于<code>setex key seconds value</code>，键必须存在才能设置成功，用于更新。</li><li>获取值<br><code>get key</code></li><li>批量设置值<br><code>mset key value key value···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>批量获取值<br><code>mget key key key···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget a b c d</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure></li><li>计数<br><code>incr key</code><br>用于对值做自增操作。<br>值必须是整数.<br>键不存在，按值为0自增，返回结果为1。<br>还有：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">decr key                    #自减</span><br><span class="line">incrby key incerement       #自增指定数字</span><br><span class="line">decrby key decrement        #自减指定数字</span><br><span class="line">incrbyfloat key incerement  #自增浮点数</span><br></pre></td></tr></table></figure></li></ul></li><li>不常用命令<ul><li>追加值<br><code>append key value</code><br>向字符串尾部追加值</li><li>字符串长度<br><code>strlen key</code><br>返回字节数</li><li>设置并返回原值<br><code>getset key value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset nice day</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset nice try</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>设置指定位置的字符<br><code>setrange key offset value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure></li><li>获取部分字符串<br><code>getrange key start end</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line">"be"</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF3wuT.png" alt=""></p><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>int<br>8个字节的长整型。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 8653</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure></li><li>embstr<br>小于等于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure></li><li>raw<br>大于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world···"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>缓存功能<br>Redis作为缓存层，MySQL作为存储层，如下图。<br><img src="https://s3.ax1x.com/2020/12/31/rvp9KI.png" alt=""><br>例如下面用于获取用户信息的伪代码。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id</span><br><span class="line">  value = redis.get(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">    userInfo = deserialize(value);    <span class="comment">#反序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo != null)</span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));   <span class="comment">#一小时过期时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">long incrVideoCounter(long id) &#123;</span><br><span class="line">  key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">  <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>共享Session<br>分布式Web服务使用Redis将用户的Session进行集中管理。<br><img src="https://s3.ax1x.com/2020/12/31/rvEkCV.png" alt=""></li><li>限速<br>例如网站限制一个IP地址在一定时间内的访问次数等。<br>用户获取验证码一分钟不超过5次的伪代码如下。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line">// SET key value EX <span class="number">60</span> NX</span><br><span class="line">isExists = redis.set(key,<span class="number">1</span>,<span class="string">"EX 60"</span>,<span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != null || redis.incr(key) &lt;=<span class="number">5</span>)&#123;</span><br><span class="line">  // 通过</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  // 限速</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>键值本身又是一对键值对结构，形如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = &#123;&#123;filed1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul><li>设置值<br><code>hset key filed value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取值<br><code>hget key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">"tom"</span><br></pre></td></tr></table></figure></li><li>删除field<br><code>hdel key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:1 name age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>计算field个数<br><code>hlen key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>批量设置或获取filed-value<br><code>hmset key filed1 value1 filed2 value2</code><br><code>hmget key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:1 name tom age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name age</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>判断filed是否存在<br><code>hexists key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取所有field<br><code>hkeys key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br></pre></td></tr></table></figure></li><li>获取所有value<br><code>hvals key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>获取所有的field-value<br><code>hgetall key</code>（个数较多会导致阻塞）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "tom"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br></pre></td></tr></table></figure></li><li>自增<br><code>hincrby key filed</code><br><code>hincrbyfloat key filed</code></li><li>计算value的字符串长度<br><code>hstrlen key filed</code>（Redis&gt;3.2）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen user:1 name</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8CPs.png" alt=""></p><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于hash-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于hash-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>hashtable（哈希表）<br>不满足ziplist时采用，O(1)。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>哈希类型是稀疏的，而关系型数据库是完全结构化的，且Redis不适合做复杂的关系查询，<br>以下为获取用户信息的伪代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  // 用户id作为key后缀</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">  // 使用hgetall获取所有用户信息映射关系</span><br><span class="line">  userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (userInfoMap != null) &#123;</span><br><span class="line">    // 将映射关系转换为UserInfo</span><br><span class="line">    userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 从MySQL中获取用户信息</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    // 将userInfo变为映射关系使用hmset保存到Redis中</span><br><span class="line">    redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">    // 添加过期时间</span><br><span class="line">    redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种缓存用户信息方法对比。</p><ul><li>原生字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 name tom</span><br><span class="line">set user:1 age 18</span><br></pre></td></tr></table></figure>每个属性一个键，简单直观，但内存占用大，用户信息内聚性差。</li><li>序列化字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 serialize(userinfo)</span><br></pre></td></tr></table></figure>简化编程，但序列化和反序列化有一定开销，且每次更新都要进行反序列化和序列化。</li><li>哈希类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset user:1 name tom age 18</span><br></pre></td></tr></table></figure>简单直观，合理使用可减少内存占用，但要注意两种内部编码的转换，hashtable会消耗更多内存。</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>可以存储多个<strong>有序</strong>、<strong>重复</strong>的字符串，每个字符串称为元素（个数不大于2^32-1），可以充当<strong>栈</strong>和<strong>队列</strong>。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul><li>添加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpush key value1 value2           #从右侧插入</span><br><span class="line">lpush key value1 value2           #从左侧插入</span><br><span class="line">linsert key before|after me you   #在me之前或之后插入you</span><br></pre></td></tr></table></figure></li><li>查找<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrange key start end              #从左至右为0到N-1，从右至左为-1到-N，end包含自身，0到-1为全部</span><br><span class="line">lindex key index                  #获取指定下标的元素</span><br><span class="line">llen key                          #获取列表长度</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpop key                          #从右侧删除</span><br><span class="line">lpop key                          #从右侧删除</span><br><span class="line">lrem key count value              #删除值等于value的元素</span><br><span class="line">                                  #count&gt;0，从左至右，最多删除count个元素</span><br><span class="line">                                  #count&lt;0，从右至左，最多删除count绝对值个元素</span><br><span class="line">                                  #count=0，删除所有</span><br><span class="line">ltrim key start end               #保留列表中start到end的元素</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure></li><li>阻塞式弹出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blpop key1 key2 timeout</span><br><span class="line">brpop key1 key2 timeout</span><br></pre></td></tr></table></figure>列表为空时，timeout=3则客户端等到3s后返回，timeout=0则一直阻塞。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 3</span><br><span class="line">(nil)</span><br><span class="line">(3.09s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">...阻塞中...</span><br></pre></td></tr></table></figure>此期间添加了数据element1，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list:test element1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br><span class="line">(90.81s)</span><br></pre></td></tr></table></figure>列表不为空，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br></pre></td></tr></table></figure>若多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取弹出的值。</li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8WJs.png" alt=""></p><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于list-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于list-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>linkedlist（链表）<br>不满足ziplist时采用。</li></ul><p>注：Redis 3.2 版本提供了quicklist编码，是以一个ziplist为节点的linkedlist，结合了两者的优势。</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>消息队列<br>使用lpush和brpop命令组合实现阻塞队列，如图。<br><img src="https://s3.ax1x.com/2021/01/03/s9MDTP.png" alt=""></li><li>文章列表<br>如分页展示文章列表。<ul><li>每篇文章使用哈希存储<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset acticle:1 title xx timestamp 1476536196 content xxxx</span><br></pre></td></tr></table></figure></li><li>向用户文章列表添加文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush user:1:acticles article:1 article:2</span><br></pre></td></tr></table></figure></li><li>分页获取用户文章列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">articles = lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">  hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush+lpop=Stack（ 栈）</span><br><span class="line">lpush+rpop=Queue（ 队列）</span><br><span class="line">lpsh+ltrim=Capped Collection（ 有限集合）</span><br><span class="line">lpush+brpop=Message Queue（ 消息队列）</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）用来保存多个<strong>无序</strong>字符串元素，且不允许有重复的元素，不支持下标索引。<br>一个集合可以存储2^32-1个元素<br>Redis支持集合内的增删改查以及集合间取交集、并集和差集。</p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内操作<ul><li>添加元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd key element1 element2</span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem key element1 element2</span><br></pre></td></tr></table></figure></li><li>计算元素个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scard key  #时间复杂度O(1)，直接调用Redis内部变量</span><br></pre></td></tr></table></figure></li><li>判断元素是否在集合中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></li><li>随机从集合返回指定个数的元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srandmember key count  #count默认为1</span><br></pre></td></tr></table></figure></li><li>从集合随机弹出count个元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop key count #Redis&gt;3.2，count默认为1</span><br></pre></td></tr></table></figure></li><li>获取所有元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间操作<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter key1 key2</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sunion key1 key2</span><br></pre></td></tr></table></figure></li><li>差集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure></li><li>将交集、并集和差集的结果保存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将key1和key2运算的结果保存在destination_key中</span></span><br><span class="line">sinterstore destination_key key1 key2</span><br><span class="line">sunionstore destination_key key1 key2</span><br><span class="line">sdiffstore destination_key key1 key2</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG9eO.png" alt=""></p><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>intset（整数集合）<br>更加节省内存。<br>使用场景：<ul><li>集合中都是整数且元素个数小于set-max-intset-entries配置（默认512个）</li></ul></li><li>hashtable（哈希表）<br>不满足intset时采用。</li></ul><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合典型的使用场景是<strong>标签</strong>（用于提升用户体验和增强用户黏度）。<br>注：用户和标签的关系维护应在一个事务内执行，防止部分命令失败造成的数据不一致。</p><ul><li>给用户添加标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>给标签添加用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>删除用户下的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>删除标签下的用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>计算用户共同感兴趣的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd=Tagging（标签）</span><br><span class="line">spop/srandmember=Random item（生成随机数， 比如抽奖）</span><br><span class="line">sadd+sinter=Social Graph（社交需求）</span><br></pre></td></tr></table></figure><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>相较于集合，有序集合中的元素依据分数进行排序，且元素不能重复但分数可以重复。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内<ul><li>添加成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 score2 member2</span><br><span class="line"></span><br><span class="line"><span class="meta">Redis&gt;</span><span class="bash">3.2，添加了如下参数：</span></span><br><span class="line">nx：member必须不存在才可以添加成功，用于添加。</span><br><span class="line">xx：member必须存在才可以添加成功，用于更新。</span><br><span class="line">ch：返回此次操作后，元素和分数发生变化的个数。</span><br><span class="line">incr：对score做增加，等于zincrby</span><br></pre></td></tr></table></figure></li><li>计算成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure></li><li>计算某个成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure></li><li>计算成员的排名<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrank key member  #分数从低到高</span><br><span class="line">zrevrank key member  #分数从高到低</span><br></pre></td></tr></table></figure></li><li>增加成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li><li>返回指定排名范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrange key start end [withscores]  #从低到高，withscores可选</span><br><span class="line">zrevrange key start end withscores</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]  #限制起始的位置和个数</span><br><span class="line">zrevrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line"></span><br><span class="line">limit offset count 可选参数，限制起始的位置和个数</span><br><span class="line">min和max支持开区间()和闭区间[]，-inf和+inf代表无穷小和无穷大</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li><li>删除成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem key member1 member2</span><br></pre></td></tr></table></figure></li><li>删除指定排名内的升序元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure></li><li>删除指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br><span class="line"></span><br><span class="line">destinatin：保存计算结果的键</span><br><span class="line">numkeys：参与计算键的个数</span><br><span class="line">weight：每个键的权重，每个键的member会将自己的分数乘以这个权重。</span><br><span class="line">aggregate sum|min|max：计算成员交集后，分数可以按照sum、min和max做汇总，默认sum。</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zunionstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG1Yj.png" alt=""></p><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于zset-max-ziplist-entries配置（默认128个）</li><li>同时所有的值小于zset-max-ziplist-value配置（默认64字节）</li></ul></li><li>skiplist（跳跃表）<br>不满足ziplist时采用。</li></ul><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景为排行榜系统。榜单的维度可以是多方面的。<br>例如视频网站对用户上传到视频做排行榜，使用赞数这个维度。</p><ul><li>添加用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd user:ranking:2021_01_05 3 mike  #用户mike上传了一个视频并获得了3个赞</span><br><span class="line">zincrby user:ranking:2021_01_05 1 mike  #之后又获得了一个赞</span><br></pre></td></tr></table></figure></li><li>取消用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li><li>展示获赞数最多前十用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrevrangebyrank user:ranking:2021_01_05 0 9</span><br></pre></td></tr></table></figure></li><li>展示用户信息及分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2021_01_05 mike</span><br><span class="line">zrank user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li></ul><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><p>关于键的一些通用命令介绍。<br>接2.1.1全局命令的一些其他命令。</p><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><ul><li><p>键重命名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure><p>（1）若rename的newkey已存在，那么该已存在的newkey的值会变成被rename的key的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set old a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set new b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rename old new</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get old</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get new</span><br><span class="line">"a"</span><br></pre></td></tr></table></figure><p>（2）为防止被强行rename，Redis提供了<code>renamenx</code>命令，只有newkey不存在时才能rename成功。<br>（3）由于重命名键期间会执行del删除旧的键，如果键对应的值较大，可能会导致阻塞。<br>（4）<code>rename key key</code>在3.2版本前会报错。</p></li><li><p>随机返回一个键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure></li><li><p>键过期</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire key seconds                      #键在seconds秒后过期</span><br><span class="line">pexpire key millionseconds              #毫秒级</span><br><span class="line">                                        #key不存在返回0</span><br><span class="line">                                        #seconds为负数，键会立即被删除</span><br><span class="line"></span><br><span class="line">expireat key timestamp                  #键在秒级时间戳timestamp后过期</span><br><span class="line">pexpireat key millionseconds-timestamp  #毫秒级</span><br><span class="line"></span><br><span class="line">ttl key                                 #查询键的剩余过期时间，单位秒。</span><br><span class="line">pttl key                                #毫秒级</span><br><span class="line">                                        #-1表示键没有设置过期时间，-2表示键不存在</span><br><span class="line"></span><br><span class="line">persist key                             #消除键的过期时间</span><br></pre></td></tr></table></figure><p>（1）无论何种方式，在Redis内部最终使用的是pexpireat。<br>（2）对于字符串类型的键，执行<code>set</code>命令会消除过期时间，详见源码中set命令的函数setKey。<br>（3）Redis不支持二级数据结构（哈希、列表等）内部元素的过期功能。<br>（4）<code>setex</code>作为set+expire的组合，不单是原子执行，且减少了一次网络通讯的时间。</p></li><li><p>迁移键</p><ul><li><p>move</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>Redis内部可以有多个数据库，且彼此相互隔离。move命令用于在Redis内部进行数据迁移。</p></li><li><p>dump+store</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value  #ttl为过期时间，=0不设置</span><br></pre></td></tr></table></figure><p>dump+store可实现不同Redis实例之间的数据迁移,整个迁移过程是非原子性的过程，且需要开启两个客户端连接。分为两步：<br>（1）在源Redis上执行dump，将键值序列化，为RDB格式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> <span class="built_in">set</span> hello world</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> dump hello</span></span><br><span class="line">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span><br></pre></td></tr></table></figure><p>（2）在目标Redis上执行restore，进行复原。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> restore hello 0 <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">"world</span><br></pre></td></tr></table></figure><p>对应伪代码为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Redis sourceRedis = new Redis("sourceMachine", 6379)</span><br><span class="line">Redis targetRedis = new Redis("targetMachine", 6379)</span><br><span class="line">targetRedis.restore("hello", 0, sourceRedis.dump(key))</span><br></pre></td></tr></table></figure></li><li><p>migrate</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key...]]</span><br><span class="line"></span><br><span class="line">host：              目标Redis的IP地址。</span><br><span class="line">port：              目标Redis的端口。</span><br><span class="line">key|""：            在Redis3.0.6版本之前，migrate只支持迁移一个键，所以此处是要迁移的键，</span><br><span class="line">                    在Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串""。</span><br><span class="line">destination-db：    目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</span><br><span class="line">timeout：           迁移的超时时间（单位为毫秒）。</span><br><span class="line">[copy]：            如果添加此选项，迁移后并不删除源键。</span><br><span class="line">[replace]：         如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</span><br><span class="line">[keys key[key...]]：迁移多个键，例如要迁移key1、key2、key3，此处填写“keys key1 key2 key3”。</span><br></pre></td></tr></table></figure><p>（1）migrate命令也是用于在Redis实例间进行数据迁移，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率。<br>（2）第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。第二，migrate命令的数据传输直接在源Redis和目标Redis上完成。第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</p><p>示例：</p><ul><li>源Redis有键hello，目标Redis没有<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis和目标Redis都有键hello<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000</span><br><span class="line">(error) ERR Target instance replied with error: BUSYKEY Target key name already exists.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000 replace</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis没有键hello。如下所示，此种情况会收到nokey的提示<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">NOKEY</span><br></pre></td></tr></table></figure></li><li>源Redis执行如下命令完成多个键的迁移<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 "" 0 5000 keys key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><ul><li><p>全量遍历键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keys pattern  #patterm使用glob风格通配符</span><br><span class="line"></span><br><span class="line">* 代表匹配所有任意字符</span><br><span class="line">? 代表匹配一个任意字符</span><br><span class="line">[1,3] 代表匹配1和3，[1-3] 代表匹配1到3的任意数字</span><br><span class="line">\x 转义字符</span><br></pre></td></tr></table></figure><p>考虑到Redis的单线程架构，keys命令一般只在以下三种情况使用：</p><ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但是会影响到主从复制。</li><li>如果确认键值总数确实比较少，可以执行该命令。</li><li>使用scan命令渐进式的遍历所有键。</li></ul></li><li><p>渐进式遍历</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br><span class="line"></span><br><span class="line">cursor：是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</span><br><span class="line">match pattern：可选参数，作用是做模式匹配。</span><br><span class="line">count number：可选参数，作用是表明每次要遍历的键个数，默认值是10，可以适当增大。</span><br></pre></td></tr></table></figure><p>Redis存储键值对实际使用hashtable作为内部编码。<br>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "15"</span><br><span class="line">2)  1) "new"</span><br><span class="line">    2) "c"</span><br><span class="line">    3) "a"</span><br><span class="line">    4) "key"</span><br><span class="line">    5) "nice"</span><br><span class="line">    6) "b"</span><br><span class="line">    7) "mylist"</span><br><span class="line">    8) "d"</span><br><span class="line">    9) "redis"</span><br><span class="line">  10) "user:1"</span><br><span class="line">127.0.0.1:6379&gt; scan 15</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "hello"</span><br></pre></td></tr></table></figure><p>除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如hgetall、smembers、zrange可能产生的阻塞问题，对应的命令分别是hscan、sscan、zscan。<br>需要注意的是scan过程中如果有键的变化，那么可能会遍历重复的键，而遍历不到新增的键。</p></li></ul><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><ul><li><p>切换数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select dbIndex</span><br></pre></td></tr></table></figure><p>Redis只用数字来标识数据库，默认有16个，各数据库独立。<br>但是该功能已逐步废弃了，原因如下：</p><ul><li>Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响。</li><li>多数据库的使用方式，会让调试和运维不同业务的数据库变的困难，假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困难。</li><li>部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱。<br>所以在需要多个数据库功能的情况下，可以在一台机器上部署多个Redis实例，以端口来区分。</li></ul></li><li><p>flushdb和flushall<br>flushdb只清除当前数据库，flushall会清除所有数据库。<br>带来的问题：</p><ul><li>flushdb/flushall命令会将所有数据清除，一旦误操作后果不堪设想。</li><li>如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能性。</li></ul></li></ul><h2 id="Ch-3-小功能大用处"><a href="#Ch-3-小功能大用处" class="headerlink" title="Ch 3 小功能大用处"></a>Ch 3 小功能大用处</h2><h3 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h3><p>发送命令&gt;命令排队&gt;命令执行&gt;返回结果<br>慢查询只统计命令执行的时间，并不反映客户端的超时问题。</p><h4 id="两个配置参数"><a href="#两个配置参数" class="headerlink" title="两个配置参数"></a>两个配置参数</h4><ul><li>预设阈值<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">单位：微秒，默认值=10000</span><br><span class="line">等于0会记录所有记录，小于0不记录任何命令</span><br></pre></td></tr></table></figure></li><li>慢查询记录存放位置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">Redis使用一个列表来存储慢查询日志（类似队列），</span><br><span class="line">slowlog-max-len指定列表最大长度</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><ul><li>获取慢查询日志<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog get [n]  #n可选，指定条数</span><br><span class="line"></span><br><span class="line">每个慢查询记录有4个属性，分别为：</span><br><span class="line">标识id、发生时间戳、命令耗时以及执行的命令和参数。</span><br></pre></td></tr></table></figure></li><li>获取慢查询日志列表当前长度<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></table></figure></li><li>慢查询日志重置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></li></ul><h4 id="实践注意事项"><a href="#实践注意事项" class="headerlink" title="实践注意事项"></a>实践注意事项</h4><ul><li><strong>slowlog-max-len配置建议</strong>：线上建议调大慢查询列表，可设置为1000以上，记录慢查询时Redis会对长命令做截断操作，并不会占用大量内存，增大慢查询列表可以减缓慢查询被剔除的可能。</li><li><strong>slowlog-log-slower-than配置建议</strong>：默认值超过10毫秒判定为慢查询，需要根据Redis并发量调整该值。由于Redis采用单线程响应命令，对于高流量的场景，如果命令执行时间在1毫秒以上，那么Redis最多可支撑OPS不到1000，因此对于高OPS场景的Redis建议设置为1毫秒。</li><li><strong>慢查询只记录命令执行时间</strong>，并不包括命令排队和网络传输时间，因此客户端执行命令的时间会大于命令实际执行时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此当客户端出现请求超时，需要检查该时间点是否有对应的慢查询，从而分析出是否为慢查询导致的命令级联阻塞。</li><li><strong>慢查询日志是一个先进先出的队列</strong>，如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化到其他存储中（例如MySQL），然后可以制作可视化界面进行查询，第13章介绍的Redis私有云CacheCloud提供了这样的功能，好的工具可以让问题排查事半功倍。</li></ul><h3 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h3><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><ul><li>-r<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 ping</span><br><span class="line"></span><br><span class="line">将ping命令执行3次</span><br></pre></td></tr></table></figure></li><li>-i（interval）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 -i 1 ping</span><br><span class="line"></span><br><span class="line">每隔几秒执行一次一次命令，单位：秒</span><br><span class="line">-i必须与-r一起用</span><br></pre></td></tr></table></figure></li><li>-x<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "world" | redis-cli -x set hello</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">-x选项代表从标准输入（stdin）读取数据作为redis-cli的最后一个参数。</span><br></pre></td></tr></table></figure></li><li>-c（cluster）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">连接Redis Cluster节点时需要使用，-c选项可以防止moved和ask异常，有关Redis Cluster将在第10章介绍。</span><br></pre></td></tr></table></figure></li><li>-a（auth）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果Redis配置了密码，可以用-a（auth）选项，有了这个选项就不需要手动输入auth命令。</span><br></pre></td></tr></table></figure></li><li>–scan和–pattern<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--scan选项和--pattern选项用于扫描指定模式的键，相当于使用scan命令。</span><br></pre></td></tr></table></figure></li><li>–slave<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--slave选项是把当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作，</span><br><span class="line">有关于Redis复制将在第6章进行详细介绍。</span><br><span class="line">合理的利用这个选项可以记录当前连接Redis节点的一些更新操作，</span><br><span class="line">这些更新操作很可能是实际开发业务时需要的数据。</span><br></pre></td></tr></table></figure></li><li>–rdb<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--rdb选项会请求Redis实例生成并发送RDB持久化文件，保存在本地。可使用它做持久化文件的定期备份。</span><br><span class="line">有关Redis持久化将在第5章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–pipe<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--pipe选项用于将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行，</span><br><span class="line">有关Redis通信协议将在第4章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–bigkeys<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--bigkeys选项使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈。</span><br></pre></td></tr></table></figure></li><li>–eval<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--eval选项用于执行指定Lua脚本，有关Lua脚本的使用将在3.4节介绍。</span><br></pre></td></tr></table></figure></li><li>–latency<br>用于检测网络延迟，有三个选项<ul><li>–lantency<br>该选项可以测试客户端到目标Redis的网络延迟，<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h &#123;server&#125; --latency</span><br></pre></td></tr></table></figure></li><li>–latency-history</li><li>-latency的执行结果只有一条，如果想以分时段的形式了解延迟信息，可以使用–latency-history选项，可以通过-i参数控制间隔时间。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.xx.xx --latency-history -i 10</span><br></pre></td></tr></table></figure></li><li>–latency-dist<br>该选项会使用统计图表的形式从控制台输出延迟统计信息。</li></ul></li><li>–stat<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--stat选项可以实时获取Redis的重要统计信息.</span><br></pre></td></tr></table></figure></li><li>–raw和–no-raw<br>–no-raw选项要求命令的返回结果必须是原始的格式，–raw返回格式化后的结果。</li></ul><h4 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h4><p>redis-server启动Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认配置启动`redis-server`</span><br><span class="line">运行启动（加上需修改的参数）`redis-server --port 6380`</span><br><span class="line">配置文件启动`redis-sever /opt/redis/redis.conf`</span><br></pre></td></tr></table></figure><p>redis-server除了启动Redis外，还有一个–test-memory选项，可以用来检测当前操作系统能否稳定地分配指定容量的内存给Redis，通过这种检测可以有效避免因为内存问题造成Redis崩溃。<br>下面的命令检测当前操作系统能否提供1G的内存给Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server --test-memory 1024</span><br></pre></td></tr></table></figure><h4 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h4><p>redis-benchmark可以为Redis做基准性能测试。</p><ul><li>-c（clients）<br>-c选项代表客户端的并发数量（默认是50）。</li><li>-n（num）<br>-n选项代表客户端请求总量（默认是100000）。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000</span><br><span class="line"></span><br><span class="line">代表测试100个客户端同时请求Redis，共执行20000次时的性能</span><br><span class="line">output：</span><br><span class="line">====== GET ======</span><br><span class="line">20000 requests completed in 0.27 seconds</span><br><span class="line">100 parallel clients</span><br><span class="line">3 bytes payload</span><br><span class="line">keep alive: 1</span><br><span class="line"></span><br><span class="line">99.11% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">73529.41 requests per second</span><br></pre></td></tr></table></figure></li><li>-q<br>-q选项仅仅显示redis-benchmark的requests per second信息。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000 -q</span><br></pre></td></tr></table></figure></li><li>-r<br>在一个空的Redis上执行了redis-benchmark会发现只有3个键：<code>counter:__rand_int__</code>、<code>mylist</code>和<code>key:__rand_int__</code>。<br>如果想向Redis插入更多的键，可以执行使用-r（random）选项，可以向Redis插入更多随机的键。<br>-r选项会在key、counter键上加一个12位的后缀，-r 10000代表只对后四位做随机处理（-r不是随机数的个数）。</li><li>-P<br>-P选项代表每个请求pipeline的数据量（默认为1）。</li><li>-k<br>-k选项代表客户端是否使用keepalive，1为使用，0为不使用，默认值为1。</li><li>-t<br>-t选项可以对指定命令进行基准测试。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set -q</span><br><span class="line">SET: 98619.32 requests per second</span><br><span class="line">GET: 97560.98 requests per second</span><br></pre></td></tr></table></figure></li><li>–csv<br>–csv选项会将结果按照csv格式输出，便于后续处理，如导出到Excel等。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set --csv</span><br><span class="line">"SET","81300.81"</span><br><span class="line">"GET","79051.38"</span><br></pre></td></tr></table></figure></li></ul><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Redis客户端从发送命令到接收到返回结果的时间为一次RTT，Redis提供的批量操作命令能减少RTT，但大部分命令并不支持批量操作。</li><li>Pipeline（流水线）机制，能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</li><li>redis-cli的–pipe选项实际上就是使用Pipeline机制，例如下面操作将set hello world和incr counter两条命令组装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -en '*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n*2\r\n$4\r\nincr\r\</span><br><span class="line">    n$7\r\ncounter\r\n' | redis-cli --pipe</span><br></pre></td></tr></table></figure></li></ul><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><ul><li>Pipeline执行速度一般比逐条执行要快。</li><li>客户端和服务端的网络延时越大，Pipeline的效果越明显。</li></ul><h4 id="原生批量命令与Pipeline对比"><a href="#原生批量命令与Pipeline对比" class="headerlink" title="原生批量命令与Pipeline对比"></a>原生批量命令与Pipeline对比</h4><ul><li>原生批量命令是原子的，Pipeline是非原子的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</li><li>Pipeline虽然只能操作一个Redis实例，但是即使在分布式Redis场景中，也可以作为批量操作的重要优化手段，具体细节见第11章。</li></ul><h3 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h3><p>为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>将一组需一起执行的命令放在<code>multi</code>和<code>exec</code>之间，若要停止事务的执行，使用<code>discard</code>命令代替<code>exec</code>。<br>若事务中出现错误，Redis有不同的处理机制：</p><ul><li>命令错误<br>命令写错造成的语法错误，整个事务无法执行。</li><li>运行时错误<br>命令写错但仍是可执行的命令，<strong>Redis不支持回滚操作</strong>，只能自行修复。<br>有些应用场景需要在事务之前，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁，其他客户端的修改会执行）。Redis提供了watch命令来解决这类问题。</li></ul><h4 id="Lua用法简述"><a href="#Lua用法简述" class="headerlink" title="Lua用法简述"></a>Lua用法简述</h4><p>Lua语言在1993年由巴西一个大学研究小组发明，其设计目标是作为嵌入式程序移植到其他应用程序，由C语言实现，虽然简单小巧但是功能强大，许多应用都选用它作为脚本语言。官网：<a href="http://www.lua.org/" target="_blank" rel="noopener">http://www.lua.org/</a></p><ul><li><p>数据类型及其逻辑处理<br>Lua语言提供了如下几种数据类型：booleans（布尔）、numbers（数值）、strings（字符串）、tables（表格）。<br>Lua的基本数据类型和逻辑处理示例如下：</p><ul><li>字符串<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> strings val = <span class="string">"test"</span>  <span class="comment">--local代表局部变量</span></span><br></pre></td></tr></table></figure></li><li>数组<br>使用tables类型，数组下标从1开始。<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tables myArray = &#123;<span class="string">"redis"</span>, <span class="string">"jedis"</span>, <span class="literal">true</span>, <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">3</span>])</span><br><span class="line"><span class="comment">--true</span></span><br></pre></td></tr></table></figure><ul><li>for<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray  <span class="comment">--#获取myArray（tables类型）长度</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>或是<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(myArray)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(index)</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>while<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> int i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sum = sum +i</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"><span class="comment">--输出结果为5050</span></span><br></pre></td></tr></table></figure></li><li>if else<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>哈希<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tables user_1 = &#123;age = <span class="number">28</span>, name = <span class="string">"tome"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(user_1[<span class="string">"age"</span>])</span><br><span class="line"><span class="comment">--28</span></span><br><span class="line">```    </span><br><span class="line">遍历：</span><br><span class="line">```lua</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(user_1)</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">print</span>(key .. value)  <span class="comment">--..用来连接字符串</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数定义</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contact</span><span class="params">(str1, str2)</span></span></span><br><span class="line">  <span class="keyword">return</span> str1 .. str2</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Redis与Lua"><a href="#Redis与Lua" class="headerlink" title="Redis与Lua"></a>Redis与Lua</h4><ul><li><p>在Redis中使用Lua<br>在Redis中执行Lua脚本有以下两种方法：</p><ul><li>eval<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval 脚本内容 key个数 key列表 参数列表</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; eval 'return "hello " .. KEYS[1] .. ARGV[1]' 1 redis world</span><br><span class="line">"hello redisworld"</span><br></pre></td></tr></table></figure>此外还可使用<code>redis-cli --eval</code>直接执行Lua文件。</li><li>evalsha<br>首先将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和，evalsha命令使用SHA1作为参数可以直接执行对应Lua脚本，避免每次发送Lua脚本的开销。这样客户端就不需要每次执行脚本内容，而脚本也会常驻在服务端，脚本功能得到了复用。<ul><li>加载脚本<br>script load命令可以将脚本内容加载到Redis内存中，得到SHA1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli script load "$(cat lua_get.lua)"</span><br><span class="line">"7413dc2440db1fea7c0a0bde841fa68eefaf149c"</span><br></pre></td></tr></table></figure></li><li>执行脚本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">evalsha 脚本SHA1值 key个数 key列表 参数列表</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; evalsha 7413dc2440db1fea7c0a0bde841fa68eefaf149c 1 redis world</span><br><span class="line">"hello redisworld"</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Lua的RedisAPI</p><ul><li>Lua可以使用<code>redis.call</code>函数实现对Redis的访问，例如下面代码是Lua使用redis.call调用了Redis的set和get操作：<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">"set"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">redis.call(<span class="string">"get"</span>, <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>放在Redis中的效果如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval 'return redis.call("get", KEYS[1])' 1 hello</span><br><span class="line">"world"</span><br></pre></td></tr></table></figure></li><li>如果<code>redis.call</code>执行失败，那么脚本执行结束会直接返回错误，而<code>redis.pcall</code>会忽略错误继续执行脚本，所以在实际开发中要根据具体的应用场景进行函数的选择。</li><li>Lua可以使用redis.log函数将Lua脚本的日志输出到Redis的日志文件中，但是一定要控制日志级别。Redis3.2提供了Lua Script Debugger功能用来调试复杂的Lua脚本，具体可以参考：<a href="http://redis.io/topics/ldb" target="_blank" rel="noopener">http://redis.io/topics/ldb</a>。</li></ul></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>Lua脚本功能为Redis开发和运维人员带来如下三个好处：</p><ul><li>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</li><li>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这些命令常驻在Redis内存中，实现复用的效果。</li><li>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</li></ul><p>示例：<br>当前列表记录着热门用户的id，假设这个列表有5个元素，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange hot:user:list 0 -1</span><br><span class="line">1) "user:1:ratio"</span><br><span class="line">2) "user:8:ratio"</span><br><span class="line">3) "user:3:ratio"</span><br><span class="line">4) "user:99:ratio"</span><br><span class="line">5) "user:72:ratio"</span><br></pre></td></tr></table></figure><p>user:{id}:ratio代表用户的热度，它本身又是一个字符串类型的键：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget user:1:ratio user:8:ratio user:3:ratio user:99:ratio</span><br><span class="line">user:72:ratio</span><br><span class="line">1) "986"</span><br><span class="line">2) "762"</span><br><span class="line">3) "556"</span><br><span class="line">4) "400"</span><br><span class="line">5) "101"</span><br></pre></td></tr></table></figure><p>现要求将列表内所有的键对应热度做加1操作，并且保证是原子执行，此功能可以利用Lua脚本来实现：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> mylist = redis.call(<span class="string">"lrange"</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, <span class="number">-1</span>)  <span class="comment">--将列表中所有元素取出， 赋值给mylist</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span> <span class="comment">--定义局部变量count=0，这个count就是最后incr的总次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--遍历mylist中所有元素，每次做完count自增，最后返回count</span></span><br><span class="line"><span class="keyword">for</span> index,key <span class="keyword">in</span> <span class="built_in">ipairs</span>(mylist)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  redis.call(<span class="string">"incr"</span>,key)</span><br><span class="line">  count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>将上述脚本写入lrange_and_mincr.lua文件中，并执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --eval lrange_and_mincr.lua hot:user:list</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h4 id="Redis如何管理Lua脚本"><a href="#Redis如何管理Lua脚本" class="headerlink" title="Redis如何管理Lua脚本"></a>Redis如何管理Lua脚本</h4><ul><li>script load<br><code>script load script</code><br>此命令用于将Lua脚本加载到Redis内存中</li><li>script exists<br><code>scripts exists sha1 [sha1 …]</code><br>此命令用于判断sha1是否已经加载到Redis内存中：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; script exists a5260dd66ce02462c5b5231c727b3f7772c0bcc5</span><br><span class="line">1) (integer) 1</span><br></pre></td></tr></table></figure></li><li>script flush<br><code>script flush</code><br>此命令用于清除Redis内存已经加载的所有Lua脚本。</li><li>script kill<br><code>script kill</code><br>此命令用于杀掉正在执行的Lua脚本。<br>但是有一点需要注意，如果当前Lua脚本正在执行写操作，那么<code>script kill</code>将不会生效。<br>此时，可以执行<code>shutdown save|nosave</code>停掉Redis服务。</li></ul><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="数据结构模型"><a href="#数据结构模型" class="headerlink" title="数据结构模型"></a>数据结构模型</h4><p><img src="https://s3.ax1x.com/2021/01/10/s1V1QH.png" alt="字符串&quot;big&quot;用二进制表示"></p><ul><li>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</li></ul><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><p>本节将每个独立用户是否访问过网站存放在Bitmaps中，将访问的用户记做1，没有访问的用户记做0，用偏移量作为用户的id。</p><ul><li>设置值<br>设置键的第offset个位的值（从0算起）<br><code>setbit key offset value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setbit unique:users:2016-04-05 0 1</span><br></pre></td></tr></table></figure>很多应用的用户id以一个指定数字（例如10000）开头，直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做setbit操作时将用户id减去这个指定数字。在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞。</li><li>获取值<br><code>getbit key offset</code></li><li>获取Bitmaps指定范围值为1的个数<br><code>bitcount key [start end]</code><br>start和end代表起始和结束字节数</li><li>Bitmaps间的运算<br><code>bitop op destinatin_key key [key...]</code><br>op：and、or、not、xor（异或）。<br>结果保存在destinatin_key中。</li><li>计算Bitmaps中第一个值为targitBit的偏移量<br><code>bitpos key targetBit [start] [end]</code><br>计算第0个字节到第1个字节之间， 第一个值为0的偏移量:<br><code>bitpos unique:users:2016-04-04 0 0 1</code></li></ul><h4 id="BitMaps分析"><a href="#BitMaps分析" class="headerlink" title="BitMaps分析"></a>BitMaps分析</h4><ul><li>假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户可以得到:<br><img src="https://s3.ax1x.com/2021/01/10/s1Znns.png" alt="set和Bitmaps存储一天活跃用户的对比"><br>随着时间推移节省的内存是非常可观的:<br><img src="https://s3.ax1x.com/2021/01/10/s1ZG3F.png" alt="set和Bitmaps存储独立用户空间对比"></li><li>但Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有10万（大量的僵尸用户），那么两者的对比如图：<br><img src="https://s3.ax1x.com/2021/01/10/s1ZhUP.png" alt="set和Bitmaps存储一天活跃用户的对比（独立用户比较少）"></li></ul><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。HyperLogLog提供了3个命令：pfadd、pfcount、pfmerge。</p><ul><li>添加<br><code>pfadd key element [element...]</code></li><li>计算独立用户数<br><code>pfcount key [key...]</code><br>使用脚本向HyperLogLog插入100万个id，插入前记录一下info memory：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:835144</span><br><span class="line">used_memory_human:815.57K</span><br></pre></td></tr></table></figure>向2016_05_01:unique:ids插入100万个用户，每次插入1000条：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">elements=""</span><br><span class="line">key="2016_05_01:unique:ids"</span><br><span class="line">for i in `seq 1 1000000`</span><br><span class="line">do</span><br><span class="line">  elements="$&#123;elements&#125; uuid-"$&#123;i&#125;</span><br><span class="line">if [[ $((i%1000)) == 0 ]];</span><br><span class="line">then</span><br><span class="line">  redis-cli pfadd $&#123;key&#125; $&#123;elements&#125;</span><br><span class="line">  elements=""</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>当上述代码执行完成后，可以看到内存只增加了15K左右：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:850616</span><br><span class="line">used_memory_human:830.68K</span><br></pre></td></tr></table></figure>但同时可以看到pfcount的执行结果并不是100万：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfcount 2016_05_01:unique:ids</span><br><span class="line">(integer) 1009838</span><br></pre></td></tr></table></figure>可以对100万个uuid使用集合类型进行测试，代码如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">elements=""</span><br><span class="line">key="2016_05_01:unique:ids:set"</span><br><span class="line">for i in `seq 1 1000000`</span><br><span class="line">do</span><br><span class="line">  elements="$&#123;elements&#125; "$&#123;i&#125;</span><br><span class="line">if [[ $((i%1000)) == 0 ]];</span><br><span class="line">then</span><br><span class="line">  redis-cli sadd $&#123;key&#125; $&#123;elements&#125;</span><br><span class="line">  elements=""</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>可以看到内存使用了84MB：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:88702680</span><br><span class="line">used_memory_human:84.59M</span><br></pre></td></tr></table></figure>但独立用户数为100万：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard 2016_05_01:unique:ids:set</span><br><span class="line">(integer) 1000000</span><br></pre></td></tr></table></figure>HyperLogLog内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是100%的正确，其中一定存在误差率。Redis官方给出的数字是0.81%的失误率，因此选用原则主要为：<ul><li>只为了计算独立总数，不需要获取单条数据。</li><li>可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。</li></ul></li><li>合并<br>求并集。<br><code>pfmerge destinatin_key sourcekey [sourcekey ...]</code></li></ul><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis提供了基于“发布/订阅”模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消息， 订阅该频道的每个客户端都可以收到该消息，如图。<br><img src="https://s3.ax1x.com/2021/01/11/s3PLPe.png" alt="Redis发布订阅模型"></p><h4 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h4><ul><li>发布消息<br><code>publish channel message</code></li><li>订阅消息<br><code>subscribe channel [channel ...]</code><br>有关订阅命令有两点需要注意：<ul><li>客户端在执行订阅命令之后进入了订阅状态，只能接收subscribe、psubscribe、unsubscribe、punsubscribe的四个命令。</li><li>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化。</li></ul></li><li>取消订阅<br><code>unsubscribe channel [channel ...]</code></li><li>按照模式订阅和取消订阅<br>pattern支持glob风格。<br><code>psubscribe pattern [pattern ...]</code><br><code>punsubscribe [pattern [pattern ...]]</code></li><li>查询订阅<ul><li>查看活跃的频道<br>至少有一个订阅者的频道。<br><code>pubsub channels [pattern]</code></li><li>查看频道订阅数<br><code>pubsub numsub [channel ...]</code></li><li>查看模式订阅数<br>通过模式来订阅的客户端数。<br><code>pubsub numpat</code></li></ul></li></ul><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式。<br>如图，图中有两套业务，上面为视频管理系统，负责管理视频信息；下面为视频服务面向客户，用户可以通过各种客户端（手机、浏览器、接口）获取到视频信息。<br><img src="https://s3.ax1x.com/2021/01/11/s3ZWoq.png" alt="发布订阅用于视频信息变化通知"></p><ul><li>视频服务订阅video:changes频道如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subscribe video:changes</span><br></pre></td></tr></table></figure></li><li>视频管理系统发布消息到video:changes频道如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">publish video:changes "video1,video3,video5"</span><br></pre></td></tr></table></figure></li><li>当视频服务收到消息，对视频信息进行更新，如下所示：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for video in video1,video3,video5</span><br><span class="line">  update &#123;video&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis3.2版本提供了GEO（地理信息定位）功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能，<br>GEO功能是Redis的另一位作者Matt Stancliff借鉴NoSQL数据库Ardb实现的，Ardb的作者来自中国，它提供了优秀的GEO功能。</p><ul><li><p>增加地理位置信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br><span class="line"></span><br><span class="line">longitude、latitude、member分别是该地理位置的经度、纬度、成员：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geoadd cities:locations 116.28 39.55 beijing</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果需要更新地理位置信息，仍然可以使用geoadd命令，虽然返回结果为0。</p></li><li><p>获取地理位置信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geopos cities:locations tianjin</span><br><span class="line">1) 1) "117.12000042200088501"</span><br><span class="line">2) "39.0800000535766543"</span><br></pre></td></tr></table></figure></li><li><p>获取两个地理位置的距离</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br><span class="line"></span><br><span class="line">unit代表返回结果的单位，包含四种：</span><br><span class="line">m（meters）代表米。</span><br><span class="line">km（kilometers）代表公里。</span><br><span class="line">mi（miles）代表英里。</span><br><span class="line">ft（ feet）代表尺。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geodist cities:locations tianjin beijing km</span><br><span class="line">"89.2061"</span><br></pre></td></tr></table></figure></li><li><p>获取指定位置范围内的地理信息位置集合</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist]</span><br><span class="line">  [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist]</span><br><span class="line">  [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br></pre></td></tr></table></figure><p>georadius命令的中心位置给出了具体的经纬度，georadiusbymember只需给出成员即可。其中radiusm|km|ft|mi是必需参数，指定了半径（带单位）。剩下的参数如下：</p><ul><li>withcoord：返回结果中包含经纬度。</li><li>withdist：返回结果中包含离中心节点位置的距离。</li><li>withhash：返回结果中包含geohash，有关geohash后面介绍。</li><li>COUNT count：指定返回结果的数量。</li><li>asc|desc：返回结果按照离中心节点的距离做升序或者降序。</li><li>store key：将返回结果的地理位置信息保存到指定键。</li><li>storedist key：将返回结果离中心节点的距离保存到指定键。</li></ul><p>下面操作计算五座城市中， 距离北京150公里以内的城市：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember cities:locations beijing 150 km</span><br><span class="line">1) "beijing"</span><br><span class="line">2) "tianjin"</span><br><span class="line">3) "tangshan"</span><br><span class="line">4) "baoding"</span><br></pre></td></tr></table></figure></li><li><p>获取geohash<br>Redis使用geohash将二维经纬度转换为一维字符串</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geohash key member [member ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geohash cities:locations beijing</span><br><span class="line">1) "wx4ww02w070"</span><br></pre></td></tr></table></figure><p>geohash有如下特点：</p><ul><li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中。</li><li>字符串越长，表示的位置更精确。<br><img src="https://s3.ax1x.com/2021/01/11/s31HXV.png" alt=""></li><li>两个字符串越相似，它们之间的距离越近，Redis利用字符串前缀匹配算法实现相关的命令。</li><li>geohash编码和经纬度是可以相互转换的。</li></ul></li><li><p>删除地理位置信息<br>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch-4-客户端"><a href="#Ch-4-客户端" class="headerlink" title="Ch 4 客户端"></a>Ch 4 客户端</h2><p>几乎所有的主流编程语言都有Redis的客户端<a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a>，不考虑Redis非常流行的原因，如果站在技术的角度看原因还有两个：</p><ul><li>客户端与服务端之间的通信协议是在TCP协议之上构建的。</li><li>Redis制定了RESP（REdis Serialization Protocol， Redis序列化协议）实现客户端与服务端的正常交互，这种协议简单高效 既能够被机器解析，又容易被人类识别。</li></ul><h3 id="客户端通信协议"><a href="#客户端通信协议" class="headerlink" title="客户端通信协议"></a>客户端通信协议</h3><h4 id="发送命令格式"><a href="#发送命令格式" class="headerlink" title="发送命令格式"></a>发送命令格式</h4><p>RESP规定一条命令的格式如下，CRLF代表”\r\n”。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*&lt;参数数量&gt; CRLF</span><br><span class="line"><span class="meta">$</span><span class="bash">&lt;参数1的字节数量&gt; CRLF</span></span><br><span class="line">&lt;参数1&gt; CRLF</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash">&lt;参数N的字节数量&gt; CRLF</span></span><br><span class="line">&lt;参数N&gt; CRLF</span><br></pre></td></tr></table></figure><p>以<code>set hello world</code>为例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">SET</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>实际传输格式为：<code>*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n</code></p><h4 id="返回结果格式"><a href="#返回结果格式" class="headerlink" title="返回结果格式"></a>返回结果格式</h4><p>Redis的返回结果类型分为以下五种:</p><ul><li>状态回复<br>在RESP中第一个字节为”+”。</li><li>错误回复<br>在RESP中第一个字节为”-“。</li><li>整数回复<br>在RESP中第一个字节为”:”。</li><li>字符串回复<br>在RESP中第一个字节为”$”。</li><li>多条字符串回复<br>在RESP中第一个字节为”*”。</li></ul><p>redis-cli只能看到最终的执行结果，是因为redis-cli本身就是按照RESP进行结果解析的，所以看不到中间结果，redis-cli.c源码对命令结果的解析结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> sds <span class="title">cliFormatReplyTTY</span><span class="params">(redisReply *r, <span class="keyword">char</span> *prefix)</span> </span>&#123;</span><br><span class="line">sds out = sdsempty();</span><br><span class="line"><span class="keyword">switch</span> (r-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_ERROR:</span><br><span class="line"><span class="comment">// 处理错误回复</span></span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_STATUS:</span><br><span class="line"><span class="comment">// 处理状态回复</span></span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_INTEGER:</span><br><span class="line"><span class="comment">// 处理整数回复</span></span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_STRING:</span><br><span class="line"><span class="comment">// 处理字符串回复</span></span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_NIL:</span><br><span class="line"><span class="comment">// 处理空</span></span><br><span class="line"><span class="keyword">case</span> REDIS_REPLY_ARRAY:</span><br><span class="line"><span class="comment">// 处理多条字符串回复</span></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如执行<code>set hello world</code>，返回结果是OK，并不能看到加号<code>+OK</code>。<br>为了看到Redis服务端返回的“真正”结果，可以使用nc命令、telnet命令、甚至写一个socket程序进行模拟。下面以nc命令进行演示：</p><ul><li>从源代码安装netcat<br>安装包：<a href="https://gitee.com/xxyrs/filehouse/raw/master/netcat-0.7.1.tar.gz" target="_blank" rel="noopener">netcat-0.7.1.tar.gz</a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz</span><br><span class="line">tar -xzvf netcat-0.7.1.tar.gz</span><br><span class="line">cd netcat-0.7.1</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li>首先使用nc 127.0.0.1 6379连接到Redis：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li><li>状态回复：<code>set hello world</code>的返回结果为+OK：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set hello world</span><br><span class="line">+OK</span><br></pre></td></tr></table></figure></li><li>错误回复：由于sethx这条命令不存在，那么返回结果就是”-“号加上错误消息：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sethx</span><br><span class="line">-ERR unknown command 'sethx'</span><br></pre></td></tr></table></figure></li><li>整数回复：当命令的执行结果是整数时，返回结果就是整数回复，例如incr、exists、del、dbsize返回结果都是整数，例如执行<code>incr counter</code>返回结果就是“：”加上整数：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">incr counter</span><br><span class="line">:1</span><br></pre></td></tr></table></figure></li><li>字符串回复：当命令的执行结果是字符串时，返回结果就是字符串回复。get、hget返回结果都是字符串，例如<code>get hello</code>的结果为“$5\r\nworld\r\n”：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get hello</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure></li><li>多条字符串回复：当命令的执行结果是多条字符串时，返回结果就是多条字符串回复。mget、hgetall、lrange等命令会返回多个结果，例如下面操作：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mset java jedis python redis-py</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">mget java python</span><br><span class="line">*2</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">jedis</span><br><span class="line"><span class="meta">$</span><span class="bash">8</span></span><br><span class="line">redis-py</span><br></pre></td></tr></table></figure></li><li>注意，无论是字符串回复还是多条字符串回复，如果有nil值，那么会返回$-1。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get not_exist_key</span><br><span class="line"><span class="meta">$</span><span class="bash">-1</span></span><br></pre></td></tr></table></figure></li><li>如果批量操作中包含一条为nil值的结果，那么返回结果如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mget hello not_exist_key java</span><br><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">world</span><br><span class="line"><span class="meta">$</span><span class="bash">-1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">jedis</span><br></pre></td></tr></table></figure></li></ul><p>有了RESP提供的发送命令和返回结果的协议格式，各种编程语言就可以利用其来实现相应的Redis客户端。</p><h3 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h3><p>Java有很多优秀的Redis客户端，详见：<a href="http://redis.io/clients#java" target="_blank" rel="noopener">http://redis.io/clients#java</a></p><h4 id="获取Jedis"><a href="#获取Jedis" class="headerlink" title="获取Jedis"></a>获取Jedis</h4><h4 id="Jedis的基本使用"><a href="#Jedis的基本使用" class="headerlink" title="Jedis的基本使用"></a>Jedis的基本使用</h4><h4 id="Jedis连接池使用"><a href="#Jedis连接池使用" class="headerlink" title="Jedis连接池使用"></a>Jedis连接池使用</h4><h4 id="Jedis中的Pipeline使用"><a href="#Jedis中的Pipeline使用" class="headerlink" title="Jedis中的Pipeline使用"></a>Jedis中的Pipeline使用</h4><h4 id="Jedis的Lua脚本使用"><a href="#Jedis的Lua脚本使用" class="headerlink" title="Jedis的Lua脚本使用"></a>Jedis的Lua脚本使用</h4><h3 id="Python客户端redis-python"><a href="#Python客户端redis-python" class="headerlink" title="Python客户端redis-python"></a>Python客户端redis-python</h3><p>Redis官网提供了很多Python语言的客户端：<a href="http://redis.io/clients#python" target="_blank" rel="noopener">http://redis.io/clients#python</a></p><h4 id="获取redis-py"><a href="#获取redis-py" class="headerlink" title="获取redis-py"></a>获取redis-py</h4><ul><li>使用pip进行安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></li><li>使用easy_install进行安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">easy_install redis</span><br></pre></td></tr></table></figure></li><li>使用源码安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https:// github.com/andymccurdy/redis-py/archive/2.10.5.zip</span><br><span class="line">unzip redis-2.10.5.zip</span><br><span class="line">cd redis-2.10.5</span><br><span class="line"><span class="meta">#</span><span class="bash">安装redis-py</span></span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li></ul><h4 id="redis-py基本使用方法"><a href="#redis-py基本使用方法" class="headerlink" title="redis-py基本使用方法"></a>redis-py基本使用方法</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">key = <span class="string">"hello"</span></span><br><span class="line">setResult = client.set(key, <span class="string">"python-redis"</span>)</span><br><span class="line">print(setResult)</span><br><span class="line">value = client.get(key)</span><br><span class="line">print(<span class="string">"key:"</span> + key + <span class="string">", value:"</span> + value)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">key:hello, value:python-redis</span><br></pre></td></tr></table></figure><p>下面代码给出redis-py操作Redis五种数据结构的示例:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.string</span></span><br><span class="line"><span class="comment">#输出结果： True</span></span><br><span class="line">client.set(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line"><span class="comment">#输出结果： world</span></span><br><span class="line">client.get(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">#输出结果： 1</span></span><br><span class="line">client.incr(<span class="string">"counter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.hash</span></span><br><span class="line">client.hset(<span class="string">"myhash"</span>,<span class="string">"f1"</span>,<span class="string">"v1"</span>)</span><br><span class="line">client.hset(<span class="string">"myhash"</span>,<span class="string">"f2"</span>,<span class="string">"v2"</span>)</span><br><span class="line"><span class="comment">#输出结果： &#123;'f1': 'v1', 'f2': 'v2'&#125;</span></span><br><span class="line">client.hgetall(<span class="string">"myhash"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3.list</span></span><br><span class="line">client.rpush(<span class="string">"mylist"</span>,<span class="string">"1"</span>)</span><br><span class="line">client.rpush(<span class="string">"mylist"</span>,<span class="string">"2"</span>)</span><br><span class="line">client.rpush(<span class="string">"mylist"</span>,<span class="string">"3"</span>)</span><br><span class="line"><span class="comment">#输出结果： ['1', '2', '3']</span></span><br><span class="line">client.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.set</span></span><br><span class="line">client.sadd(<span class="string">"myset"</span>,<span class="string">"a"</span>)</span><br><span class="line">client.sadd(<span class="string">"myset"</span>,<span class="string">"b"</span>)</span><br><span class="line">client.sadd(<span class="string">"myset"</span>,<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#输出结果： set(['a', 'b'])</span></span><br><span class="line">client.smembers(<span class="string">"myset"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.zset</span></span><br><span class="line">client.zadd(<span class="string">"myzset"</span>,<span class="string">"99"</span>,<span class="string">"tom"</span>)</span><br><span class="line">client.zadd(<span class="string">"myzset"</span>,<span class="string">"66"</span>,<span class="string">"peter"</span>)</span><br><span class="line">client.zadd(<span class="string">"myzset"</span>,<span class="string">"33"</span>,<span class="string">"james"</span>)</span><br><span class="line"><span class="comment">#输出结果： [('james', 33.0), ('peter', 66.0), ('tom', 99.0)]</span></span><br><span class="line">client.zrange(<span class="string">"myzset"</span>, <span class="number">0</span>, <span class="number">-1</span>, withscores=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="redis-py的Pipline使用"><a href="#redis-py的Pipline使用" class="headerlink" title="redis-py的Pipline使用"></a>redis-py的Pipline使用</h4><p>用redis-py的Pipeline实现mdel功能：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mdel</span><span class="params">(keys)</span>:</span></span><br><span class="line">  client = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">  pipeline = client.pipeline(transaction=<span class="literal">False</span>)   <span class="comment">#不使用事务</span></span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">print</span> pipeline.delete(key)</span><br><span class="line">  <span class="keyword">return</span> pipeline.execute()</span><br></pre></td></tr></table></figure><h4 id="redis-py的Lua脚本使用"><a href="#redis-py的Lua脚本使用" class="headerlink" title="redis-py的Lua脚本使用"></a>redis-py的Lua脚本使用</h4><p>redis-py提供了三个重要的函数实现Lua脚本的执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval(String script, int keyCount, String... params)</span><br><span class="line"></span><br><span class="line">script_load(String script)</span><br><span class="line"></span><br><span class="line">evalsha(String sha1, int keyCount, String... params)</span><br></pre></td></tr></table></figure><p>eval函数有三个参数，分别是：</p><ul><li>script：Lua脚本内容。</li><li>keyCount：键的个数。</li><li>params：相关参数KEYS和ARGV。</li></ul><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">script = <span class="string">"return redis.call('get',KEYS[1])"</span></span><br><span class="line"><span class="comment">#输出结果为world</span></span><br><span class="line"><span class="keyword">print</span> client.eval(script,<span class="number">1</span>,<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure><p>script_load和evalsha函数要一起使用，首先使用script_load将脚本加载到Redis中，evalsha函数用来执行脚本的哈希值，它需要三个参数：</p><ul><li>scriptSha：脚本的SHA1。</li><li>keyCount：键的个数。</li><li>params：相关参数KEYS和ARGV。</li></ul><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">script = <span class="string">"return redis.call('get',KEYS[1])"</span></span><br><span class="line">scriptSha = client.script_load(script)</span><br><span class="line"><span class="keyword">print</span> client.evalsha(scriptSha, <span class="number">1</span>, <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure><h3 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h3><h4 id="客户端API"><a href="#客户端API" class="headerlink" title="客户端API"></a>客户端API</h4><ul><li><p>client list<br>client list命令能列出与Redis服务端相连的所有客户端连接信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=421 addr=127.0.0.1:54264 fd=8 name= </span><br><span class="line">age=6 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 </span><br><span class="line">argv-mem=10 obl=0 oll=0 omem=0 tot-mem=61466 events=r cmd=client user=default</span><br></pre></td></tr></table></figure><ul><li><p>标识：addr、id、fd、name<br>id：客户端连接的唯一标识，这个id是随着Redis的连接自增的，重启Redis后会重置为0。<br>addr：客户端连接的ip和端口。<br>fd：socket的文件描述符，与lsof命令结果中的fd是同一个，如果fd=-1代表当前客户端不是外部客户端，而是Redis内部的伪装客户端。<br>name：客户端的名字。</p></li><li><p>输入缓冲区：qbuf、qbuf-free<br>Redis为每个客户端分配了输入缓冲区，作用是将客户端发送的命令临时保存，同时Redis会从输入缓冲区拉取命令并执行。</p></li><li><p>输出缓冲区：obl、oll、omem</p></li><li><p>客户端存货状态：age、idle</p></li><li><p>客户端类型：flag</p></li><li><p>其他</p></li></ul></li><li><p>client setName和client getName</p></li><li><p>client kill</p></li><li><p>client pause</p></li></ul><h4 id="客户端相关配置"><a href="#客户端相关配置" class="headerlink" title="客户端相关配置"></a>客户端相关配置</h4><h4 id="客户端统计片段"><a href="#客户端统计片段" class="headerlink" title="客户端统计片段"></a>客户端统计片段</h4><h3 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h3><h4 id="无法从连接池获取到连接"><a href="#无法从连接池获取到连接" class="headerlink" title="无法从连接池获取到连接"></a>无法从连接池获取到连接</h4><h4 id="客户端读写超时"><a href="#客户端读写超时" class="headerlink" title="客户端读写超时"></a>客户端读写超时</h4><h4 id="客户端连接超时"><a href="#客户端连接超时" class="headerlink" title="客户端连接超时"></a>客户端连接超时</h4><h4 id="客户端缓冲区异常"><a href="#客户端缓冲区异常" class="headerlink" title="客户端缓冲区异常"></a>客户端缓冲区异常</h4><h4 id="Lua脚本正在执行"><a href="#Lua脚本正在执行" class="headerlink" title="Lua脚本正在执行"></a>Lua脚本正在执行</h4><h4 id="Redis正在加载持久化文件"><a href="#Redis正在加载持久化文件" class="headerlink" title="Redis正在加载持久化文件"></a>Redis正在加载持久化文件</h4><h4 id="Redis使用的内存超过maxmemory配置"><a href="#Redis使用的内存超过maxmemory配置" class="headerlink" title="Redis使用的内存超过maxmemory配置"></a>Redis使用的内存超过maxmemory配置</h4><h4 id="客户端连接数过大"><a href="#客户端连接数过大" class="headerlink" title="客户端连接数过大"></a>客户端连接数过大</h4><h3 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h3><h4 id="Redis内存陡增"><a href="#Redis内存陡增" class="headerlink" title="Redis内存陡增"></a>Redis内存陡增</h4><h4 id="客户端周期性超时"><a href="#客户端周期性超时" class="headerlink" title="客户端周期性超时"></a>客户端周期性超时</h4><h2 id="Ch-5-持久化"><a href="#Ch-5-持久化" class="headerlink" title="Ch 5 持久化"></a>Ch 5 持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ul><li>手动触发<ul><li>save命令（已废弃）<br>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。<br>运行save命令对应的Redis日志为：<code>* DB saved on disk</code></li><li>bgsave命令<br>Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。<br>运行bgsave命令对应的Redis日志为：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Background saving started by pid 3151</span><br><span class="line">* DB saved on disk</span><br><span class="line">* RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">* Background saving terminated with success</span><br></pre></td></tr></table></figure></li></ul></li><li>自动触发<ul><li>使用save相关配置，如<code>save m n</code>。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见Ch6介绍的复制原理。</li><li>执行debug reload命令重新加载Redis时，也会自动触发save操作。</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li></ul></li></ul><h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><p><img src="https://s3.ax1x.com/2021/01/28/ySdX1U.png" alt="bgsave命令的运作流程"></p><ul><li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回。</li><li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。</li><li>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。</li><li>进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项。</li></ul><h4 id="RDB文件的处理"><a href="#RDB文件的处理" class="headerlink" title="RDB文件的处理"></a>RDB文件的处理</h4><ul><li>保存<br>RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定。可以通过执行<code>config set dir {newDir}</code>和<code>config set dbfilename {newFileName}</code>运行期动态执行，当下次运行时RDB文件会保存到新目录。<br><strong>注</strong>：当遇到坏盘或磁盘写满等情况时，可以通过<code>config set dir{newDir}</code>在线修改文件路径到可用的磁盘路径，之后执行bgsave进行磁盘切换，同样适用于AOF持久化文件。</li><li>压缩<br>Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数<code>config set rdbcompression {yes|no}</code>动态修改。<br><strong>注</strong>：虽然压缩RDB会消耗CPU，但可大幅降低文件的体积， 方便保存到硬盘或通过网络发送给从节点， 因此线上建议开启。</li><li>校验<br>如果Redis加载损坏的RDB文件时拒绝启动， 并打印如下日志：<br><code># Short read or OOM loading DB. Unrecoverable error, aborting now.</code><br>这时可以使用Redis提供的redis-check-dump工具检测RDB文件并获取对应的错误报告。</li></ul><h4 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h4><ul><li>RDB的优点：<ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li><li>Redis加载RDB恢复数据远远快于AOF的方式。</li></ul></li><li>RDB的缺点：<ul><li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li><li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</li></ul></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。<br>AOF的主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是Redis持久化的主流方式。理解掌握好AOF持久化机制对我们兼顾数据安全性和性能非常有帮助。</p><h4 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h4><ul><li>开启AOF功能需要设置配置：<ul><li>appendonly yes，默认不开启。</li><li>AOF文件名通过appendfilename配置设置，默认文件名是appendonly.aof。</li><li>保存路径同RDB持久化方式一致，通过dir配置指定。</li></ul></li><li>AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load），如图所示：<br><img src="https://s3.ax1x.com/2021/01/28/ySDgbQ.png" alt="AOF工作流程"><ul><li>所有的写入命令会追加到aof_buf（缓冲区）中。</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li><li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ul></li></ul><h4 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h4><p>AOF命令写入的内容直接是文本协议格式，Redis协议格式具体说明见4.1客户端协议小节。</p><ul><li>AOF为什么直接采用文本协议格式？可能的理由如下：<ul><li>文本协议具有很好的兼容性。</li><li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。</li><li>文本协议具有可读性，方便直接修改和处理。</li></ul></li><li>AOF为什么把命令追加到aof_buf中？<br>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</li></ul><h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制，不同值的含义如下：<br><img src="https://s3.ax1x.com/2021/01/28/y9AMEn.png" alt="AOF缓冲区同步文件策略"></p><ul><li>系统调用write和fsync说明：<ul><li>write操作会触发延迟写（delayed write）机制。Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，例如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li><li>除了write、fsync，Linux还提供了sync、fdatasync操作，具体API说明参见：<br><a href="http://linux.die.net/man/2/write" target="_blank" rel="noopener">http://linux.die.net/man/2/write</a><br><a href="http://linux.die.net/man/2/fsync" target="_blank" rel="noopener">http://linux.die.net/man/2/fsync</a><br><a href="http://linux.die.net/man/2/fdatasync" target="_blank" rel="noopener">http://linux.die.net/man/2/fdatasync</a></li></ul></li><li>配置为always时，每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰，不建议配置。</li><li>配置为no，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</li><li>配置为everysec，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。（严格来说最多丢失1秒数据是不准确的，5.3节会做具体介绍到。）</li></ul><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><ul><li>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。</li><li>AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li><li>重写后的AOF文件为什么可以变小？ 有如下原因：<ul><li>进程内已经超时的数据不再写入文件。</li><li>旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a 111、set a 222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li><li>多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</li></ul></li><li>AOF重写过程可以手动触发和自动触发：<ul><li>手动触发：直接调用bgrewriteaof命令。</li><li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。<ul><li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</li><li>auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（ aof_base_size）的比值。</li><li>自动触发时机 = aof_current_size &gt; auto-aof-rewrite-minsize &amp;&amp;<br>(aof_current_size-aof_base_size) / aof_base_size &gt;= auto-aof-rewritepercentage<br>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</li></ul></li></ul></li><li>当触发AOF重写时，内部的运行流程如下：<br><img src="https://s3.ax1x.com/2021/01/28/y9MrG9.png" alt="AOF重写运作流程"></li><li>执行AOF重写请求。<br>如果当前进程正在执行AOF重写，请求不执行并返回如下响应：ERR Background append only file rewriting already in progress<br>如果当前进程正在执行bgsave操作，重写命令延迟到bgsave完成之后再执行，返回如下响应：Background append only file rewriting scheduled</li><li>父进程执行fork创建子进程，开销等同于bgsave过程。</li><li>主进程fork操作完成后，继续响应其他命令。所有修改命令依然写入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性。</li><li>由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令 Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</li><li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞。</li><li>新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见info persistence下的aof_*相关统计。</li><li>父进程把AOF重写缓冲区的数据写入到新的AOF文件。</li><li>使用新AOF文件替换老文件，完成AOF重写。</li></ul><h4 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h4><ul><li>AOF和RDB文件都可以用于服务器重启时的数据恢复。Redis持久化文件加载流程如图。<br><img src="https://s3.ax1x.com/2021/01/28/y9l5jI.png" alt="Redis持久化文件加载流程"></li><li>流程说明：<ul><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件，打印如下日志：<br><code>* DB loaded from append only file: 5.841 seconds</code></li><li>AOF关闭或者AOF文件不存在时，加载RDB文件，打印如下日志：<br><code>* DB loaded from disk: 5.586 seconds</code></li><li>加载AOF/RDB文件成功后，Redis启动成功。</li><li>AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ul></li></ul><h4 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h4><p>加载损坏的AOF文件时会拒绝启动，并打印如下日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Bad file format reading the append only file: make a backup of your AOF file,</span></span><br><span class="line">then use ./redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：对于错误格式的AOF文件，先进行备份，然后采用redis-check-aof–fix命令进行修复，修复后使用diff -u对比数据的差异，找出丢失的数据，有些可以人工修改补全。<br>AOF文件可能存在结尾不完整的情况，比如机器突然断电导致AOF尾部文件命令写入不全。Redis为提供了aof-load-truncated配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印如下警告日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !!! Warning: short <span class="built_in">read</span> <span class="keyword">while</span> loading the AOF file !!!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !!! Truncating the AOF at offset 397856725 !!!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF loaded anyway because aof-load-truncated is enabled</span></span><br></pre></td></tr></table></figure><h3 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h3><h4 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a>fork操作</h4><ul><li>当Redis做RDB或AOF重写时，一个必不可少的操作就是执行fork操作创建子进程，对于大多数操作系统来说fork是个重量级操作。虽然fork创建的子进程不需要拷贝父进程的物理内存空间，但是会复制父进程的空间内存页表。例如对于10GB的Redis进程，需要复制大约20MB的内存页表，因此fork操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是Xen虚拟机，fork操作会更耗时。</li><li><strong>fork耗时问题定位</strong>：对于高流量的Redis实例OPS可达5万以上，如果fork操作耗时在秒级别将拖慢Redis几万条命令执行，对线上应用延迟影响非常明显。正常情况下fork耗时应该是每GB消耗20毫秒左右。可以在info stats统计中查latest_fork_usec指标获取最近一次fork操作耗时，单位微秒。</li><li>如何改善fork操作的耗时：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen。</li><li>控制Redis实例最大可用内存，fork耗时跟内存量成正比，线上建议每个Redis实例内存控制在10GB以内。</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败，具体细节见12.1节“Linux配置优化”。</li><li>降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。</li></ul></li></ul><h4 id="子进程开销监控与优化"><a href="#子进程开销监控与优化" class="headerlink" title="子进程开销监控与优化"></a>子进程开销监控与优化</h4><p>子进程负责AOF或者RDB文件的重写，它的运行过程主要涉及CPU、内存、硬盘三部分的消耗。</p><ul><li>CPU<ul><li>CPU开销分析。<br>子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%。</li><li>CPU消耗优化。<br>Redis是CPU密集型服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。</li><li>不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。</li><li>如果部署多个Redis实例，尽量保证同一时刻只有一个子进程执行重写工作，具体细节见5.4节“多实例部署”。</li></ul></li><li>内存<ul><li>内存消耗分析。<br>子进程通过fork操作产生，占用内存大小等同于父进程，理论上需要两倍的内存来完成持久化操作，但Linux有写时复制机制（copy-on-write）。<br>父子进程会共享相同的物理内存页，当父进程处理写请求时会把要修改的页创建副本，而子进程在fork操作过程中共享整个父进程内存快照。</li><li>内存消耗监控。<br>RDB重写时，Redis日志输出容如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Background saving started by pid 7692</span><br><span class="line">* DB saved on disk</span><br><span class="line">* RDB: 5 MB of memory used by copy-on-write</span><br><span class="line">* Background saving terminated with success</span><br></pre></td></tr></table></figure>如果重写过程中存在内存修改操作，父进程负责创建所修改内存页的副本，从日志中可以看出这部分内存消耗了5MB，可以等价认为RDB重写消耗了5MB的内存。<br>AOF重写时，Redis日志输出容如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Background append only file rewriting started by pid 8937</span><br><span class="line">* AOF rewrite child asks to stop sending diffs.</span><br><span class="line">* Parent agreed to stop sending diffs. Finalizing AOF...</span><br><span class="line">* Concatenating 0.00 MB of AOF diff received from parent.</span><br><span class="line">* SYNC append only file rewrite performed</span><br><span class="line">* AOF rewrite: 53 MB of memory used by copy-on-write</span><br><span class="line">* Background AOF rewrite terminated with success</span><br><span class="line">* Residual parent diff successfully flushed to the rewritten AOF (1.49 MB)</span><br><span class="line">* Background AOF rewrite finished successfully</span><br></pre></td></tr></table></figure>父进程维护页副本消耗同RDB重写过程类似，不同之处在于AOF重写需要AOF重写缓冲区，因此根据以上日志可以预估内存消耗为：53MB+1.49MB，也就是AOF重写时子进程消耗的内存量。<br><strong>注</strong>：编写shell脚本根据Redis日志可快速定位子进程重写期间内存过度消耗情况。</li><li>内存消耗优化：<ul><li>同CPU优化一样，如果部署多个Redis实例，尽量保证同一时刻只有一个子进程在工作。</li><li>避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗。</li></ul></li><li>Linux kernel在2.6.38内核增加了Transparent Huge Pages（THP），支持huge page（2MB）的页分配，默认开启。当开启时可以降低fork创建子进程的速度，但执行fork之后，如果开启THP，复制页单位从原来4KB变为2MB，会大幅增加重写期间父进程内存消耗。建议设置<code>sudo echonever&gt;/sys/kernel/mm/transparent_hugepage/enabled</code>关闭THP。更多THP细节和配置见12.1节Linux配置优化</li></ul></li><li>硬盘<ul><li>硬盘开销分析。<br>子进程主要职责是把AOF或者RDB文件写入硬盘持久化。 势必造成硬盘写入压力。 根据Redis重写AOF/RDB的数据量， 结合系统工具如sar、 iostat、 iotop等， 可分析出重写期间硬盘负载情况。</li><li>硬盘开销优化。<ul><li>不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。</li><li>AOF重写时会消耗大量硬盘IO，可以开启配置no-appendfsync-onrewrite，默认关闭。表示在AOF重写期间不做fsync操作。</li><li>当开启AOF功能的Redis用于高流量写入场景时，如果使用普通机械磁盘，写入吞吐一般在100MB/s左右，这时Redis实例的瓶颈主要在AOF同步硬盘上。</li><li>对于单机配置多个Redis实例的情况，可以配置不同实例分盘存储AOF文件，分摊硬盘写入压力。</li></ul></li><li><strong>注</strong>：配置no-appendfsync-on-rewrite=yes时，在极端情况下可能丢失整个AOF重写期间的数据，需要根据数据安全性决定是否配置。</li></ul></li></ul><h4 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h4><ul><li>当开启AOF持久化时，常用的同步硬盘的策略是everysec，用于平衡性能和数据安全性。对于这种方式，Redis使用另一条线程每秒执行fsync同步硬盘。当系统硬盘资源繁忙时，会造成Redis主线程阻塞，如图所示。<br><img src="https://s3.ax1x.com/2021/01/28/y9q2CR.png" alt="使用everysec做刷盘策略的流程"></li><li>阻塞流程分析：<ul><li>主线程负责写入AOF缓冲区。</li><li>AOF线程负责每秒执行一次同步磁盘操作，并记录最近一次同步时间。</li><li>主线程负责对比上次AOF同步时间：<ul><li>如果距上次同步成功时间在2秒内，主线程直接返回。</li><li>如果距上次同步成功时间超过2秒，主线程将会阻塞，直到同步操作完成。</li></ul></li></ul></li><li>通过对AOF阻塞流程可以发现两个问题：<ul><li>everysec配置最多可能丢失2秒数据，不是1秒。</li><li>如果系统fsync缓慢，将会导致Redis主线程阻塞影响效率。</li></ul></li><li>AOF阻塞问题定位：<ul><li>发生AOF阻塞时，Redis输出如下日志，用于记录AOF fsync阻塞导致拖慢Redis服务的行为：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Asynchronous AOF fsync is taking too long (disk is busy). Writing the AOF buffer</span><br><span class="line">without waiting for fsync to complete, this may slow down Redis</span><br></pre></td></tr></table></figure></li><li>每当发生AOF追加阻塞事件发生时，在info Persistence统计中，aof_delayed_fsync指标会累加，查看这个指标方便定位AOF阻塞问题。</li><li>AOF同步最多允许2秒的延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如iotop，定位消耗硬盘IO资源的进程。优化AOF追加阻塞问题主要是优化系统硬盘负载，优化方式见上一节。</li></ul></li></ul><h3 id="多实例部署"><a href="#多实例部署" class="headerlink" title="多实例部署"></a>多实例部署</h3><p>Redis单线程架构导致无法充分利用CPU多核特性，通常的做法是在一台机器上部署多个Redis实例。当多个实例开启AOF重写后，彼此之间会产生对CPU和IO的竞争。本节主要介绍针对这种场景的分析和优化。</p><ul><li>对于单机多Redis部署，如果同一时刻运行多个子进程，对当前系统影响将非常明显，因此需要采用一种措施，把子进程工作进行隔离。Redis在info Persistence中为我们提供了监控子进程运行状况的度量指标，如表所示。<br><img src="https://s3.ax1x.com/2021/01/28/y9LGM6.png" alt="info Persistence片段度量指标"><br>我们基于以上指标，可以通过外部程序轮询控制AOF重写操作的执行，整个过程如图所示。<br><img src="https://s3.ax1x.com/2021/01/28/y9LYqO.png" alt="轮询控制AOF重写"></li><li>流程说明：<ul><li>外部程序定时轮询监控机器（machine）上所有Redis实例。</li><li>对于开启AOF的实例，查看（aof_current_sizeaof_base_size） / aof_base_size确认增长率。</li><li>当增长率超过特定阈值（如100%），执行bgrewriteaof命令手动触发当前实例的AOF重写。</li><li>运行期间循环检查aof_rewrite_in_progress和aof_current_rewrite_time_sec指标，直到AOF重写结束。</li><li>确认实例AOF重写完成后，再检查其他实例并重复第2步到第4步操作。从而保证机器内每个Redis实例AOF重写串行化执行。</li></ul></li></ul><h2 id="Ch-6-复制"><a href="#Ch-6-复制" class="headerlink" title="Ch 6 复制"></a>Ch 6 复制</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h3><h2 id="Ch-7-阻塞"><a href="#Ch-7-阻塞" class="headerlink" title="Ch 7 阻塞"></a>Ch 7 阻塞</h2><h3 id="发现阻塞"><a href="#发现阻塞" class="headerlink" title="发现阻塞"></a>发现阻塞</h3><h3 id="内在原因"><a href="#内在原因" class="headerlink" title="内在原因"></a>内在原因</h3><h3 id="外在原因"><a href="#外在原因" class="headerlink" title="外在原因"></a>外在原因</h3><h2 id="Ch-8-理解内存"><a href="#Ch-8-理解内存" class="headerlink" title="Ch 8 理解内存"></a>Ch 8 理解内存</h2><h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>不负骤雨</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://xxyr.cc/post/Redis/redis-notes/" title="《Redis开发与运维》笔记">https://xxyr.cc/post/Redis/redis-notes/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"># Redis</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/post/Life/memories/" rel="next" title="回忆录">回忆录 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-1-初识Redis"><span class="nav-number">1.</span> <span class="nav-text">Ch 1 初识Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要特性"><span class="nav-number">1.1.</span> <span class="nav-text">主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis安装与启动"><span class="nav-number">1.3.</span> <span class="nav-text">Redis安装与启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis安装"><span class="nav-number">1.3.1.</span> <span class="nav-text">Redis安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis配置、启动、操作和关闭"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redis配置、启动、操作和关闭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-2-API的理解和使用"><span class="nav-number">2.</span> <span class="nav-text">Ch 2 API的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识、操作"><span class="nav-number">2.1.</span> <span class="nav-text">基础知识、操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">全局命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构和内部编码"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据结构和内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单线程架构"><span class="nav-number">2.1.3.</span> <span class="nav-text">单线程架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">2.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令"><span class="nav-number">2.2.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码"><span class="nav-number">2.2.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希"><span class="nav-number">2.3.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-2"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">2.4.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-3"><span class="nav-number">2.4.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">2.5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-4"><span class="nav-number">2.5.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序集合"><span class="nav-number">2.6.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-4"><span class="nav-number">2.6.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-4"><span class="nav-number">2.6.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-5"><span class="nav-number">2.6.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键管理"><span class="nav-number">2.7.</span> <span class="nav-text">键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个键管理"><span class="nav-number">2.7.1.</span> <span class="nav-text">单个键管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历键"><span class="nav-number">2.7.2.</span> <span class="nav-text">遍历键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库管理"><span class="nav-number">2.7.3.</span> <span class="nav-text">数据库管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-3-小功能大用处"><span class="nav-number">3.</span> <span class="nav-text">Ch 3 小功能大用处</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询分析"><span class="nav-number">3.1.</span> <span class="nav-text">慢查询分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两个配置参数"><span class="nav-number">3.1.1.</span> <span class="nav-text">两个配置参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作命令"><span class="nav-number">3.1.2.</span> <span class="nav-text">操作命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实践注意事项"><span class="nav-number">3.1.3.</span> <span class="nav-text">实践注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Shell"><span class="nav-number">3.2.</span> <span class="nav-text">Redis Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-cli"><span class="nav-number">3.2.1.</span> <span class="nav-text">redis-cli</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-server"><span class="nav-number">3.2.2.</span> <span class="nav-text">redis-server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-benchmark"><span class="nav-number">3.2.3.</span> <span class="nav-text">redis-benchmark</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipeline"><span class="nav-number">3.3.</span> <span class="nav-text">Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">3.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能测试"><span class="nav-number">3.3.2.</span> <span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生批量命令与Pipeline对比"><span class="nav-number">3.3.3.</span> <span class="nav-text">原生批量命令与Pipeline对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳实践"><span class="nav-number">3.3.4.</span> <span class="nav-text">最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务与Lua"><span class="nav-number">3.4.</span> <span class="nav-text">事务与Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务"><span class="nav-number">3.4.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lua用法简述"><span class="nav-number">3.4.2.</span> <span class="nav-text">Lua用法简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis与Lua"><span class="nav-number">3.4.3.</span> <span class="nav-text">Redis与Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">3.4.4.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis如何管理Lua脚本"><span class="nav-number">3.4.5.</span> <span class="nav-text">Redis如何管理Lua脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmaps"><span class="nav-number">3.5.</span> <span class="nav-text">Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构模型"><span class="nav-number">3.5.1.</span> <span class="nav-text">数据结构模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-5"><span class="nav-number">3.5.2.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BitMaps分析"><span class="nav-number">3.5.3.</span> <span class="nav-text">BitMaps分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">3.6.</span> <span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布订阅"><span class="nav-number">3.7.</span> <span class="nav-text">发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-6"><span class="nav-number">3.7.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-6"><span class="nav-number">3.7.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEO"><span class="nav-number">3.8.</span> <span class="nav-text">GEO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-4-客户端"><span class="nav-number">4.</span> <span class="nav-text">Ch 4 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端通信协议"><span class="nav-number">4.1.</span> <span class="nav-text">客户端通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送命令格式"><span class="nav-number">4.1.1.</span> <span class="nav-text">发送命令格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回结果格式"><span class="nav-number">4.1.2.</span> <span class="nav-text">返回结果格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java客户端Jedis"><span class="nav-number">4.2.</span> <span class="nav-text">Java客户端Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取Jedis"><span class="nav-number">4.2.1.</span> <span class="nav-text">获取Jedis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis的基本使用"><span class="nav-number">4.2.2.</span> <span class="nav-text">Jedis的基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis连接池使用"><span class="nav-number">4.2.3.</span> <span class="nav-text">Jedis连接池使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis中的Pipeline使用"><span class="nav-number">4.2.4.</span> <span class="nav-text">Jedis中的Pipeline使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis的Lua脚本使用"><span class="nav-number">4.2.5.</span> <span class="nav-text">Jedis的Lua脚本使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python客户端redis-python"><span class="nav-number">4.3.</span> <span class="nav-text">Python客户端redis-python</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取redis-py"><span class="nav-number">4.3.1.</span> <span class="nav-text">获取redis-py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-py基本使用方法"><span class="nav-number">4.3.2.</span> <span class="nav-text">redis-py基本使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-py的Pipline使用"><span class="nav-number">4.3.3.</span> <span class="nav-text">redis-py的Pipline使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-py的Lua脚本使用"><span class="nav-number">4.3.4.</span> <span class="nav-text">redis-py的Lua脚本使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端管理"><span class="nav-number">4.4.</span> <span class="nav-text">客户端管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端API"><span class="nav-number">4.4.1.</span> <span class="nav-text">客户端API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端相关配置"><span class="nav-number">4.4.2.</span> <span class="nav-text">客户端相关配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端统计片段"><span class="nav-number">4.4.3.</span> <span class="nav-text">客户端统计片段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端常见异常"><span class="nav-number">4.5.</span> <span class="nav-text">客户端常见异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无法从连接池获取到连接"><span class="nav-number">4.5.1.</span> <span class="nav-text">无法从连接池获取到连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端读写超时"><span class="nav-number">4.5.2.</span> <span class="nav-text">客户端读写超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端连接超时"><span class="nav-number">4.5.3.</span> <span class="nav-text">客户端连接超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端缓冲区异常"><span class="nav-number">4.5.4.</span> <span class="nav-text">客户端缓冲区异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lua脚本正在执行"><span class="nav-number">4.5.5.</span> <span class="nav-text">Lua脚本正在执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis正在加载持久化文件"><span class="nav-number">4.5.6.</span> <span class="nav-text">Redis正在加载持久化文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis使用的内存超过maxmemory配置"><span class="nav-number">4.5.7.</span> <span class="nav-text">Redis使用的内存超过maxmemory配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端连接数过大"><span class="nav-number">4.5.8.</span> <span class="nav-text">客户端连接数过大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端案例分析"><span class="nav-number">4.6.</span> <span class="nav-text">客户端案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis内存陡增"><span class="nav-number">4.6.1.</span> <span class="nav-text">Redis内存陡增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端周期性超时"><span class="nav-number">4.6.2.</span> <span class="nav-text">客户端周期性超时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-5-持久化"><span class="nav-number">5.</span> <span class="nav-text">Ch 5 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">5.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#触发机制"><span class="nav-number">5.1.1.</span> <span class="nav-text">触发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流程说明"><span class="nav-number">5.1.2.</span> <span class="nav-text">流程说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB文件的处理"><span class="nav-number">5.1.3.</span> <span class="nav-text">RDB文件的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB的优缺点"><span class="nav-number">5.1.4.</span> <span class="nav-text">RDB的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">5.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用AOF"><span class="nav-number">5.2.1.</span> <span class="nav-text">使用AOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令写入"><span class="nav-number">5.2.2.</span> <span class="nav-text">命令写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件同步"><span class="nav-number">5.2.3.</span> <span class="nav-text">文件同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重写机制"><span class="nav-number">5.2.4.</span> <span class="nav-text">重写机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重启加载"><span class="nav-number">5.2.5.</span> <span class="nav-text">重启加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件校验"><span class="nav-number">5.2.6.</span> <span class="nav-text">文件校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题定位与优化"><span class="nav-number">5.3.</span> <span class="nav-text">问题定位与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork操作"><span class="nav-number">5.3.1.</span> <span class="nav-text">fork操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子进程开销监控与优化"><span class="nav-number">5.3.2.</span> <span class="nav-text">子进程开销监控与优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF追加阻塞"><span class="nav-number">5.3.3.</span> <span class="nav-text">AOF追加阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多实例部署"><span class="nav-number">5.4.</span> <span class="nav-text">多实例部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-6-复制"><span class="nav-number">6.</span> <span class="nav-text">Ch 6 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">6.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑"><span class="nav-number">6.2.</span> <span class="nav-text">拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">6.3.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发与运维中的问题"><span class="nav-number">6.4.</span> <span class="nav-text">开发与运维中的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-7-阻塞"><span class="nav-number">7.</span> <span class="nav-text">Ch 7 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发现阻塞"><span class="nav-number">7.1.</span> <span class="nav-text">发现阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内在原因"><span class="nav-number">7.2.</span> <span class="nav-text">内在原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外在原因"><span class="nav-number">7.3.</span> <span class="nav-text">外在原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch-8-理解内存"><span class="nav-number">8.</span> <span class="nav-text">Ch 8 理解内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存消耗"><span class="nav-number">8.1.</span> <span class="nav-text">内存消耗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-number">8.2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存优化"><span class="nav-number">8.3.</span> <span class="nav-text">内存优化</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="不负骤雨" src="https://s3.ax1x.com/2021/02/06/yY1Kx0.jpg"><p class="site-author-name" itemprop="name">不负骤雨</p><div class="site-description" itemprop="description">reading coding keeping</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhishui1?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhishui1?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/349434614" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;349434614" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom bili"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/id/zhishui_x" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;zhishui_x" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i></a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">不负骤雨</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">170k</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: true,
      notify: true,
      appId: 'hOTS2YD4rcQy3T7bS94tywjn-gzGzoHsz',
      appKey: '4fQPAOtQk7tqm6wJ8kJxODvT',
      placeholder: "Just go go",
      avatar: 'wavatar',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html>