<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://xxyr.cc").hostname,root:"/",scheme:"Gemini",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="《Effective Python》学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="Pythonic Coding"><meta property="og:url" content="https://xxyr.cc/post/Python/effective-python/index.html"><meta property="og:site_name" content="不负骤雨"><meta property="og:description" content="《Effective Python》学习笔记"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-02-18T00:58:36.000Z"><meta property="article:modified_time" content="2020-05-18T13:07:39.805Z"><meta property="article:author" content="不负骤雨"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://xxyr.cc/post/Python/effective-python/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>Pythonic Coding | 不负骤雨</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" style="margin:10px"><div class="container use-motion"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不负骤雨</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">围城</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">13</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">14</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xxyr.cc/post/Python/effective-python/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://i.loli.net/2019/12/15/ev4RZy7Iakn9WHl.jpg"><meta itemprop="name" content="不负骤雨"><meta itemprop="description" content="reading coding keeping"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="不负骤雨"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Pythonic Coding</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-18 08:58:36" itemprop="dateCreated datePublished" datetime="2020-02-18T08:58:36+08:00">2020-02-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-05-18 21:07:39" itemprop="dateModified" datetime="2020-05-18T21:07:39+08:00">2020-05-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span> </a></span></span><span id="/post/Python/effective-python/" class="post-meta-item leancloud_visitors" data-flag-title="Pythonic Coding" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论次数：</span> <a title="valine" href="/post/Python/effective-python/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/Python/effective-python/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>《Effective Python》学习笔记<a id="more"></a></p><h2 id="程序风格"><a href="#程序风格" class="headerlink" title="程序风格"></a><center>程序风格</center></h2><h3 id="遵循PEP8风格指南"><a href="#遵循PEP8风格指南" class="headerlink" title="遵循PEP8风格指南"></a>遵循PEP8风格指南</h3><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">《Python Enhancement Proposal #8》</a>，简称PEP8，是针对Python代码格式编订的风格指南。</p><h3 id="bytes、str与unicode区别"><a href="#bytes、str与unicode区别" class="headerlink" title="bytes、str与unicode区别"></a>bytes、str与unicode区别</h3><h4 id="首先区分Python3与Python2的两种表示字符序列的类型"><a href="#首先区分Python3与Python2的两种表示字符序列的类型" class="headerlink" title="首先区分Python3与Python2的两种表示字符序列的类型"></a>首先区分Python3与Python2的两种表示字符序列的类型</h4><ul><li>Python3，bytes与str，前者的实例包含原始的8位值，即原始的字节，包含8个二进制位；后者的实例包含Unicode字符</li><li>Python2，str与unicode，前者的实例包含原始的8位值；后者的实例包含Unicode字符</li></ul><h4 id="二进制数据与Unicode字符相互转换"><a href="#二进制数据与Unicode字符相互转换" class="headerlink" title="二进制数据与Unicode字符相互转换"></a>二进制数据与Unicode字符相互转换</h4><p>常见编码方式为UTF-8<br>Unicode字符 → 二进制数据，encode()方法<br>二进制数据 → Unicode字符，decode()方法</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>Python程序中，编码和解码操作放在程序外围，核心部分使用Unicode字符类型</li><li>在只处理7位ASCII时，Python2的str和unicode类型的实例可以等价，而Python3中bytes与str的实例绝对不等价</li><li>Python3中，使用内置open()函数获取文件句柄，该句柄默认采用UTF-8格式来操作文件，问题在于Python3给open()函数添加了名为encoding的新参数，其默认值为’utf-8’，要求必须传入包含Unicode字符的str实例，而不接受包含二进制数据的bytes实例<br>总结为必须使用二进制写入模式open(path, ‘wb’)来开启待操作文件</li></ul><h3 id="用辅助函数取代复杂表达式"><a href="#用辅助函数取代复杂表达式" class="headerlink" title="用辅助函数取代复杂表达式"></a>用辅助函数取代复杂表达式</h3><p>如，从字典中查询并返回得到的第一个整数值:<br><code>red = my_values.get(&#39;red&#39;, [&#39;&#39;])[0] or 0</code><br>未查询到或值为0为空统一返回0，该表达式不易理解，若要频繁使用，将其总结为辅助函数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_int</span><span class="params">(values, key, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">    found =values.get(key, [<span class="string">''</span>])</span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        found = int(found[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = default</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">red = get_first_int(my_values, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><p>somelist[start:end]，其中start所指元素涵盖在切割后的范围内，end所指元素不包括在切割结果之中。例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start从0开始，end倒数从-1开始</span></span><br><span class="line">a[:]                                    <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line">a[:<span class="number">3</span>]                                   <span class="comment">#[1,2,3]</span></span><br><span class="line">a[<span class="number">2</span>:]                                   <span class="comment">#[3,4,5,6]</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]                                  <span class="comment">#[3,4,5]</span></span><br><span class="line">a[<span class="number">-3</span>:<span class="number">-1</span>]                                <span class="comment">#[4,5]</span></span><br></pre></td></tr></table></figure><p>切割列表时，start和end越界不会出问题，利用该特性可以限定输入序列的最大长度。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">first_nine_items</span> = a[:<span class="number">9</span>]</span><br><span class="line"><span class="attr">last_nine_items</span> = a[<span class="number">9</span>:]</span><br></pre></td></tr></table></figure><p>切片后不影响原列表，对list赋值，若使用切片操作，会把原列表处在相关范围内的值替换为新值，即便长度不同也可以替换。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">1</span>]                          <span class="comment">#[1,2,1,1,6]</span></span><br><span class="line">a[:] = [<span class="number">1</span>,<span class="number">1</span>]                            <span class="comment">#[1,1]</span></span><br></pre></td></tr></table></figure><h4 id="步进式切割"><a href="#步进式切割" class="headerlink" title="步进式切割"></a>步进式切割</h4><p>somelist[start:end:stride]</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">odds = a[::<span class="number">2</span>]</span><br><span class="line">evens = a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">b = <span class="string">b'abc'</span></span><br><span class="line">reverse = b[::<span class="number">-1</span>]                       <span class="comment">#负值为反向步进</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>负步长只对字节串和ASCII字符有效，对已编码成UTF-8字节串的Unicode字符无效</li><li>尽量使用stride为正数，且不带start和end索引</li><li>同一切片操作内，不要同时指定start、end和stride，考虑将其拆解为一条步进切割，一条范围切割</li></ul><h3 id="列表与迭代"><a href="#列表与迭代" class="headerlink" title="列表与迭代"></a>列表与迭代</h3><h4 id="用列表推导取代map和filter"><a href="#用列表推导取代map和filter" class="headerlink" title="用列表推导取代map和filter"></a>用列表推导取代map和filter</h4><p><strong>列表推导</strong>(list comprehension)，根据一份列表来制作另外一份。<br><strong>字典</strong>(dict)与<strong>集</strong>(set)也支持推导表达式</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用map，创建lambda函数，结合filter</span></span><br><span class="line">squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br><span class="line">even_squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用列表推导</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="列表推导内含的表达式不宜超过两个"><a href="#列表推导内含的表达式不宜超过两个" class="headerlink" title="列表推导内含的表达式不宜超过两个"></a>列表推导内含的表达式不宜超过两个</h4><p>列表推导支持多重循环</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵简化为一维列表</span></span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]                  <span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]          <span class="comment">#[[1, 4, 9], [16, 25, 36], [49, 64, 81]]</span></span><br></pre></td></tr></table></figure><p>每一级循环也支持多重条件</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处在同一循环级别中的多项条件， 彼此之间默认形成and表达式</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#从矩阵中取出本身能被3整除，且其所在行所有元素之和大于等于10的元素</span></span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] </span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h4 id="用生成器表达式改写数据量较大的列表推导"><a href="#用生成器表达式改写数据量较大的列表推导" class="headerlink" title="用生成器表达式改写数据量较大的列表推导"></a>用生成器表达式改写数据量较大的列表推导</h4><p>首先，列表推导的缺点是：<br>在推导过程中，对于输入序列中的每个值，可能都要创建一个仅含一个元素的新列表，若输入数据量较大，会消耗大量内存。<br>如，读取一份文件并返回每行的字符数，采用列表推导</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file)]</span><br></pre></td></tr></table></figure><p><strong>生成器表达式</strong>(generator expression)：<br>对列表推导和生成器的一种<strong>泛化</strong>(generalization)，生成器表达式运行时，不会呈现整个输出序列，而是估值为<strong>迭代器</strong>(iterator)，该迭代器每次根据生成器表达式产生一项数据。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器表达式，立刻返回一个迭代器</span></span><br><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file))</span><br><span class="line">next(it)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器表达式可以互相组合</span></span><br><span class="line">roots = ((x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure><h4 id="用enumerate取代range"><a href="#用enumerate取代range" class="headerlink" title="用enumerate取代range"></a>用enumerate取代range</h4><p>enumerate可以把各种迭代器包装为生成器，可以在遍历迭代器时获得每个元素的索引，在同时需要下标和值的时候使用。如range</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_num)):</span><br><span class="line">    num = list_num[i]</span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i+<span class="number">1</span>, num))</span><br></pre></td></tr></table></figure><p>使用enumerate</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerator(list_num, <span class="number">1</span>):                  <span class="comment">#起始下标指定为1</span></span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i, num))</span><br></pre></td></tr></table></figure><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><p>Python3中的zip函数，能将两个及以上的迭代器封装为生成器，在遍历过程中逐次产生元组。<br>Python2中，直接产生所有元组，并一次性返回整份列表<br>若提供的迭代器长度不等，zip会提前自动终止</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'adad'</span>, <span class="string">'bob'</span>, <span class="string">'alen'</span>]</span><br><span class="line">letters = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, letter <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    print(name+str(letter))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><center>函数</center></h2><p>函数的问题主要体现在<strong>参数</strong>、<strong>作用域</strong>、<strong>返回值</strong>三个方面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="在闭包里使用外围作用域中的变量"><a href="#在闭包里使用外围作用域中的变量" class="headerlink" title="在闭包里使用外围作用域中的变量"></a>在闭包里使用外围作用域中的变量</h4><p>注意：</p><ul><li>Python支持闭包（closure）：闭包是定义在某个作用域中的函数，可以引用那个作用域中的变量。</li><li>Python的函数时一级对象，可以直接引用函数、将函数赋给变量或者将函数作为参数传递。</li></ul><p>例如，对一份数字列表进行排序，要求出现的特定数字在其他数字排序之前。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sort_priority(numbers, group)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>稍作修改为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">found = sort_priority2(numbers, group)</span><br><span class="line">print(found)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>found的输出结果与预期的True不符，这里我们首先要了解，在表达式中引用变量，Python解释器遵循以下顺序遍历各作用域：</p><ul><li>当前函数作用域</li><li>任何外围作用域（如包含当前函数的其他函数）</li><li>包含当前代码的那个模块的作用域（全局作用域，global scope）</li><li>内置作用域（包含str及len等函数的那个作用域）</li><li>未定义过名称相符变量，抛出NameError异常</li></ul><p>sort_priority2函数中将found赋值为True是在闭包函数helper内进行的，实则是在闭包函数的作用域中定义了一个found变量并赋值为True，与其外围函数sort_priority2作用域中定义的found不同，最后返回的是sort_priority2中赋值为False的found变量。<br>因此，我们需要获取闭包内的数据，可使用nonlocal语句，不支持Python2</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found                  <span class="comment">#声明该found为闭包外围作用域中的found</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>而实际开发中，nonlocal容易遭到滥用，且副作用难以追踪，难以理解，不适用于较长较复杂的函数。有以下两个解决办法：</p><ol><li>将相关状态封装为辅助类<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">            self.found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br><span class="line">print(sorter.found)</span><br></pre></td></tr></table></figure></li><li>用Python的作用域规则，Python2可用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = [<span class="literal">False</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="尽量用异常表示特殊情况，而非返回None"><a href="#尽量用异常表示特殊情况，而非返回None" class="headerlink" title="尽量用异常表示特殊情况，而非返回None"></a>尽量用异常表示特殊情况，而非返回None</h4>例如，两数相除的情况。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:                              <span class="comment">#这种情况没有问题</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:                                  <span class="comment">#错误情况</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure>当分子为0时not result结果为True，结果应为0，却显示Invalid inputs。用异常来表示这种情况：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Result is %.1f'</span> % result)</span><br></pre></td></tr></table></figure><h4 id="用生成器改写直接返回列表的函数"><a href="#用生成器改写直接返回列表的函数" class="headerlink" title="用生成器改写直接返回列表的函数"></a>用生成器改写直接返回列表的函数</h4>若函数产生一系列结果，最简单的方法是返回一个包含所有结果的列表，此方法主要有两个缺点：</li></ol><ul><li>代码拥挤，不清晰</li><li>返回前将所有结果放在列表里，若输入量非常大，会导致内存耗尽</li></ul><p>例如以下函数返回字符串中每个单词首字母的位置。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            result.append(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = index_words(text)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>用生成器改写：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">yield</span> index+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = list(index_words(text))</span><br></pre></td></tr></table></figure></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>不负骤雨</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://xxyr.cc/post/Python/effective-python/" title="Pythonic Coding">https://xxyr.cc/post/Python/effective-python/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Python/" rel="tag"># Python</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/DeepLearning/deep-learning-notes/" rel="prev" title="《Python深度学习》笔记"><i class="fa fa-chevron-left"></i> 《Python深度学习》笔记</a></div><div class="post-nav-item"><a href="/post/Python/auto-gui-with-python/" rel="next" title="使用Python自动化控制鼠标和键盘">使用Python自动化控制鼠标和键盘 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序风格"><span class="nav-number">1.</span> <span class="nav-text">程序风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#遵循PEP8风格指南"><span class="nav-number">1.1.</span> <span class="nav-text">遵循PEP8风格指南</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bytes、str与unicode区别"><span class="nav-number">1.2.</span> <span class="nav-text">bytes、str与unicode区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#首先区分Python3与Python2的两种表示字符序列的类型"><span class="nav-number">1.2.1.</span> <span class="nav-text">首先区分Python3与Python2的两种表示字符序列的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制数据与Unicode字符相互转换"><span class="nav-number">1.2.2.</span> <span class="nav-text">二进制数据与Unicode字符相互转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用辅助函数取代复杂表达式"><span class="nav-number">1.3.</span> <span class="nav-text">用辅助函数取代复杂表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片操作"><span class="nav-number">1.4.</span> <span class="nav-text">切片操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本写法"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步进式切割"><span class="nav-number">1.4.2.</span> <span class="nav-text">步进式切割</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表与迭代"><span class="nav-number">1.5.</span> <span class="nav-text">列表与迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用列表推导取代map和filter"><span class="nav-number">1.5.1.</span> <span class="nav-text">用列表推导取代map和filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表推导内含的表达式不宜超过两个"><span class="nav-number">1.5.2.</span> <span class="nav-text">列表推导内含的表达式不宜超过两个</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用生成器表达式改写数据量较大的列表推导"><span class="nav-number">1.5.3.</span> <span class="nav-text">用生成器表达式改写数据量较大的列表推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用enumerate取代range"><span class="nav-number">1.5.4.</span> <span class="nav-text">用enumerate取代range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用zip函数同时遍历两个迭代器"><span class="nav-number">1.5.5.</span> <span class="nav-text">用zip函数同时遍历两个迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参数"><span class="nav-number">2.1.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">2.2.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在闭包里使用外围作用域中的变量"><span class="nav-number">2.2.1.</span> <span class="nav-text">在闭包里使用外围作用域中的变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值"><span class="nav-number">2.3.</span> <span class="nav-text">返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#尽量用异常表示特殊情况，而非返回None"><span class="nav-number">2.3.1.</span> <span class="nav-text">尽量用异常表示特殊情况，而非返回None</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用生成器改写直接返回列表的函数"><span class="nav-number">2.3.2.</span> <span class="nav-text">用生成器改写直接返回列表的函数</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="不负骤雨" src="https://i.loli.net/2019/12/15/ev4RZy7Iakn9WHl.jpg"><p class="site-author-name" itemprop="name">不负骤雨</p><div class="site-description" itemprop="description">reading coding keeping</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhishui1?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhishui1?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/349434614" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;349434614" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom bili"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/id/zhishui_x" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;zhishui_x" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i></a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">不负骤雨</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">100k</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: true,
      notify: true,
      appId: 'hOTS2YD4rcQy3T7bS94tywjn-gzGzoHsz',
      appKey: '4fQPAOtQk7tqm6wJ8kJxODvT',
      placeholder: "Just go go",
      avatar: 'wavatar',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html>