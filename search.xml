<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《Redis开发与运维》笔记</title>
    <url>/post/Redis/redis-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Redis开发与运维》学习笔记<a id="more"></a></p><h2 id="Ch-1-初识Redis"><a href="#Ch-1-初识Redis" class="headerlink" title="Ch 1 初识Redis"></a>Ch 1 初识Redis</h2><p>Redis（REmote Dictionary Server）——一种基于键值对的NoSQL数据库。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul><li><strong>速度快</strong><ul><li>所有数据存放在内存中。</li><li>基于C语言实现。</li><li>单线程架构。</li><li>源代码优化好。</li></ul></li><li><strong>基于键值对的数据结构服务器</strong><ul><li>Redis的值主要支持5种数据结构：字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）。</li><li>同时在字符串基础上演变了位图（Bitmaps）、HyperLogLog以及GEO（地理信息定位）等数据结构。</li></ul></li><li><strong>丰富的功能</strong><ul><li>键过期功能，实现缓存。</li><li>发布订阅功能，实现消息系统。</li><li>支持LUA脚本功能，用LUA创造出新的Redis命令。</li><li>简单的事务功能。</li><li>流水线功能，客户端能将命令一次性传到Redis。</li></ul></li><li><strong>简单稳定</strong><ul><li>源码相对较少。</li><li>使用单线程模型。</li><li>不依赖OS中的类库。</li><li>自己实现了事件处理的相关功能。</li></ul></li><li><strong>客户端语言多</strong><ul><li>提供简单的TCP通信协议</li><li>支持Java、PHP、Python、C、C++、Nodejs等. <a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a></li></ul></li><li><strong>持久化</strong><ul><li>RDB和AOF。</li></ul></li><li><strong>主从复制</strong><ul><li>分布式Redis的基础，实现多个相同数据的Redis副本。</li></ul></li><li><strong>高可用和分布式</strong></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>缓存</li><li>排行榜系统（列表和有序集合）</li><li>计数器应用（播放数、浏览数等）</li><li>社交网络（赞踩、粉丝、共同好友等）</li><li>消息队列系统</li><li>数据规模不宜过大、适用热数据（经常访问）</li></ul><h3 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h3><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><p><a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.redis.io/releases/redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-6.0.9 redis   <span class="comment">#创建软链接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>若显示 <code>install: 无法创建普通文件&#39;/usr/local/bin/redis-server&#39;: 权限不够</code><br>则执行<code>su root</code>获取root权限<br>不记得密码执行<code>sudo passwd root</code>修改密码<br>安装成功查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -v</span></span><br><span class="line">redis-cli 6.0.9</span><br></pre></td></tr></table></figure><h4 id="Redis配置、启动、操作和关闭"><a href="#Redis配置、启动、操作和关闭" class="headerlink" title="Redis配置、启动、操作和关闭"></a><span id="jump">Redis配置、启动、操作和关闭</span></h4><ul><li>三种启动方式<ul><li>默认配置启动<code>redis-server</code></li><li>运行启动（加上需修改的参数）<code>redis-server --port 6380</code></li><li>配置文件启动<code>redis-sever /opt/redis/redis.conf</code></li></ul></li><li>Redis命令行客户端<ul><li>交互式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set good day</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>命令方式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li></ul></li><li>停止Redis服务<br><code>redis-cli shutdown</code> （可选参数nosave|save是否生成持久化文件）</li></ul><h2 id="Ch-2-API的理解和使用"><a href="#Ch-2-API的理解和使用" class="headerlink" title="Ch 2 API的理解和使用"></a>Ch 2 API的理解和使用</h2><h3 id="基础知识、操作"><a href="#基础知识、操作" class="headerlink" title="基础知识、操作"></a>基础知识、操作</h3><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><ul><li>查看所有键<br><code>keys *</code><br>keys命令会遍历所有键，时间复杂度为O（n），线上环境禁止使用。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "good"</span><br><span class="line">2) "hello"</span><br></pre></td></tr></table></figure></li><li>键总数<br><code>dbsize</code><br>直接获取Redis内置的键总数变量，时间复杂度为O（1）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>检查键是否存在<br><code>exists key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists no_hello</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>删除键<br><code>del key1 key2 key3~</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del good hello</span><br><span class="line">(integer) 2                       #返回成功删除键的个数</span><br></pre></td></tr></table></figure></li><li>键过期<br><code>expire key seconds</code><br>对键添加过期时间，过期自动删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire hello 10   #单位：s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) 5                       #剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) -2                      #-2表示键不存在，-1表示键没有设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li>键的数据结构类型<br><code>type key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; type a</span><br><span class="line">none</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h4><p>优点：改进内部编码而不影响外部数据结构和命令，适应各种场景更加灵活，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjAmUx.png" alt=""></p><h4 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h4><ul><li>单线程首先不会出现并发问题，可以简化数据结构和算法的实现，并且避免了线程切换和竞态产生的消耗，但不适合某个命令执行时间过长的场景。</li><li>纯内存访问，重要基础。</li><li>非阻塞I/O，使用epoll作为I/O多路复用技术的实现以及自身事件模型，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjnP8x.png" alt=""></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Redis最基础的数据结构，键是字符串类型，字符串类型的值可以是字符串（JSON、XML等）、数字、二进制，值最大不能超过512MB。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>常用命令<ul><li>设置值<br><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code><br>ex seconds：为键设置秒级过期时间。<br>px milliseconds：为键设置毫秒级过期时间。<br>nx：等价于<code>setnx key value</code>，键必须不存在才能设置成功，用于添加（可以用于实现分布式锁）。<br>xx：等价于<code>setex key seconds value</code>，键必须存在才能设置成功，用于更新。</li><li>获取值<br><code>get key</code></li><li>批量设置值<br><code>mset key value key value···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>批量获取值<br><code>mget key key key···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget a b c d</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure></li><li>计数<br><code>incr key</code><br>用于对值做自增操作。<br>值必须是整数.<br>键不存在，按值为0自增，返回结果为1。<br>还有：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">decr key                    #自减</span><br><span class="line">incrby key incerement       #自增指定数字</span><br><span class="line">decrby key decrement        #自减指定数字</span><br><span class="line">incrbyfloat key incerement  #自增浮点数</span><br></pre></td></tr></table></figure></li></ul></li><li>不常用命令<ul><li>追加值<br><code>append key value</code><br>向字符串尾部追加值</li><li>字符串长度<br><code>strlen key</code><br>返回字节数</li><li>设置并返回原值<br><code>getset key value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset nice day</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset nice try</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>设置指定位置的字符<br><code>setrange key offset value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure></li><li>获取部分字符串<br><code>getrange key start end</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line">"be"</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF3wuT.png" alt=""></p><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>int<br>8个字节的长整型。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 8653</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure></li><li>embstr<br>小于等于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure></li><li>raw<br>大于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world···"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>缓存功能<br>Redis作为缓存层，MySQL作为存储层，如下图。<br><img src="https://s3.ax1x.com/2020/12/31/rvp9KI.png" alt=""><br>例如下面用于获取用户信息的伪代码。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id</span><br><span class="line">  value = redis.get(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">    userInfo = deserialize(value);    <span class="comment">#反序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo != null)</span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));   <span class="comment">#一小时过期时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">long incrVideoCounter(long id) &#123;</span><br><span class="line">  key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">  <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>共享Session<br>分布式Web服务使用Redis将用户的Session进行集中管理。<br><img src="https://s3.ax1x.com/2020/12/31/rvEkCV.png" alt=""></li><li>限速<br>例如网站限制一个IP地址在一定时间内的访问次数等。<br>用户获取验证码一分钟不超过5次的伪代码如下。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line">// SET key value EX <span class="number">60</span> NX</span><br><span class="line">isExists = redis.set(key,<span class="number">1</span>,<span class="string">"EX 60"</span>,<span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != null || redis.incr(key) &lt;=<span class="number">5</span>)&#123;</span><br><span class="line">  // 通过</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  // 限速</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>键值本身又是一对键值对结构，形如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = &#123;&#123;filed1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul><li>设置值<br><code>hset key filed value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取值<br><code>hget key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">"tom"</span><br></pre></td></tr></table></figure></li><li>删除field<br><code>hdel key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:1 name age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>计算field个数<br><code>hlen key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>批量设置或获取filed-value<br><code>hmset key filed1 value1 filed2 value2</code><br><code>hmget key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:1 name tom age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name age</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>判断filed是否存在<br><code>hexists key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取所有field<br><code>hkeys key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br></pre></td></tr></table></figure></li><li>获取所有value<br><code>hvals key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>获取所有的field-value<br><code>hgetall key</code>（个数较多会导致阻塞）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "tom"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br></pre></td></tr></table></figure></li><li>自增<br><code>hincrby key filed</code><br><code>hincrbyfloat key filed</code></li><li>计算value的字符串长度<br><code>hstrlen key filed</code>（Redis&gt;3.2）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen user:1 name</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8CPs.png" alt=""></p><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于hash-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于hash-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>hashtable（哈希表）<br>不满足ziplist时采用，O(1)。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>哈希类型是稀疏的，而关系型数据库是完全结构化的，且Redis不适合做复杂的关系查询，<br>以下为获取用户信息的伪代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  // 用户id作为key后缀</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">  // 使用hgetall获取所有用户信息映射关系</span><br><span class="line">  userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (userInfoMap != null) &#123;</span><br><span class="line">    // 将映射关系转换为UserInfo</span><br><span class="line">    userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 从MySQL中获取用户信息</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    // 将userInfo变为映射关系使用hmset保存到Redis中</span><br><span class="line">    redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">    // 添加过期时间</span><br><span class="line">    redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种缓存用户信息方法对比。</p><ul><li>原生字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 name tom</span><br><span class="line">set user:1 age 18</span><br></pre></td></tr></table></figure>每个属性一个键，简单直观，但内存占用大，用户信息内聚性差。</li><li>序列化字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 serialize(userinfo)</span><br></pre></td></tr></table></figure>简化编程，但序列化和反序列化有一定开销，且每次更新都要进行反序列化和序列化。</li><li>哈希类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset user:1 name tom age 18</span><br></pre></td></tr></table></figure>简单直观，合理使用可减少内存占用，但要注意两种内部编码的转换，hashtable会消耗更多内存。</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>可以存储多个<strong>有序</strong>、<strong>重复</strong>的字符串，每个字符串称为元素（个数不大于2^32-1），可以充当<strong>栈</strong>和<strong>队列</strong>。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul><li>添加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpush key value1 value2           #从右侧插入</span><br><span class="line">lpush key value1 value2           #从左侧插入</span><br><span class="line">linsert key before|after me you   #在me之前或之后插入you</span><br></pre></td></tr></table></figure></li><li>查找<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrange key start end              #从左至右为0到N-1，从右至左为-1到-N，end包含自身，0到-1为全部</span><br><span class="line">lindex key index                  #获取指定下标的元素</span><br><span class="line">llen key                          #获取列表长度</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpop key                          #从右侧删除</span><br><span class="line">lpop key                          #从右侧删除</span><br><span class="line">lrem key count value              #删除值等于value的元素</span><br><span class="line">                                  #count&gt;0，从左至右，最多删除count个元素</span><br><span class="line">                                  #count&lt;0，从右至左，最多删除count绝对值个元素</span><br><span class="line">                                  #count=0，删除所有</span><br><span class="line">ltrim key start end               #保留列表中start到end的元素</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure></li><li>阻塞式弹出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blpop key1 key2 timeout</span><br><span class="line">brpop key1 key2 timeout</span><br></pre></td></tr></table></figure>列表为空时，timeout=3则客户端等到3s后返回，timeout=0则一直阻塞。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 3</span><br><span class="line">(nil)</span><br><span class="line">(3.09s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">...阻塞中...</span><br></pre></td></tr></table></figure>此期间添加了数据element1，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list:test element1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br><span class="line">(90.81s)</span><br></pre></td></tr></table></figure>列表不为空，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br></pre></td></tr></table></figure>若多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取弹出的值。</li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sF8WJs.png" alt=""></p><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于list-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于list-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>linkedlist（链表）<br>不满足ziplist时采用。</li></ul><p>注：Redis 3.2 版本提供了quicklist编码，是以一个ziplist为节点的linkedlist，结合了两者的优势。</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>消息队列<br>使用lpush和brpop命令组合实现阻塞队列，如图。<br><img src="https://s3.ax1x.com/2021/01/03/s9MDTP.png" alt=""></li><li>文章列表<br>如分页展示文章列表。<ul><li>每篇文章使用哈希存储<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset acticle:1 title xx timestamp 1476536196 content xxxx</span><br></pre></td></tr></table></figure></li><li>向用户文章列表添加文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush user:1:acticles article:1 article:2</span><br></pre></td></tr></table></figure></li><li>分页获取用户文章列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">articles = lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">  hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush+lpop=Stack（ 栈）</span><br><span class="line">lpush+rpop=Queue（ 队列）</span><br><span class="line">lpsh+ltrim=Capped Collection（ 有限集合）</span><br><span class="line">lpush+brpop=Message Queue（ 消息队列）</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）用来保存多个<strong>无序</strong>字符串元素，且不允许有重复的元素，不支持下标索引。<br>一个集合可以存储2^32-1个元素<br>Redis支持集合内的增删改查以及集合间取交集、并集和差集。</p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内操作<ul><li>添加元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd key element1 element2</span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem key element1 element2</span><br></pre></td></tr></table></figure></li><li>计算元素个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scard key  #时间复杂度O(1)，直接调用Redis内部变量</span><br></pre></td></tr></table></figure></li><li>判断元素是否在集合中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></li><li>随机从集合返回指定个数的元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srandmember key count  #count默认为1</span><br></pre></td></tr></table></figure></li><li>从集合随机弹出count个元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop key count #Redis&gt;3.2，count默认为1</span><br></pre></td></tr></table></figure></li><li>获取所有元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间操作<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter key1 key2</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sunion key1 key2</span><br></pre></td></tr></table></figure></li><li>差集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure></li><li>将交集、并集和差集的结果保存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将key1和key2运算的结果保存在destination_key中</span></span><br><span class="line">sinterstore destination_key key1 key2</span><br><span class="line">sunionstore destination_key key1 key2</span><br><span class="line">sdiffstore destination_key key1 key2</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG9eO.png" alt=""></p><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>intset（整数集合）<br>更加节省内存。<br>使用场景：<ul><li>集合中都是整数且元素个数小于set-max-intset-entries配置（默认512个）</li></ul></li><li>hashtable（哈希表）<br>不满足intset时采用。</li></ul><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合典型的使用场景是<strong>标签</strong>（用于提升用户体验和增强用户黏度）。<br>注：用户和标签的关系维护应在一个事务内执行，防止部分命令失败造成的数据不一致。</p><ul><li>给用户添加标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>给标签添加用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>删除用户下的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>删除标签下的用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>计算用户共同感兴趣的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd=Tagging（标签）</span><br><span class="line">spop/srandmember=Random item（生成随机数， 比如抽奖）</span><br><span class="line">sadd+sinter=Social Graph（社交需求）</span><br></pre></td></tr></table></figure><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>相较于集合，有序集合中的元素依据分数进行排序，且元素不能重复但分数可以重复。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内<ul><li>添加成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 score2 member2</span><br><span class="line"></span><br><span class="line"><span class="meta">Redis&gt;</span><span class="bash">3.2，添加了如下参数：</span></span><br><span class="line">nx：member必须不存在才可以添加成功，用于添加。</span><br><span class="line">xx：member必须存在才可以添加成功，用于更新。</span><br><span class="line">ch：返回此次操作后，元素和分数发生变化的个数。</span><br><span class="line">incr：对score做增加，等于zincrby</span><br></pre></td></tr></table></figure></li><li>计算成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure></li><li>计算某个成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure></li><li>计算成员的排名<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrank key member  #分数从低到高</span><br><span class="line">zrevrank key member  #分数从高到低</span><br></pre></td></tr></table></figure></li><li>增加成员的分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li><li>返回指定排名范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrange key start end [withscores]  #从低到高，withscores可选</span><br><span class="line">zrevrange key start end withscores</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]  #限制起始的位置和个数</span><br><span class="line">zrevrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line"></span><br><span class="line">limit offset count 可选参数，限制起始的位置和个数</span><br><span class="line">min和max支持开区间()和闭区间[]，-inf和+inf代表无穷小和无穷大</span><br></pre></td></tr></table></figure></li><li>返回指定分数范围的成员个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li><li>删除成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem key member1 member2</span><br></pre></td></tr></table></figure></li><li>删除指定排名内的升序元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure></li><li>删除指定分数范围的成员<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br><span class="line"></span><br><span class="line">destinatin：保存计算结果的键</span><br><span class="line">numkeys：参与计算键的个数</span><br><span class="line">weight：每个键的权重，每个键的member会将自己的分数乘以这个权重。</span><br><span class="line">aggregate sum|min|max：计算成员交集后，分数可以按照sum、min和max做汇总，默认sum。</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zunionstore destination numkeys key1 key2 weight1 weight2 [aggregate sum|min|max]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>各命令时间复杂度如图。<br><img src="https://s3.ax1x.com/2021/01/05/sFG1Yj.png" alt=""></p><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于zset-max-ziplist-entries配置（默认128个）</li><li>同时所有的值小于zset-max-ziplist-value配置（默认64字节）</li></ul></li><li>skiplist（跳跃表）<br>不满足ziplist时采用。</li></ul><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景为排行榜系统。榜单的维度可以是多方面的。<br>例如视频网站对用户上传到视频做排行榜，使用赞数这个维度。</p><ul><li>添加用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd user:ranking:2021_01_05 3 mike  #用户mike上传了一个视频并获得了3个赞</span><br><span class="line">zincrby user:ranking:2021_01_05 1 mike  #之后又获得了一个赞</span><br></pre></td></tr></table></figure></li><li>取消用户赞数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrem user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li><li>展示获赞数最多前十用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zrevrangebyrank user:ranking:2021_01_05 0 9</span><br></pre></td></tr></table></figure></li><li>展示用户信息及分数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2021_01_05 mike</span><br><span class="line">zrank user:ranking:2021_01_05 mike</span><br></pre></td></tr></table></figure></li></ul><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><p>关于键的一些通用命令介绍。<br>接2.1.1全局命令的一些其他命令。</p><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><ul><li><p>键重命名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure><p>（1）若rename的newkey已存在，那么该已存在的newkey的值会变成被rename的key的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set old a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set new b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rename old new</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get old</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get new</span><br><span class="line">"a"</span><br></pre></td></tr></table></figure><p>（2）为防止被强行rename，Redis提供了<code>renamenx</code>命令，只有newkey不存在时才能rename成功。<br>（3）由于重命名键期间会执行del删除旧的键，如果键对应的值较大，可能会导致阻塞。<br>（4）<code>rename key key</code>在3.2版本前会报错。</p></li><li><p>随机返回一个键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure></li><li><p>键过期</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire key seconds                      #键在seconds秒后过期</span><br><span class="line">pexpire key millionseconds              #毫秒级</span><br><span class="line">                                        #key不存在返回0</span><br><span class="line">                                        #seconds为负数，键会立即被删除</span><br><span class="line"></span><br><span class="line">expireat key timestamp                  #键在秒级时间戳timestamp后过期</span><br><span class="line">pexpireat key millionseconds-timestamp  #毫秒级</span><br><span class="line"></span><br><span class="line">ttl key                                 #查询键的剩余过期时间，单位秒。</span><br><span class="line">pttl key                                #毫秒级</span><br><span class="line">                                        #-1表示键没有设置过期时间，-2表示键不存在</span><br><span class="line"></span><br><span class="line">persist key                             #消除键的过期时间</span><br></pre></td></tr></table></figure><p>（1）无论何种方式，在Redis内部最终使用的是pexpireat。<br>（2）对于字符串类型的键，执行<code>set</code>命令会消除过期时间，详见源码中set命令的函数setKey。<br>（3）Redis不支持二级数据结构（哈希、列表等）内部元素的过期功能。<br>（4）<code>setex</code>作为set+expire的组合，不单是原子执行，且减少了一次网络通讯的时间。</p></li><li><p>迁移键</p><ul><li><p>move</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>Redis内部可以有多个数据库，且彼此相互隔离。move命令用于在Redis内部进行数据迁移。</p></li><li><p>dump+store</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value  #ttl为过期时间，=0不设置</span><br></pre></td></tr></table></figure><p>dump+store可实现不同Redis实例之间的数据迁移,整个迁移过程是非原子性的过程，且需要开启两个客户端连接。分为两步：<br>（1）在源Redis上执行dump，将键值序列化，为RDB格式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> <span class="built_in">set</span> hello world</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-source&gt;</span><span class="bash"> dump hello</span></span><br><span class="line">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span><br></pre></td></tr></table></figure><p>（2）在目标Redis上执行restore，进行复原。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> restore hello 0 <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis-target&gt;</span><span class="bash"> get hello</span></span><br><span class="line">"world</span><br></pre></td></tr></table></figure><p>对应伪代码为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Redis sourceRedis = new Redis("sourceMachine", 6379)</span><br><span class="line">Redis targetRedis = new Redis("targetMachine", 6379)</span><br><span class="line">targetRedis.restore("hello", 0, sourceRedis.dump(key))</span><br></pre></td></tr></table></figure></li><li><p>migrate</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key...]]</span><br><span class="line"></span><br><span class="line">host：              目标Redis的IP地址。</span><br><span class="line">port：              目标Redis的端口。</span><br><span class="line">key|""：            在Redis3.0.6版本之前，migrate只支持迁移一个键，所以此处是要迁移的键，</span><br><span class="line">                    在Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串""。</span><br><span class="line">destination-db：    目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</span><br><span class="line">timeout：           迁移的超时时间（单位为毫秒）。</span><br><span class="line">[copy]：            如果添加此选项，迁移后并不删除源键。</span><br><span class="line">[replace]：         如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</span><br><span class="line">[keys key[key...]]：迁移多个键，例如要迁移key1、key2、key3，此处填写“keys key1 key2 key3”。</span><br></pre></td></tr></table></figure><p>（1）migrate命令也是用于在Redis实例间进行数据迁移，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率。<br>（2）第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。第二，migrate命令的数据传输直接在源Redis和目标Redis上完成。第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</p><p>示例：</p><ul><li>源Redis有键hello，目标Redis没有<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis和目标Redis都有键hello<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000</span><br><span class="line">(error) ERR Target instance replied with error: BUSYKEY Target key name already exists.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6379 hello 0 1000 replace</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>源Redis没有键hello。如下所示，此种情况会收到nokey的提示<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 hello 0 1000</span><br><span class="line">NOKEY</span><br></pre></td></tr></table></figure></li><li>源Redis执行如下命令完成多个键的迁移<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; migrate 127.0.0.1 6380 "" 0 5000 keys key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><ul><li><p>全量遍历键</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keys pattern  #patterm使用glob风格通配符</span><br><span class="line"></span><br><span class="line">* 代表匹配所有任意字符</span><br><span class="line">? 代表匹配一个任意字符</span><br><span class="line">[1,3] 代表匹配1和3，[1-3] 代表匹配1到3的任意数字</span><br><span class="line">\x 转义字符</span><br></pre></td></tr></table></figure><p>考虑到Redis的单线程架构，keys命令一般只在以下三种情况使用：</p><ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但是会影响到主从复制。</li><li>如果确认键值总数确实比较少，可以执行该命令。</li><li>使用scan命令渐进式的遍历所有键。</li></ul></li><li><p>渐进式遍历</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br><span class="line"></span><br><span class="line">cursor：是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</span><br><span class="line">match pattern：可选参数，作用是做模式匹配。</span><br><span class="line">count number：可选参数，作用是表明每次要遍历的键个数，默认值是10，可以适当增大。</span><br></pre></td></tr></table></figure><p>Redis存储键值对实际使用hashtable作为内部编码。<br>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "15"</span><br><span class="line">2)  1) "new"</span><br><span class="line">    2) "c"</span><br><span class="line">    3) "a"</span><br><span class="line">    4) "key"</span><br><span class="line">    5) "nice"</span><br><span class="line">    6) "b"</span><br><span class="line">    7) "mylist"</span><br><span class="line">    8) "d"</span><br><span class="line">    9) "redis"</span><br><span class="line">  10) "user:1"</span><br><span class="line">127.0.0.1:6379&gt; scan 15</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "hello"</span><br></pre></td></tr></table></figure><p>除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如hgetall、smembers、zrange可能产生的阻塞问题，对应的命令分别是hscan、sscan、zscan。<br>需要注意的是scan过程中如果有键的变化，那么可能会遍历重复的键，而遍历不到新增的键。</p></li></ul><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><ul><li><p>切换数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select dbIndex</span><br></pre></td></tr></table></figure><p>Redis只用数字来标识数据库，默认有16个，各数据库独立。<br>但是该功能已逐步废弃了，原因如下：</p><ul><li>Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响。</li><li>多数据库的使用方式，会让调试和运维不同业务的数据库变的困难，假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困难。</li><li>部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱。<br>所以在需要多个数据库功能的情况下，可以在一台机器上部署多个Redis实例，以端口来区分。</li></ul></li><li><p>flushdb和flushall<br>flushdb只清除当前数据库，flushall会清除所有数据库。<br>带来的问题：</p><ul><li>flushdb/flushall命令会将所有数据清除，一旦误操作后果不堪设想。</li><li>如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能性。</li></ul></li></ul><h2 id="Ch-3-小功能大用处"><a href="#Ch-3-小功能大用处" class="headerlink" title="Ch 3 小功能大用处"></a>Ch 3 小功能大用处</h2><h3 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h3><p>发送命令&gt;命令排队&gt;命令执行&gt;返回结果<br>慢查询只统计命令执行的时间，并不反映客户端的超时问题。</p><h4 id="两个配置参数"><a href="#两个配置参数" class="headerlink" title="两个配置参数"></a>两个配置参数</h4><ul><li>预设阈值<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">单位：微秒，默认值=10000</span><br><span class="line">等于0会记录所有记录，小于0不记录任何命令</span><br></pre></td></tr></table></figure></li><li>慢查询记录存放位置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite  #将配置持久化到本地配置文件</span><br><span class="line"></span><br><span class="line">Redis使用一个列表来存储慢查询日志（类似队列），</span><br><span class="line">slowlog-max-len指定列表最大长度</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><ul><li>获取慢查询日志<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog get [n]  #n可选，指定条数</span><br><span class="line"></span><br><span class="line">每个慢查询记录有4个属性，分别为：</span><br><span class="line">标识id、发生时间戳、命令耗时以及执行的命令和参数。</span><br></pre></td></tr></table></figure></li><li>获取慢查询日志列表当前长度<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></table></figure></li><li>慢查询日志重置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></li></ul><h4 id="实践注意事项"><a href="#实践注意事项" class="headerlink" title="实践注意事项"></a>实践注意事项</h4><ul><li><strong>slowlog-max-len配置建议</strong>：线上建议调大慢查询列表，可设置为1000以上，记录慢查询时Redis会对长命令做截断操作，并不会占用大量内存，增大慢查询列表可以减缓慢查询被剔除的可能。</li><li><strong>slowlog-log-slower-than配置建议</strong>：默认值超过10毫秒判定为慢查询，需要根据Redis并发量调整该值。由于Redis采用单线程响应命令，对于高流量的场景，如果命令执行时间在1毫秒以上，那么Redis最多可支撑OPS不到1000，因此对于高OPS场景的Redis建议设置为1毫秒。</li><li><strong>慢查询只记录命令执行时间</strong>，并不包括命令排队和网络传输时间，因此客户端执行命令的时间会大于命令实际执行时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此当客户端出现请求超时，需要检查该时间点是否有对应的慢查询，从而分析出是否为慢查询导致的命令级联阻塞。</li><li><strong>慢查询日志是一个先进先出的队列</strong>，如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化到其他存储中（例如MySQL），然后可以制作可视化界面进行查询，第13章介绍的Redis私有云CacheCloud提供了这样的功能，好的工具可以让问题排查事半功倍。</li></ul><h3 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h3><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><ul><li>-r<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 ping</span><br><span class="line"></span><br><span class="line">将ping命令执行3次</span><br></pre></td></tr></table></figure></li><li>-i（interval）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -r 3 -i 1 ping</span><br><span class="line"></span><br><span class="line">每隔几秒执行一次一次命令，单位：秒</span><br><span class="line">-i必须与-r一起用</span><br></pre></td></tr></table></figure></li><li>-x<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "world" | redis-cli -x set hello</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">-x选项代表从标准输入（stdin）读取数据作为redis-cli的最后一个参数。</span><br></pre></td></tr></table></figure></li><li>-c（cluster）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">连接Redis Cluster节点时需要使用，-c选项可以防止moved和ask异常，有关Redis Cluster将在第10章介绍。</span><br></pre></td></tr></table></figure></li><li>-a（auth）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果Redis配置了密码，可以用-a（auth）选项，有了这个选项就不需要手动输入auth命令。</span><br></pre></td></tr></table></figure></li><li>–scan和–pattern<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--scan选项和--pattern选项用于扫描指定模式的键，相当于使用scan命令。</span><br></pre></td></tr></table></figure></li><li>–slave<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--slave选项是把当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作，</span><br><span class="line">有关于Redis复制将在第6章进行详细介绍。</span><br><span class="line">合理的利用这个选项可以记录当前连接Redis节点的一些更新操作，</span><br><span class="line">这些更新操作很可能是实际开发业务时需要的数据。</span><br></pre></td></tr></table></figure></li><li>–rdb<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--rdb选项会请求Redis实例生成并发送RDB持久化文件，保存在本地。可使用它做持久化文件的定期备份。</span><br><span class="line">有关Redis持久化将在第5章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–pipe<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--pipe选项用于将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行，</span><br><span class="line">有关Redis通信协议将在第4章进行详细介绍。</span><br></pre></td></tr></table></figure></li><li>–bigkeys<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--bigkeys选项使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈。</span><br></pre></td></tr></table></figure></li><li>–eval<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--eval选项用于执行指定Lua脚本，有关Lua脚本的使用将在3.4节介绍。</span><br></pre></td></tr></table></figure></li><li>–latency<br>用于检测网络延迟，有三个选项<ul><li>–lantency<br>该选项可以测试客户端到目标Redis的网络延迟，<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h &#123;server&#125; --latency</span><br></pre></td></tr></table></figure></li><li>–latency-history</li><li>-latency的执行结果只有一条，如果想以分时段的形式了解延迟信息，可以使用–latency-history选项，可以通过-i参数控制间隔时间。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.xx.xx --latency-history -i 10</span><br></pre></td></tr></table></figure></li><li>–latency-dist<br>该选项会使用统计图表的形式从控制台输出延迟统计信息。</li></ul></li><li>–stat<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--stat选项可以实时获取Redis的重要统计信息.</span><br></pre></td></tr></table></figure></li><li>–raw和–no-raw<br>–no-raw选项要求命令的返回结果必须是原始的格式，–raw返回格式化后的结果。</li></ul><h4 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h4><p>redis-server启动Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认配置启动`redis-server`</span><br><span class="line">运行启动（加上需修改的参数）`redis-server --port 6380`</span><br><span class="line">配置文件启动`redis-sever /opt/redis/redis.conf`</span><br></pre></td></tr></table></figure><p>redis-server除了启动Redis外，还有一个–test-memory选项，可以用来检测当前操作系统能否稳定地分配指定容量的内存给Redis，通过这种检测可以有效避免因为内存问题造成Redis崩溃。<br>下面的命令检测当前操作系统能否提供1G的内存给Redis：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server --test-memory 1024</span><br></pre></td></tr></table></figure><h4 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h4><p>redis-benchmark可以为Redis做基准性能测试。</p><ul><li>-c（clients）<br>-c选项代表客户端的并发数量（默认是50）。</li><li>-n（num）<br>-n选项代表客户端请求总量（默认是100000）。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000</span><br><span class="line"></span><br><span class="line">代表测试100个客户端同时请求Redis，共执行20000次时的性能</span><br><span class="line">output：</span><br><span class="line">====== GET ======</span><br><span class="line">20000 requests completed in 0.27 seconds</span><br><span class="line">100 parallel clients</span><br><span class="line">3 bytes payload</span><br><span class="line">keep alive: 1</span><br><span class="line"></span><br><span class="line">99.11% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">73529.41 requests per second</span><br></pre></td></tr></table></figure></li><li>-q<br>-q选项仅仅显示redis-benchmark的requests per second信息。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000 -q</span><br></pre></td></tr></table></figure></li><li>-r<br>在一个空的Redis上执行了redis-benchmark会发现只有3个键：<code>counter:__rand_int__</code>、<code>mylist</code>和<code>key:__rand_int__</code>。<br>如果想向Redis插入更多的键，可以执行使用-r（random）选项，可以向Redis插入更多随机的键。<br>-r选项会在key、counter键上加一个12位的后缀，-r 10000代表只对后四位做随机处理（-r不是随机数的个数）。</li><li>-P<br>-P选项代表每个请求pipeline的数据量（默认为1）。</li><li>-k<br>-k选项代表客户端是否使用keepalive，1为使用，0为不使用，默认值为1。</li><li>-t<br>-t选项可以对指定命令进行基准测试。<br>示例：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set -q</span><br><span class="line">SET: 98619.32 requests per second</span><br><span class="line">GET: 97560.98 requests per second</span><br></pre></td></tr></table></figure></li><li>–csv<br>–csv选项会将结果按照csv格式输出，便于后续处理，如导出到Excel等。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -t get,set --csv</span><br><span class="line">"SET","81300.81"</span><br><span class="line">"GET","79051.38"</span><br></pre></td></tr></table></figure></li></ul><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Redis客户端从发送命令到接收到返回结果的时间为一次RTT，Redis提供的批量操作命令能减少RTT，但大部分命令并不支持批量操作。</li><li>Pipeline（流水线）机制，能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</li><li>redis-cli的–pipe选项实际上就是使用Pipeline机制，例如下面操作将set hello world和incr counter两条命令组装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -en '*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n*2\r\n$4\r\nincr\r\</span><br><span class="line">    n$7\r\ncounter\r\n' | redis-cli --pipe</span><br></pre></td></tr></table></figure></li></ul><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><ul><li>Pipeline执行速度一般比逐条执行要快。</li><li>客户端和服务端的网络延时越大，Pipeline的效果越明显。</li></ul><h4 id="原生批量命令与Pipeline对比"><a href="#原生批量命令与Pipeline对比" class="headerlink" title="原生批量命令与Pipeline对比"></a>原生批量命令与Pipeline对比</h4><ul><li>原生批量命令是原子的，Pipeline是非原子的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</li><li>Pipeline虽然只能操作一个Redis实例，但是即使在分布式Redis场景中，也可以作为批量操作的重要优化手段，具体细节见第11章。</li></ul><h3 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h3><p>为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>将一组需一起执行的命令放在<code>multi</code>和<code>exec</code>之间，若要停止事务的执行，使用<code>discard</code>命令代替<code>exec</code>。<br>若事务中出现错误，Redis有不同的处理机制：</p><ul><li>命令错误<br>命令写错造成的语法错误，整个事务无法执行。</li><li>运行时错误<br>命令写错但仍是可执行的命令，<strong>Redis不支持回滚操作</strong>，只能自行修复。<br>有些应用场景需要在事务之前，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁，其他客户端的修改会执行）。Redis提供了watch命令来解决这类问题。</li></ul><h4 id="Lua用法简述"><a href="#Lua用法简述" class="headerlink" title="Lua用法简述"></a>Lua用法简述</h4><h4 id="Redis与Lua"><a href="#Redis与Lua" class="headerlink" title="Redis与Lua"></a>Redis与Lua</h4><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h4 id="Redis如何管理Lua脚本"><a href="#Redis如何管理Lua脚本" class="headerlink" title="Redis如何管理Lua脚本"></a>Redis如何管理Lua脚本</h4><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="数据结构模型"><a href="#数据结构模型" class="headerlink" title="数据结构模型"></a>数据结构模型</h4><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><h4 id="BitMaps分析"><a href="#BitMaps分析" class="headerlink" title="BitMaps分析"></a>BitMaps分析</h4><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h4><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><h2 id="Ch-4-客户端"><a href="#Ch-4-客户端" class="headerlink" title="Ch 4 客户端"></a>Ch 4 客户端</h2><h3 id="客户端通信协议"><a href="#客户端通信协议" class="headerlink" title="客户端通信协议"></a>客户端通信协议</h3><h3 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h3><h3 id="Python客户端redis-python"><a href="#Python客户端redis-python" class="headerlink" title="Python客户端redis-python"></a>Python客户端redis-python</h3><h3 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h3><h3 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h3><h3 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h3><h2 id="Ch-5-持久化"><a href="#Ch-5-持久化" class="headerlink" title="Ch 5 持久化"></a>Ch 5 持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h3 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h3><h3 id="多实例部署"><a href="#多实例部署" class="headerlink" title="多实例部署"></a>多实例部署</h3><h2 id="Ch-6-复制"><a href="#Ch-6-复制" class="headerlink" title="Ch 6 复制"></a>Ch 6 复制</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h3><h2 id="Ch-7-阻塞"><a href="#Ch-7-阻塞" class="headerlink" title="Ch 7 阻塞"></a>Ch 7 阻塞</h2><h3 id="发现阻塞"><a href="#发现阻塞" class="headerlink" title="发现阻塞"></a>发现阻塞</h3><h3 id="内在原因"><a href="#内在原因" class="headerlink" title="内在原因"></a>内在原因</h3><h3 id="外在原因"><a href="#外在原因" class="headerlink" title="外在原因"></a>外在原因</h3><h2 id="Ch-8-理解内存"><a href="#Ch-8-理解内存" class="headerlink" title="Ch 8 理解内存"></a>Ch 8 理解内存</h2><h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆录</title>
    <url>/post/Life/memories/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>脑海中闪过的片段<a id="more"></a><br>时常有一些回忆片段涌现出脑海，借此记录下来。</p>]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>Python进阶</title>
    <url>/post/Python/fluent-python-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《流畅的Python》学习笔记<a id="more"></a><br>学习Python之前，最好熟悉一下Python的语言和风格规范<br><a href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html" target="_blank" rel="noopener">https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html</a><br>原项目：<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">https://github.com/google/styleguide</a></p><center><span style="font-weight:700;font-size:24px">序幕</span></center><h2 id="Ch1-Python数据模型"><a href="#Ch1-Python数据模型" class="headerlink" title="Ch1 Python数据模型"></a>Ch1 Python数据模型</h2><p>数据（对象）模型是对Python框架的描述，规范了这门语言自身构建模块的接口，这些模块包括序列、迭代器、函数、类和上下文管理器等。<br>而无论在哪种框架下编程，都会大量实现会被框架本身调用的方法，Python里会使用特殊方法去激活一些基本的对象操作，这类方法称为魔术方法（magic method）或双下方法（dunder method），形如<code>__getitem__</code>。</p><h3 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h3><p>如下代码段：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="comment">#collections.namedtuple用于构建一个简单的类，</span></span><br><span class="line"><span class="comment">#该类用来构建只有少数属性但没有方法的对象，如数据库条目。</span></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'方块 梅花 红桃 黑桃'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="string">"""提供了元素定位deck[0]</span></span><br><span class="line"><span class="string">        将[]操作交给self._cards列表，所以deck类自动支持切片操作且可迭代（支持反向迭代reversed(deck)）</span></span><br><span class="line"><span class="string">        迭代通常是隐式的，若一个集合类型未实现__contains__方法，那么in运算就会按顺序做一次迭代搜索</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    card1 = Cards(<span class="number">3</span>, <span class="string">'红桃'</span>)</span><br><span class="line">    print(card1)</span><br><span class="line">    deck = FrenchDeck()</span><br><span class="line">    print(len(deck))</span><br><span class="line">    print(deck[<span class="number">-1</span>])</span><br><span class="line">    print(choice(deck))</span><br><span class="line">    print(Card(<span class="string">'7'</span>, <span class="string">'红桃'</span>))</span><br><span class="line">    <span class="comment"># TODO(xyr): 排序和洗牌</span></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">    Card(rank=<span class="number">3</span>, suit=<span class="string">'红桃'</span>)</span><br><span class="line">    <span class="number">52</span></span><br><span class="line">    Card(rank=<span class="string">'A'</span>, suit=<span class="string">'黑桃'</span>)</span><br><span class="line">    Card(rank=<span class="string">'3'</span>, suit=<span class="string">'黑桃'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h3><ul><li>首先，特殊方法是为了被Python解释器调用，而非自己调用，除非有大量元编程存在，或者在自己的子类的<code>__init__</code>方法中调用超累的构造器。</li><li>特殊方法的调用一般是隐式的，比如<code>for i in x:</code>调用的其实是iter(x)，而这个函数背后则是<code>x.__iter__()</code>方法（前提是这个方法已经在x中被实现）。</li><li>通过内置的函数（len、str等）使用特殊方法是最好的选择。</li><li>如果是Python内置的类型（list、str等），CPython的<code>__len__</code>实际上会直接返回PyVarObject（表示内存中长度可变的内置对象的C语言结构体）里的ob_size属性。</li><li>不要随意添加特殊方法，以防在后面的更新中被Python内部使用而产生冲突。</li></ul><h4 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h4><p>利用特殊方法，可以让自定义对象通过“+”（或别的运算符）进行运算，例如下面的一个自定义的二维向量类，其中的+、*和abs（取绝对值或取模）运算即是由这些特殊方法实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line">        <span class="comment"># return bool(self.x or self.y)  #更加高效</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)  <span class="comment">#未考虑交换律</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    v1 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    v2 = Vector(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    print(v1+v2)</span><br><span class="line">    print(abs(v1))</span><br><span class="line">    print(v1*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">    Vector(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="number">5.0</span></span><br><span class="line">    Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h4><ul><li>Python通过内置函数repr将一个对象用字符串的形式表达出来，repr就是通过<code>__repr__</code>这个特殊方法得到一个对象的字符串的形式，若未实现<code>__repr__</code>，打印一个向量实例时得到的会是<code>&lt;Vector object at 0x10e100070&gt;</code></li><li>格式化字符串的两种方法，使用<code>%</code>和使用<code>str.format</code>均利用了repr。</li><li><code>__repr__</code>中使用<code>%r</code>来获取对象各个属性的标准字符串表示形式。</li><li><code>__repr__</code>所返回的字符串应准确无歧义，且尽可能表达出如何用代码创建出这个被打印的对象。</li><li><code>__repr__</code>和<code>__str__</code>的区别在于前者方便记录和调试日志，后者在<code>str()</code>函数被使用，或<code>print()</code>打印对象时被调用，且返回的字符串对终端用户更友好。两者优先实现<code>__repr__</code>，因为一个函数没有<code>__str__</code>而去调用它会用<code>__repr__</code>来代替。（详见<a href="http://stackoverflow.com/questions/1436703/differencebetween-str-and-repr-in-python）" target="_blank" rel="noopener">http://stackoverflow.com/questions/1436703/differencebetween-str-and-repr-in-python）</a></li></ul><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>通过<code>__add__</code>和<code>__mul__</code>实现了+和*，这里不改变操作对象，而是返回一个新创建的向量对象。</p><h4 id="自定义的布尔值"><a href="#自定义的布尔值" class="headerlink" title="自定义的布尔值"></a>自定义的布尔值</h4><ul><li><code>bool(x)</code>背后调用<code>x.__bool__()</code>，若未实现<code>__bool__</code>方法，那么<code>bool(x)</code>会尝试调用<code>x.__len__()</code>，0为False，否则返回True。</li><li>默认情况下自定义类的实例总为真，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。</li><li>更高效的<code>__bool__</code>方法，<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h3><p>Python语言参考手册中的“DataModel”，<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">（https://docs.python.org/3/reference/datamodel.html）</a>一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。<br><img src="https://s3.ax1x.com/2021/01/04/sP0shD.jpg" alt=""></p><h3 id="为什么len不是普通方法"><a href="#为什么len不是普通方法" class="headerlink" title="为什么len不是普通方法"></a>为什么len不是普通方法</h3><p>“实用胜于纯粹，不能让特例特殊到破坏既定规则。”<br>len之所以不是一个普通方法，是为了让Python自带的数据结构可以走后门，abs也是同理。但是多亏了它是特殊方法，我们也可以把len用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点。</p><center><span style="font-weight:700;font-size:24px">数据结构</span></center><h2 id="Ch2-序列构成的数组"><a href="#Ch2-序列构成的数组" class="headerlink" title="Ch2 序列构成的数组"></a>Ch2 序列构成的数组</h2><p>无论那种数据结构，都共用一套操作：<strong>迭代</strong>、<strong>切片</strong>、<strong>排序</strong>和<strong>拼接</strong>。</p><h3 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h3><h3 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h3><h3 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h3><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h3 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h3><h3 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h3><h3 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h3><h3 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h3><h3 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>WireShark网络分析</title>
    <url>/post/Networks/wireshark/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>WireShark网络分析</p><a id="more"></a><p>官网：<a href="https://www.wireshark.org/" target="_blank" rel="noopener">https://www.wireshark.org/</a></p><h2 id="《Wireshark网络分析的艺术》笔记"><a href="#《Wireshark网络分析的艺术》笔记" class="headerlink" title="《Wireshark网络分析的艺术》笔记"></a>《Wireshark网络分析的艺术》笔记</h2><h3 id="关于TCP的延迟确认机制可能带来的性能问题，"><a href="#关于TCP的延迟确认机制可能带来的性能问题，" class="headerlink" title="关于TCP的延迟确认机制可能带来的性能问题，"></a>关于TCP的延迟确认机制可能带来的性能问题，</h3><ul><li><strong>延迟确认的优点</strong>：在延迟的时间内，客户端有数据要发，就可以在发数据时捎带确认信息，省去一个纯粹的确认包（实际为帧，后面全称为包），进而节省带宽。</li><li><strong>可能会导致的问题</strong>：网络拥塞时大量重传影响性能，或因延迟太久导致超时重传，或TCP窗口极小。</li><li><strong>解决</strong>：启用SACK会在ACK中附带已收到的包号（或者关闭延迟确认），从而解决延迟确认带来的性能问题。<br>在Wireshark抓包中使用Filter：<code>tcp.analysis.ack_rtt&gt;0.2 and tcp.len==0</code>将超过200ms的确认包筛选出来</li></ul><h3 id="关于TCP的三次握手失败分析"><a href="#关于TCP的三次握手失败分析" class="headerlink" title="关于TCP的三次握手失败分析"></a>关于TCP的三次握手失败分析</h3><ul><li><strong>主要原因</strong>：</li></ul>]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>WireShark</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫基础</title>
    <url>/post/Python/python-spider/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Python3网络爬虫开发实战》笔记<a id="more"></a></p><h2 id="Ch-1-爬虫基础"><a href="#Ch-1-爬虫基础" class="headerlink" title="Ch 1 爬虫基础"></a>Ch 1 爬虫基础</h2><h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><p>URI的全称为 Uniform Resource Identifier，即统一资源标志符。<br>URL的全称为 Universal Resource Locator，即统一资源定位符。<br>URN的全称为 Universal Resource Name，即统一资源名称。<br>三者关系为：<br><img src="https://s3.ax1x.com/2021/01/05/skJuQI.png" alt=""></p><h4 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h4><p>HypeText</p><h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>HTTP的全称是Hyper Text Transfer Protocol，超文本传输协议。<br>HTTPS的全称是Hyper Text Transfer Protocol over Secure Socket Layer，是以安全为目标的HTTP通道，简单讲是 HTTP 的安全版，即HTTP下加入 SSL层，简称为HTTPS。</p><h4 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h4><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ul><li><p>请求方法<br><img src="https://s3.ax1x.com/2021/01/05/skt3GQ.png" alt=""></p></li><li><p>请求网址<br>URL</p></li><li><p>请求头<br>用来说明服务器要使用的附加信息。<br><img src="https://s3.ax1x.com/2021/01/05/sktHsI.png" alt=""></p><p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p></li><li><p>请求体<br>一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。<br><img src="https://s3.ax1x.com/2021/01/05/skNbp4.png" alt=""></p><p>在爬虫中，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type， 不然可能会导致POST提交后无法正常响应。</p></li></ul><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul><li><p>响应状态码<br>响应状态码表示服务器的响应状态。<br><img src="https://s3.ax1x.com/2021/01/05/skUWCD.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/05/skaVxJ.png" alt=""></p></li><li><p>响应头<br>响应头包含了服务器对请求的应答信息。<br><img src="https://s3.ax1x.com/2021/01/05/skavFK.png" alt=""></p></li><li><p>响应体<br>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。</p></li></ul><h3 id="网页基础"><a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h3><h4 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h4><p>网页可以分为三大部分——HTML,CSS和JavaScript。如果把网页比作一个人的话， HTML相于骨架，JavaScript相当于肌肉，CSS相当于皮肤。</p><ul><li>HTML<br>HTML是用来描述网页的一种语言，其全称叫作Hyper Text Markup Language，即超文本标记语言。</li><li>CSS<br>CSS，全称叫作Cascading Style Sheets，即层叠样式表。</li><li>JavaScript<br>JavaScript，简称JS，是一种脚本语言，实现了一种实时、动态、交互的页面功能。</li></ul><h4 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="节点树及节点间关系"><a href="#节点树及节点间关系" class="headerlink" title="节点树及节点间关系"></a>节点树及节点间关系</h4><p><img src="https://s3.ax1x.com/2021/01/05/skyP9x.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/05/skykjO.png" alt=""></p><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>常用三种方法：根据id（#）、根据class（.）以及标签名（h1）进行筛选。<br>嵌套选择：</p><ul><li>各选择器之间加空格代表嵌套关系，如div #container为先选择一个div节点，在选择其内部id为container的节点。</li><li>不加空格代表并列关系，如div#container为选择id为container的div节点。</li></ul><p>css选择器还有一些其他语法规则，具体如表2-4所示。<br><img src="https://s3.ax1x.com/2021/01/05/skh0nx.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/05/skhWjI.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/05/skhhut.png" alt=""></p><h3 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h3><h4 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h4><ul><li>获取网页</li><li>提取信息</li><li>保存数据</li><li>自动化程序</li></ul><h4 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h4><p>HTML代码、JSON文件、二进制数据等</p><h4 id="JavaScript渲染页面"><a href="#JavaScript渲染页面" class="headerlink" title="JavaScript渲染页面"></a>JavaScript渲染页面</h4><p>通过分析其后台Ajax接口，或使用Selenium、Splash库来模拟JavaScript渲染。</p><h3 id="会话和Cookies"><a href="#会话和Cookies" class="headerlink" title="会话和Cookies"></a>会话和Cookies</h3><h4 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h4><h4 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h4><p>HTTP连接本身是无状态的。</p><ul><li><p>会话<br>Web中，会话对象用来存储特定用户会话所需的属性及配置信息。</p></li><li><p>Cookies<br>Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p></li><li><p>会话维持<br>当客户端第一次请求服务器时，服务器会返回一个请求头中带有Set-Cookie字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把Cookie保 存起来。当浏览器下一次再请求该网站时，浏览器会把此Cookies放到请求头一起提交给服务器，“Cookies携带了会话ID信息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来以此来辨认用户状态。</p></li><li><p>属性结构</p><ul><li>Name：该Cookie的名称。一旦创建，该名称便不可更改。</li><li>Value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</li><li>Domain：可以访问该 Cookie 的域名 。 例如，如果设置为 . zhihu.com ，则所有以 zh ihu .com 结尾的域名都可以访问该 Cookie。</li><li>Max Age：该Cookie失效的时间，单位为秒，也常和Expires一起使用，通过它可以计算出其有效时间。Max Age如果为正数，则该Cookie在Max Age 秒之后失效。如果为负数，则关闭浏览器时Cookie即失效，浏览器也不会以任何形式保存该Cookie。</li><li>Path：该Cookie的使用路径。如果设置为／path/，则只有路径为／path/的页面可以访问该Cookie；如果设置为/，则本域名下的所有页面都可以访问该Cookie。</li><li>Size字段：此Cookie的大小。</li><li>HTTP字段：Cookie的httponly属性。若此属性为true，则只有在HTTP头中会带有此Cookie的信息，而不能通过document.cookie来访问此Cookie。</li><li>Secure：该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据之前先将数据加密。默认为false。</li></ul></li><li><p>会话Cookie和持久Cookie<br>表面意思为会话Cookie存在浏览器内存里，浏览器关闭则Cookie失效；持久Cookie保存在硬盘里，下次可再次使用。<br>实际为设置Cookie的Max Age或Expires字段。</p></li></ul><h4 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h4><p>“浏览器关闭，会话就消失了”。是不准确的。</p><h3 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>本机的网络请求通过代理服务器访问Web服务器。</p><h4 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h4><ul><li>突破自身IP访问限制。</li><li>访问一些单位或团体内部资源。</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将·其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实IP：免受攻击或防止IP被封锁。</li></ul><h4 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h4><ul><li>根据协议区分<ul><li>FTP代理服务器：主要用于访问FTP服务器，一般有上传、下载以及缓存功能，端口一般为21、2121等。</li><li>HTTP代理服务器：主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80、8080、3128等。</li><li>SSl/TLS代理：主要用于访问加密网站，一般有SSL或TLS加密功能（最高支持128位加密强度），端口一般为443。</li><li>RTSP代理：主要用于访问Real流媒体服务器，一般有缓存功能，端口一般为554。</li><li>Telnet代理：主要用于telnet远程控制（黑客人侵计算机时常用于隐藏身份），端口一般为23。</li><li>POP3/SMTP代理：主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25。</li><li>SOCKS代理：只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5，前者只支持TCP，而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说，SOCKS4能做到的SOCKS5都可以做到，但 SOCKS5能做到的SOCKS4不一定能做到。</li></ul></li><li>根据匿名程度区分<ul><li>高度匿名代理：会将数据包原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP是代理服务器的IP。</li><li>普通匿名代理：会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加入的HTTP头有HTTP_VIA和 HTTP_X_FORWARDED_FOR。</li><li>透明代理：不但改动了数据包 还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网巾的硬件防火墙。</li><li>间谍代理：指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。</li></ul></li></ul><h4 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h4><ul><li>网上的免费代理</li><li>付费代理服务</li><li>ADSL拨号：拨一次号换一次IP，稳定性高。</li></ul><h2 id="Ch-2-基本库的使用"><a href="#Ch-2-基本库的使用" class="headerlink" title="Ch 2 基本库的使用"></a>Ch 2 基本库的使用</h2><h3 id="使用urllib"><a href="#使用urllib" class="headerlink" title="使用urllib"></a>使用urllib</h3><p>urllib为Python内置的HTTP请求库，包含以下4个模块：</p><ul><li>request：它是最基本的HTTP请求模块，可以用来模拟发送请求。</li><li>error：异常处理模块。</li><li>parse：一个工具模块，提供了许多URL处理方法，比如拆分、解析、合并等。</li><li>robot parser：主要是用来识别网站的robots.txt文件，然后判断哪些网站可以爬，哪些网站不可以爬，用得比较少。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><ul><li>urlopen()<br>urlopen()返回一个HTTPResponse类型的对象，主要包含read()、readinto()、getheader(name)、getheaders()、fileno()等方法，以及msg、version、status、reason、debuglevel、closed等属性。<br>urlopen()函数的API：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=<span class="literal">None</span>, timeout=<span class="number">1</span>, cafile=<span class="literal">None</span>, </span><br><span class="line">                            capath=<span class="literal">None</span>, cadefault=<span class="literal">False</span>, context=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">data：需要是字节流编码格式，即bytes类型，请求方法变为POST</span><br><span class="line">timeout：单位为秒</span><br><span class="line">cafile和capath：指定CA证书及其路径</span><br><span class="line">cadefault：已弃用</span><br><span class="line">context：用来指定SSL设置，必须是ssl.SSLContext类型</span><br></pre></td></tr></table></figure>示例：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;<span class="string">'word'</span>:<span class="string">'hello'</span>&#125;), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">response= urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>, data=data)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure></li><li>Request类<br>API：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span><span class="params">(ur1, data=None, headers=&#123;&#125;,</span></span></span><br><span class="line"><span class="class"><span class="params">                                  origin_req_host=None, unverifiable=False, method=None)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">headers</span>：为一个字典，用来构造请求头，也可以后面用<span class="title">add_header</span><span class="params">()</span>添加，常用来修改<span class="title">User</span>-<span class="title">Agent</span></span></span><br><span class="line"><span class="class"><span class="title">origin_req_host</span>：请求方的<span class="title">host</span>名称或<span class="title">IP</span>地址</span></span><br><span class="line"><span class="class"><span class="title">unverifiable</span>：请求权限问题</span></span><br><span class="line"><span class="class"><span class="title">method</span>：请求方法</span></span><br></pre></td></tr></table></figure>示例：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (Compatible; MSIE 5.5; Windows NT)'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span></span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf8'</span>)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></li><li>用Opener构建Handler<br>官方文档：<a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a><ul><li>验证<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line">username = <span class="string">'username'</span></span><br><span class="line">password = <span class="string">'password'</span></span><br><span class="line">url = <span class="string">'http://localhost:5000/'</span></span><br><span class="line"></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(<span class="literal">None</span>, url, username, password)</span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p)</span><br><span class="line">opener = build_opener(auth_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = opener.open(url)</span><br><span class="line">    html = result.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(html)</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure></li><li>代理<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1:9743'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'https://127.0.0.1:9743'</span></span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.open(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    print(response.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure></li><li>Cookies<ul><li>获取Cookies<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name+<span class="string">"="</span>+item.value)</span><br></pre></td></tr></table></figure></li><li>Cookie保存至文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'cookies.txt'</span></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)</span><br><span class="line"><span class="comment">#cookie = http.cookiejar.LWPCookieJar(filename)  另一种格式</span></span><br><span class="line"><span class="comment">#cookie.load('cookies.txt', ignore_discard=True, ignore_expires=True)  读取</span></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><ul><li>URLError<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'http://cuiqingcai.com/index.htm'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure></li><li>HTTPError<br>URLError是HTTPError的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'http://cuiqingcai.com/index.htm'</span>)</span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h4><p>url.parse模块，定义了处理URL的标准接口，例如实现URL各部分的抽取、合并以及链接转换。<br>支持如下协议的URL处理：file、ftp、gopher、hdl、http、https、imap、mailto、mms、news、nntp、prospero、rsync、rtsp、rtspu、sftp、sip、sips、snews、svn、svn+ssh、telnet和wais。<br>常用方法如下：</p><ul><li><p>urlparse()<br>实现URL的识别与分段。<br>API：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urllib.parse.urlparse(urlstring, scheme=<span class="string">''</span>, allow_fragments=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">scheme：url中没有协议时，作为默认的协议。</span><br><span class="line">allow_fragments：是否忽略fragment。如果设置为<span class="literal">False</span>，fragment部分就会被忽略，</span><br><span class="line">                 它会被依次解析为query、parameters或者path的一部分，而fragment部分为空。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html#comment'</span>,</span><br><span class="line">                   scheme=<span class="string">'https'</span>, allow_fragments=<span class="literal">False</span>)</span><br><span class="line">print(result)  <span class="comment">#返回的result为ParseResult类型，实际上是一个元组，支持result[0]和result.scheme</span></span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, </span><br><span class="line">            path=<span class="string">'/index.html#comment'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br></pre></td></tr></table></figure></li><li><p>urlunparse()<br>实现URL的构造。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"></span><br><span class="line"><span class="comment">#data可以用其他类型，但长度必须是6</span></span><br><span class="line">data = [<span class="string">'http'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'user'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]</span><br><span class="line">print(urlunparse(data))</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">http://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></table></figure></li><li><p>urlsplit()<br>类似urlparse()，但只返回5个结果，params合并到path里。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit</span><br><span class="line"></span><br><span class="line">result = urlsplit(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">SplitResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, </span><br><span class="line">            path=<span class="string">'/index.html;user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre></td></tr></table></figure></li><li><p>urlunsplit()<br>类似urlunparse()，但只传入5个参数。</p></li><li><p>urljoin()</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">urljoin(base_url, target_url)</span><br><span class="line"></span><br><span class="line">分析base_url的scheme、netloc和path三个内容并对target_url进行补充</span><br></pre></td></tr></table></figure></li><li><p>urlencode()<br>将字典序列化为GET请求的参数。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com?'</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">http://www.baidu.com?name=germey&amp;age=22</span><br></pre></td></tr></table></figure></li><li><p>parse_qs()<br>将URL反序列化为字典。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;age=22'</span></span><br><span class="line">print(parse_qs(query))</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">&#123;<span class="string">'name'</span>: [<span class="string">'germey'</span>], <span class="string">'age'</span>: [<span class="string">'22'</span>]&#125;</span><br></pre></td></tr></table></figure></li><li><p>parse_qsl()<br>将URL转化为元组组成的列表。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[(<span class="string">'name'</span>, <span class="string">'germey'</span>), (<span class="string">'age'</span>, <span class="string">'22'</span>)]</span><br></pre></td></tr></table></figure></li><li><p>quote()<br>将内容（中文字符）转化为URL编码的格式。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">'壁纸'</span></span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd='</span> + quote(keyword)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</span><br></pre></td></tr></table></figure></li><li><p>unquote()<br>进行URL解码</p></li></ul><h4 id="分析Robots协议"><a href="#分析Robots协议" class="headerlink" title="分析Robots协议"></a>分析Robots协议</h4><ul><li><p>Robots协议<br>Robots协议也称作爬虫协议、机器人协议，全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作robot.txt的文本文件，一般放在网站的根目录下。</p></li><li><p>爬虫名称<br>常见的搜索爬虫的名称及对应的网站：<br>BaiduSpider 百度 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>Googlebot 谷歌 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a><br>360Spider 360 搜索 <a href="http://www.so.com" target="_blank" rel="noopener">www.so.com</a><br>YodaoBot 有道 <a href="http://www.youdao.com" target="_blank" rel="noopener">www.youdao.com</a><br>ia_archiver Alexa <a href="http://www.alexa.cn" target="_blank" rel="noopener">www.alexa.cn</a><br>Scooter altavista <a href="http://www.altavista.com" target="_blank" rel="noopener">www.altavista.com</a></p></li><li><p>robotparser<br>urllib.robotparser模块提供了一个RobotFileParser类，该类的一些方法如下：</p><ul><li>set_url()：用来设置robots.txt文件的链接。也可在创建RobotFileParser对象时传入链接。</li><li>read()：读取robots.txt文件并进行分析。</li><li>parse()：用来解析robots.txt文件，传人的参数是robots.txt某些行的内容，它会按照robots.txt的语法规则来分析这些内容。</li><li>can_fetch()：该方法传人两个参数，第一个是 User-agent，第二个是要抓取的URL。返回的内容是该搜索引擎是否可以抓取这个URL，结果为True 或False。</li><li>mtime()：返回的是上次抓取和分析robots.txt的时间，这对于长时间分析和抓取的搜索爬虫是有必要的，可能需要定期检查来抓取最新的robots.txt。</li><li>modified()：同样对长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析robots.txt的时间。</li></ul><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line"></span><br><span class="line">rp = RobotFileParser()</span><br><span class="line">rp.set_url(<span class="string">'http://www.jianshu.com/robots.txt'</span>)</span><br><span class="line">rp.read()</span><br><span class="line"><span class="comment">#上面两行可以用parse方法来执行读取和分析</span></span><br><span class="line"><span class="comment">#rp.parse(urlopen('http://www.jianshu.com/robots.txt').read().decode('utf-8').split('\n'))</span></span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>, <span class="string">'http://www.jianshu.com/p/b67554025d7d'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>, <span class="string">"http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections"</span>))</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用requests"><a href="#使用requests" class="headerlink" title="使用requests"></a>使用requests</h3><p>解决urllib中Cookies、登录验证、代理设置不方便的问题。<br>安装<code>pip install requests</code></p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>requests库包含get()、post()、put()、delete()、head()和options()等方法，分别对应各种方式请求网页。</p><ul><li><p>GET请求</p><ul><li>基本实例：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'germey'</span>,</span><br><span class="line"><span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=data)</span><br><span class="line">print(type(r))</span><br><span class="line">print(r.status)</span><br><span class="line"><span class="comment">#网页的返回类型实际是JSON格式的str类型，调用json()可将其转化为字典</span></span><br><span class="line">print(type(r.json()))</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">requests</span>.<span class="title">models</span>.<span class="title">Response</span>'&gt;</span></span><br><span class="line"><span class="class">200</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></table></figure></li><li>抓取网页<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: (<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) '</span></span><br><span class="line">                    <span class="string">'AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                     <span class="string">'Chrome/52.0.2743.116 Safari/537.36'</span>)</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">"https://www.zhihu.com/explore"</span>, headers=headers)</span><br><span class="line">pattern = re.compile(<span class="string">'explore-feed.*?question_link.*?&gt;(.*?)&lt;/a&gt;'</span>, re.S)</span><br><span class="line">titles = re.findall(pattern, r.text)</span><br><span class="line">print(titles)</span><br></pre></td></tr></table></figure></li><li>抓取二进制数据<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>POST请求</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'germey'</span>, <span class="string">'age'</span>: <span class="string">'22'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=data)</span><br></pre></td></tr></table></figure></li><li><p>响应</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://www.xxyr.cc'</span>)</span><br><span class="line">print(type(r.status_code))</span><br><span class="line">print(type(r.headers))</span><br><span class="line">print(type(r.cookies))</span><br><span class="line">print(type(r.url))</span><br><span class="line">print(type(r.history))</span><br><span class="line">print(type(r.text))  <span class="comment">#返回内容的字符串形式</span></span><br><span class="line">print(type(r.content)) <span class="comment">#返回内容的二进制形式</span></span><br><span class="line">print(requests.codes.ok)  <span class="comment">#内置的返回码</span></span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">requests</span>.<span class="title">structures</span>.<span class="title">CaseInsensitiveDict</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">requests</span>.<span class="title">cookies</span>.<span class="title">RequestsCookieJar</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class">200</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><ul><li><p>文件上传</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></li><li><p>Cookies</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(r.cookies)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">    print(key + <span class="string">'='</span> + value)</span><br></pre></td></tr></table></figure><p>可将Cookie字段添加到headers里实现登录：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">'https://www.zhihu.com'</span>, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>或将其作为cookie参数添加到get()方法里：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span></span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies.split(<span class="string">';'</span>):</span><br><span class="line">    key, value = cookie.split(<span class="string">'='</span>, <span class="number">1</span>)</span><br><span class="line">    jar.set(key, value)</span><br><span class="line">r = requests.get(<span class="string">'http://www.zhihu.com'</span>, cookies=jar, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></li><li><p>会话维持<br>当访问登录网站后的页面，或同一站点的不同页面时，就需要进行会话维持。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;</span><br><span class="line">    <span class="string">"number"</span>: <span class="string">"123456789"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SSL证书验证</p></li><li><p>代理设置</p></li><li><p>超时设置</p></li><li><p>身份认证</p></li><li><p>Prepared Request</p></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="抓取猫眼电影排行"><a href="#抓取猫眼电影排行" class="headerlink" title="抓取猫眼电影排行"></a>抓取猫眼电影排行</h3><h2 id="Ch-3-解析库的使用"><a href="#Ch-3-解析库的使用" class="headerlink" title="Ch 3 解析库的使用"></a>Ch 3 解析库的使用</h2><h3 id="使用XPath"><a href="#使用XPath" class="headerlink" title="使用XPath"></a>使用XPath</h3><h3 id="使用Beautiful-Soup"><a href="#使用Beautiful-Soup" class="headerlink" title="使用Beautiful Soup"></a>使用Beautiful Soup</h3><h3 id="使用pyquery"><a href="#使用pyquery" class="headerlink" title="使用pyquery"></a>使用pyquery</h3><h2 id="Ch-4-数据存储"><a href="#Ch-4-数据存储" class="headerlink" title="Ch 4 数据存储"></a>Ch 4 数据存储</h2><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><h4 id="TXT文本存储"><a href="#TXT文本存储" class="headerlink" title="TXT文本存储"></a>TXT文本存储</h4><h4 id="JSON文件存储"><a href="#JSON文件存储" class="headerlink" title="JSON文件存储"></a>JSON文件存储</h4><h4 id="CSV文件存储"><a href="#CSV文件存储" class="headerlink" title="CSV文件存储"></a>CSV文件存储</h4><h3 id="关系型数据库存储"><a href="#关系型数据库存储" class="headerlink" title="关系型数据库存储"></a>关系型数据库存储</h3><h4 id="MySQL存储"><a href="#MySQL存储" class="headerlink" title="MySQL存储"></a>MySQL存储</h4><h3 id="非关系型数据库存储"><a href="#非关系型数据库存储" class="headerlink" title="非关系型数据库存储"></a>非关系型数据库存储</h3><h4 id="MongoDB存储"><a href="#MongoDB存储" class="headerlink" title="MongoDB存储"></a>MongoDB存储</h4><h4 id="Redis存储"><a href="#Redis存储" class="headerlink" title="Redis存储"></a>Redis存储</h4><h2 id="Ch-5-Ajax数据爬取"><a href="#Ch-5-Ajax数据爬取" class="headerlink" title="Ch 5 Ajax数据爬取"></a>Ch 5 Ajax数据爬取</h2><h3 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h3><h3 id="Ajax分析方法"><a href="#Ajax分析方法" class="headerlink" title="Ajax分析方法"></a>Ajax分析方法</h3><h3 id="Ajax结果提取"><a href="#Ajax结果提取" class="headerlink" title="Ajax结果提取"></a>Ajax结果提取</h3><h3 id="分析Ajax爬取今日头条节拍美图"><a href="#分析Ajax爬取今日头条节拍美图" class="headerlink" title="分析Ajax爬取今日头条节拍美图"></a>分析Ajax爬取今日头条节拍美图</h3><h2 id="Ch-6-动态渲染页面爬取"><a href="#Ch-6-动态渲染页面爬取" class="headerlink" title="Ch 6 动态渲染页面爬取"></a>Ch 6 动态渲染页面爬取</h2><h3 id="Selenium的使用"><a href="#Selenium的使用" class="headerlink" title="Selenium的使用"></a>Selenium的使用</h3><h3 id="Splash的使用"><a href="#Splash的使用" class="headerlink" title="Splash的使用"></a>Splash的使用</h3><h3 id="Splash负载均衡配置"><a href="#Splash负载均衡配置" class="headerlink" title="Splash负载均衡配置"></a>Splash负载均衡配置</h3><h3 id="使用Selenium爬取淘宝商品"><a href="#使用Selenium爬取淘宝商品" class="headerlink" title="使用Selenium爬取淘宝商品"></a>使用Selenium爬取淘宝商品</h3><h2 id="Ch-7-验证码的识别"><a href="#Ch-7-验证码的识别" class="headerlink" title="Ch 7 验证码的识别"></a>Ch 7 验证码的识别</h2><h3 id="图形验证码识别"><a href="#图形验证码识别" class="headerlink" title="图形验证码识别"></a>图形验证码识别</h3><h3 id="滑动验证码识别"><a href="#滑动验证码识别" class="headerlink" title="滑动验证码识别"></a>滑动验证码识别</h3><h3 id="点触验证码识别"><a href="#点触验证码识别" class="headerlink" title="点触验证码识别"></a>点触验证码识别</h3><h3 id="宫格验证码识别"><a href="#宫格验证码识别" class="headerlink" title="宫格验证码识别"></a>宫格验证码识别</h3><h2 id="Ch-8-代理的使用"><a href="#Ch-8-代理的使用" class="headerlink" title="Ch 8 代理的使用"></a>Ch 8 代理的使用</h2><h3 id="代理的设置"><a href="#代理的设置" class="headerlink" title="代理的设置"></a>代理的设置</h3><h3 id="代理池的维护"><a href="#代理池的维护" class="headerlink" title="代理池的维护"></a>代理池的维护</h3><h3 id="付费代理的使用"><a href="#付费代理的使用" class="headerlink" title="付费代理的使用"></a>付费代理的使用</h3><h3 id="ADSL拨号代理"><a href="#ADSL拨号代理" class="headerlink" title="ADSL拨号代理"></a>ADSL拨号代理</h3><h3 id="使用代理爬取微信公众号文章"><a href="#使用代理爬取微信公众号文章" class="headerlink" title="使用代理爬取微信公众号文章"></a>使用代理爬取微信公众号文章</h3><h2 id="Ch-9-模拟登录"><a href="#Ch-9-模拟登录" class="headerlink" title="Ch 9 模拟登录"></a>Ch 9 模拟登录</h2><h3 id="模拟登录并爬取GitHub"><a href="#模拟登录并爬取GitHub" class="headerlink" title="模拟登录并爬取GitHub"></a>模拟登录并爬取GitHub</h3><h3 id="Cookie池的搭建"><a href="#Cookie池的搭建" class="headerlink" title="Cookie池的搭建"></a>Cookie池的搭建</h3><h2 id="Ch-10-APP的爬取"><a href="#Ch-10-APP的爬取" class="headerlink" title="Ch 10 APP的爬取"></a>Ch 10 APP的爬取</h2><h3 id="Charles的使用"><a href="#Charles的使用" class="headerlink" title="Charles的使用"></a>Charles的使用</h3><h3 id="mitmproxy的使用"><a href="#mitmproxy的使用" class="headerlink" title="mitmproxy的使用"></a>mitmproxy的使用</h3><h3 id="mitmdump爬取“得到”电子书信息"><a href="#mitmdump爬取“得到”电子书信息" class="headerlink" title="mitmdump爬取“得到”电子书信息"></a>mitmdump爬取“得到”电子书信息</h3><h3 id="APPium的基本使用"><a href="#APPium的基本使用" class="headerlink" title="APPium的基本使用"></a>APPium的基本使用</h3><h3 id="APPium爬取微信朋友圈"><a href="#APPium爬取微信朋友圈" class="headerlink" title="APPium爬取微信朋友圈"></a>APPium爬取微信朋友圈</h3><h3 id="APPium-mitmdump爬取京东商品"><a href="#APPium-mitmdump爬取京东商品" class="headerlink" title="APPium+mitmdump爬取京东商品"></a>APPium+mitmdump爬取京东商品</h3><h2 id="Ch-11-pyspider框架使用"><a href="#Ch-11-pyspider框架使用" class="headerlink" title="Ch 11 pyspider框架使用"></a>Ch 11 pyspider框架使用</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h2 id="Ch-12-Scrapy框架使用"><a href="#Ch-12-Scrapy框架使用" class="headerlink" title="Ch 12 Scrapy框架使用"></a>Ch 12 Scrapy框架使用</h2><h2 id="Ch-13-分布式爬虫"><a href="#Ch-13-分布式爬虫" class="headerlink" title="Ch 13 分布式爬虫"></a>Ch 13 分布式爬虫</h2><h2 id="Ch-14-分布式爬虫的部署"><a href="#Ch-14-分布式爬虫的部署" class="headerlink" title="Ch 14 分布式爬虫的部署"></a>Ch 14 分布式爬虫的部署</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/post/Tips/common-commands/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>包括Hexo、Django等<a id="more"></a></p><h2 id="Django常用命令"><a href="#Django常用命令" class="headerlink" title="Django常用命令"></a>Django常用命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h3 id="新建文章："><a href="#新建文章：" class="headerlink" title="新建文章："></a>新建文章：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo new page --path _posts/Hexo/hexo-commands <span class="string">"Hexo常用命令"</span></span><br></pre></td></tr></table></figure><h3 id="生成静态文件和上传："><a href="#生成静态文件和上传：" class="headerlink" title="生成静态文件和上传："></a>生成静态文件和上传：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h3 id="本地运行："><a href="#本地运行：" class="headerlink" title="本地运行："></a>本地运行：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tips</category>
      </categories>
  </entry>
  <entry>
    <title>《Python深度学习》笔记</title>
    <url>/post/DeepLearning/deep-learning-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Python深度学习》笔记<a id="more"></a><br><a href="#jump">Windows下的环境搭建</a>，<br>英文电子版<a href="https://livebook.manning.com/book/deep-learning-with-python/" target="_blank" rel="noopener">https://livebook.manning.com/book/deep-learning-with-python/</a><br>Keras中文文档：<a href="https://keras.io/zh/" target="_blank" rel="noopener">https://keras.io/zh/</a></p><h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1 基本概念"></a>Chapter 1 基本概念</h2><p>首先理清人工智能、机器学习和深度学习的概念和关系，<br>人工智能&gt;机器学习&gt;深度学习<br>深度学习是机器学习的子集，而机器学习则是人工智能的子集</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p><strong>简洁定义</strong>：将通常由人类完成的智力任务自动化。<br><strong>发展</strong>：<em>符号主义人工智能</em>（symbolic AI）→<em>机器学习</em>（machine learning）<br><strong>符号主义人工智能</strong>：编写足够多的明确规则来处理知识，用于解决定义明确的逻辑问题，如下国际象棋，但对于图像分类、语音识别等难以给出明确规则的复杂、模糊的问题将无法解决。</p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><img src="https://i.loli.net/2020/05/16/iweKFoO9k862ufD.png" alt=""><br>　　机器学习将某个任务相关的示例输入机器学习系统，系统从中找到统计结构，最终找到规则将任务自动化，其与经典程序设计不同如上图。<br>　　机器学习的三个要素如下：<br>　　（1）输入数据点。<br>　　（2）预期输出的示例。<br>　　（3）衡量算法效果好坏的方法。<br>　　机器学习和深度学习的核心问题在于<strong>有意义地变换数据</strong> ，即学习输入数据的有用<strong>表示</strong>（表征数据或将数据编码），如彩色图像可以编码为RGB（红-绿-蓝）格式或HSV（色相-饱和度-明度）格式，在应对不同任务时，不同的表示方式将会产生很大的差异，所以机器学习模型的目的就是为输入数据寻找合适的表示。<br>　　<strong>定义</strong>：在预先定义好的可能性空间中（假设空间），利用反馈信号的指引来寻找输入数据的有用表示。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>　　深度学习强调从连续的<strong>层</strong>中进行学习，这些层对应越来越有意义的<strong>表示</strong>。<br>　　模型包含的层数成为模型的<strong>深度</strong>，这些分层总是通过<strong>神经网络</strong>（neural network）模型学习得到。<br>　　<strong>定义</strong>：学习数据表示的多级方法，相当于多级信息蒸馏操作。<br>　　<strong>深度学习工作原理</strong>：<br>　　神经网络每层对输入数据所做的具体操作保存在该层的<strong>权重</strong>中，其本质是一串数字，每层实现的变换由其权重来<strong>参数化</strong>，<strong>学习</strong>即为每层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。<br>　　输入网络预测值和真实目标值通过<strong>损失函数</strong>计算一个距离值，利用这个距离值作为反馈信号通过<strong>优化器</strong>实现<strong>反向传播算法</strong>来对权重值进行微调，以降低当前示例的损失值，随着示例的增多，损失值逐渐降低，输出值与目标值尽可能接近。如下图。<br><img src="https://i.loli.net/2020/05/16/zomZXBxty67UqEN.png" alt="深度学习工作原理图"></p><h2 id="Chapter-2-神经网络的数学基础"><a href="#Chapter-2-神经网络的数学基础" class="headerlink" title="Chapter 2 神经网络的数学基础"></a>Chapter 2 神经网络的数学基础</h2><h3 id="张量（tensor）"><a href="#张量（tensor）" class="headerlink" title="张量（tensor）"></a>张量（tensor）</h3><p>定义：又叫多维Numpy数组，作为机器学习的基本数据结构，是一个数据容器，包含的数据几乎总是数值数据，如矩阵是二维张量，张量是矩阵向任意维度的推广[ 张量的<strong>维度</strong>（dimension）通常叫做<strong>轴</strong>（axis）]</p><h3 id="标量（scalar）"><a href="#标量（scalar）" class="headerlink" title="标量（scalar）"></a>标量（scalar）</h3><p>定义：仅包含一个数字的张量，又叫标量张量、零维张量、0D张量。在Numpy数组中，一个float32或float64的数字就是一个标量。<br>标量张量有0个轴（ndim == 0），轴的个数又叫<strong>阶</strong>（rank）。如下代码查看一个标量张量的轴的个数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="number">12</span>)</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a>向量（vector）</h3><p>定义：数字组成的数组，又叫一维张量或1D张量，只有一个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>该向量有5个元素，为5D向量，有1个轴，沿着轴有5个维度。而5D张量有5个轴，沿着某个轴可能有任意个维度。</p><h3 id="矩阵（matrix）"><a href="#矩阵（matrix）" class="headerlink" title="矩阵（matrix）"></a>矩阵（matrix）</h3><p>定义：多个向量组成的数组，又叫二维张量或2D张量，有2个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>第一个轴上的元素叫行，[12, 3, 22, 121, 4]是x的第一行，第二个轴上的元素叫列，[12, 12, 12]是x的第一列。</p><h3 id="3D张量与更高维张量"><a href="#3D张量与更高维张量" class="headerlink" title="3D张量与更高维张量"></a>3D张量与更高维张量</h3><p>定义：多个矩阵组成的数组，有3个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]],</span><br><span class="line">            [[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>深度学习一般处理0D到4D张量，处理视频数据可能会遇到5D张量。</p><h3 id="张量的关键属性"><a href="#张量的关键属性" class="headerlink" title="张量的关键属性"></a>张量的关键属性</h3><ul><li><strong>轴的个数</strong>（阶、维度）：Python库中为ndim。</li><li><strong>形状</strong>：张量沿某个轴的维度大小（元素个数），如前面的3D张量的形状为（3， 3， 5）。</li><li><strong>数据类型</strong>：张量所包含数据的类型，Python库中为dtype，如float32、float64、unit8等，极少数情况有字符（char）张量，Numpy等大多数库都不存在字符串张量，因为<span style="border-bottom:2px solid red">张量存储在预先分配的连续内存段中</span>，而字符串长度可变，无法用这种方式存储。</li></ul><p>代码示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line">print(train_images.shape)</span><br><span class="line">print(train_images.ndim);</span><br><span class="line">print(train_images.dtype);</span><br><span class="line"></span><br><span class="line"><span class="comment">#该3D张量中的第四个数字</span></span><br><span class="line">digit = train_images[<span class="number">4</span>]</span><br><span class="line">plt.imshow(digit, cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">uint8</span><br><span class="line"></span><br><span class="line"><span class="comment">#由上可见，train_images是一个由8位整数组成的3维张量，即60000个28*28整数矩阵组成的数组，每个矩阵是一张灰度图像。</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/18/Yf6u1H.png" alt="该3D张量中的第四个数字"></p><h3 id="张量切片"><a href="#张量切片" class="headerlink" title="张量切片"></a>张量切片</h3><p>类似于Python的切片操作，示例:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择第10~100个数字（不包括100），将其放在形为（90，28，28）的数组中</span></span><br><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>]     <span class="comment">#[10:100, 0:28, 0:28]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可沿着张量轴在任意两个索引间进行选择，也可使用负索引</span></span><br><span class="line">my_slice = train_images[, <span class="number">14</span>:, <span class="number">14</span>:]       <span class="comment">#右下角14*14</span></span><br><span class="line">my_slice = train_images[, <span class="number">7</span>:<span class="number">-7</span>, <span class="number">7</span>:<span class="number">-7</span>]       <span class="comment">#中心14*14</span></span><br></pre></td></tr></table></figure><h3 id="数据批量"><a href="#数据批量" class="headerlink" title="数据批量"></a>数据批量</h3><p>　　所有数据张量的第一个轴称为<strong>样本轴</strong>或<strong>0轴</strong>（samples axis）。<br>　　深度学习模型会将数据集拆分成小批量，形如<code>batch = train_images[:128]</code>。<br>　　对于这种批量张量，第一个轴为<strong>批量轴</strong>（batch axis）或<strong>批量维度</strong>（batch dimension）。</p><h3 id="现实世界中的数据张量"><a href="#现实世界中的数据张量" class="headerlink" title="现实世界中的数据张量"></a>现实世界中的数据张量</h3><ul><li><strong>向量数据</strong>：2D 张量，形状为 (samples, features) 。</li><li><strong>时间序列数据或序列数据</strong>：3D 张量，形状为 (samples, timesteps, features) 。</li><li><strong>图像</strong>：4D张量，形状为 (samples, height, width, channels) 或 (samples, channels,<br>height, width) 。</li><li><strong>视频</strong>：5D张量，形状为 (samples, frames, height, width, channels) 或 (samples,<br>frames, channels, height, width)</li></ul><h4 id="向量数据"><a href="#向量数据" class="headerlink" title="向量数据"></a>向量数据</h4><p>　　常见的数据。每个数据点被编码为一个向量，因此一个数据批量就被编码为 2D 张量（即向量组成的数组），其中第一个轴是<strong>样本轴</strong>，第二个轴是<strong>特征轴</strong> <span style="border-bottom:2px solid red">(samples, features)</span>。如<br>　　人口统计数据集，其中包括每个人的年龄、邮编和收入。每个人可以表示为包含 3 个值的向量，而整个数据集包含 100 000 个人，因此可以存储在形状为 (100000, 3) 的 2D张量中。</p><h4 id="时间序列数据或序列数据"><a href="#时间序列数据或序列数据" class="headerlink" title="时间序列数据或序列数据"></a>时间序列数据或序列数据</h4><p>　　当时间对于数据很重要时，将数据存储在带有时间轴的3D张量中。每个样本被编码为一个向量序列（即2D张量），因此一个数据批量就被编码为一个3D张量 <span style="border-bottom:2px solid red">(samples, timesteps, features)</span>。如图：<br><img src="https://s1.ax1x.com/2020/05/18/YhClMF.png" alt="">　　依据惯例，时间轴始终是第二个轴。<br>　　例如股票价格数据集：<br>　　要构建一个股票价格数据集：每一分钟，我们将股票的当前价格，前一分钟的最高价格和前一分钟的最低价格保存下来，那么就被编码为一个3D向量。整个交易日就编码为一个有390个3D向量的2D张量（390，3）。250天的数据就编码为3D张量（250，390，3）。</p><h4 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h4><p>　　图像通常具有三个维度：<strong>高度</strong>、<strong>宽度</strong>和<strong>颜色深度</strong>。虽然灰度图像（比如 MNIST 数字图像）只有一个颜色通道，因此可以保存在 2D 张量中，但按照惯例，图像张量始终都是 3D 张量，灰度图像的彩色通道只有一维。因此，如果图像大小为 256×256，那么 128 张灰度图像组成的批量可以保存在一个形状为 (128, 256, 256, 1) 的张量中，而 128 张彩色图像组成的批量则可以保存在一个形状为 (128, 256, 256, 3) 的张量中。<br><img src="https://s1.ax1x.com/2020/05/18/YhipjS.png" alt="">　　图像张量的形状有两种约定：通道在后（channels-last）的约定（在 TensorFlow 中使用）和通道在前（channels-first）的约定（在 Theano 中使用）。<br>　　Google 的 TensorFlow 机器学习框架将颜色深度轴放在最后：<span style="border-bottom:2px solid red"> (samples, height, width, color_depth)</span>,例如(128, 256, 256, 3) 。<br>　　Theano将图像深度轴放在批量轴之后：<span style="border-bottom:2px solid red">(samples, color_depth, height, width)</span>，例如(128, 3, 256, 256)。<br>　　Keras 框架同时支持这两种格式。</p><h4 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h4><p>　　视频数据是现实生活中需要用到 5D 张量的少数数据类型之一。视频可以看作一系列帧，每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_depth) 的 3D 张量中，因此一系列帧可以保存在一个形状为 (frames, height, width,color_depth) 的 4D 张量中，而不同视频组成的批量则可以保存在一个 5D 张量中，其形状为<span style="border-bottom:2px solid red">(samples, frames, height, width, color_depth) </span>。<br>　　例如，一个以每秒 4 帧采样的 60 秒 YouTube 视频片段，视频尺寸为 144×256，这个视频共有 240 帧。4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3)的张量中。总共有 106 168 320 个值！如果张量的数据类型（ dtype ）是 float32 ，每个值都是32 位，那么这个张量共有 405MB。现实生活中遇到的视频要小得多，因为它们不以float32 格式存储，而且通常被大大压缩，比如 MPEG 格式。</p><h3 id="张量运算——神经网络的“齿轮”"><a href="#张量运算——神经网络的“齿轮”" class="headerlink" title="张量运算——神经网络的“齿轮”"></a>张量运算——神经网络的“齿轮”</h3><p>　　本节和下一节主要是高等数学和线性代数在神经网络中的运用，下面只简单提一下这些数学知识在神经网络中的相关概念。</p><h4 id="逐元素运算（element-wise）"><a href="#逐元素运算（element-wise）" class="headerlink" title="逐元素运算（element-wise）"></a>逐元素运算（element-wise）</h4><p>　　运算独立地应用于张两种地每个元素，适合大规模并行实现。如：</p><ul><li>relu运算：relu(x) == max(x, 0)</li><li>四则运算（前提是运算对象形状相同）</li></ul><h4 id="广播（broadcast）"><a href="#广播（broadcast）" class="headerlink" title="广播（broadcast）"></a>广播（broadcast）</h4><p>　　两个形状不同地张量相加，较小地张量会被广播，以匹配较大的张量。如：<br>　　x形状为（32，10），y形状为（10，），则x+y会为y添加空的第一个轴（广播轴）→（1，10），再沿新轴重复32次→（32，10）。<br>　　但以上过程不会在运算中实际发生，只是想象的思维模型。</p><h4 id="张量点积（tensor-product）"><a href="#张量点积（tensor-product）" class="headerlink" title="张量点积（tensor product）"></a>张量点积（tensor product）</h4><p>　　类似于线性代数中矩阵的乘法，Keras和Numpy中使用<code>numpy.dot(x, y)</code>实现。<br>　　形如(a, b, c, d).(d, e)-&gt;(a, b, c, e)，<img src="https://s1.ax1x.com/2020/05/19/Y4DYO1.jpg" alt=""></p><h4 id="张量变形（tensor-reshaping）"><a href="#张量变形（tensor-reshaping）" class="headerlink" title="张量变形（tensor reshaping）"></a>张量变形（tensor reshaping）</h4><p>　　改变张量的行列，但元素总数不变。<code>x.reshape((2,6))</code><br>　　行列互换称为<strong>转置</strong>（transposition）<code>numpy.transpose(x)</code></p><h4 id="张量运算的几何解释"><a href="#张量运算的几何解释" class="headerlink" title="张量运算的几何解释"></a>张量运算的几何解释</h4><p>　　类似高数中的向量变换以及更高维的延申。</p><h3 id="基于梯度的优化——神经网络的“引擎”"><a href="#基于梯度的优化——神经网络的“引擎”" class="headerlink" title="基于梯度的优化——神经网络的“引擎”"></a>基于梯度的优化——神经网络的“引擎”</h3><p>　　对每个神经层用下述方法对输入数据进行变换。<br>　　<code>output = relu(dot(W, input) + b)</code><br>　　在这个表达式中，W 和b 都是张量，均为该层的属性。它们被称为该层的<strong>权重</strong>（weight）或<strong>可训练参数</strong>（trainable parameter），分别对应kernel 和bias 属性。这些权重包含网络从观察训练数据中学到的信息。<br>　　一开始，这些权重矩阵取较小的随机值，这一步叫作<strong>随机初始化</strong>（random initialization）。当然，W 和b 都是随机的，relu(dot(W, input) + b) 肯定不会得到任何有用的表示。虽然得到的表示是没有意义的，但这是一个起点。下一步则是根据反馈信号逐渐调节这些权重。这个逐渐调节的过程叫作<strong>训练</strong>，也就是机器学习中的<strong>学习</strong>。<br>　　上述过程发生在一个<strong>训练循环</strong>（training loop）内，其具体过程如下。必要时一直重复这些步骤。</p><ul><li>抽取训练样本x 和对应目标y 组成的数据批量。</li><li>在x 上运行网络［这一步叫作前向传播（forward pass）］，得到预测值y_pred。</li><li>计算网络在这批数据上的损失，用于衡量y_pred 和y 之间的距离。</li><li>更新网络的所有权重，使网络在这批数据上的损失略微下降。</li></ul><p>　　最终得到的网络在训练数据上的损失非常小，即预测值y_pred 和预期目标y 之间的距离非常小。<br><span style="border-bottom:2px solid red">详情参见：<a href="https://www.ituring.com.cn/book/tupubarticle/23177" target="_blank" rel="noopener">https://www.ituring.com.cn/book/tupubarticle/23177</a></span></p><h2 id="Chapter-3-神经网络入门"><a href="#Chapter-3-神经网络入门" class="headerlink" title="Chapter 3 神经网络入门"></a>Chapter 3 神经网络入门</h2><p>　　这里再次引用第一章的深度学习工作原理图。<br><img src="https://i.loli.net/2020/05/16/zomZXBxty67UqEN.png" alt="深度学习工作原理图"></p><h3 id="层：深度学习的基础组件"><a href="#层：深度学习的基础组件" class="headerlink" title="层：深度学习的基础组件"></a>层：深度学习的基础组件</h3><p>　　<strong>层</strong>是神经网络的基本数据结构，层的状态即层的<strong>权重</strong>，权重是利用<strong>随机梯度下降</strong>学到的一个或多个张量。以下是几种不同的层及其应用场景。</p><ul><li><strong>密集连接层</strong>（densely connected layer）：又叫<strong>全连接层</strong>（fully connected layer）和<strong>密集层</strong>（dense layer），用于处理保存简单向量的2D张量，形状为 (samples, features)，对应Keras的Dense类。</li><li><strong>循环层</strong>（recurrent layer）：用于处理保存序列数据的3D张量，形状为 (samples, timesteps, features)，对应Keras的LSTM层。</li><li><strong>二维卷积层</strong>：用于处理保存图像数据的4D张量，形状为 (samples, height, width, channels)，对应Keras的Conv2D。</li></ul><h3 id="模型：层构成的网络"><a href="#模型：层构成的网络" class="headerlink" title="模型：层构成的网络"></a>模型：层构成的网络</h3><p>　　构建深度学习模型就是将相互兼容的多个层拼接在一起，以建立有用的数据变换流程。深度学习模型是层构成的有向无环图。<br>　　这里的层兼容性（layer compatibility）指每一层只接受特定形状的输入张量并返回特定形状的输出张量。<br>　　一些常见的网络拓扑结构如下:<br>　　（1）线性网络<br>　　（2）双分支（two-branch）网络<br>　　（3）多头（multihead）网络<br>　　（4）Inception模块</p><h3 id="损失函数与优化器：配置学习过程的关键"><a href="#损失函数与优化器：配置学习过程的关键" class="headerlink" title="损失函数与优化器：配置学习过程的关键"></a>损失函数与优化器：配置学习过程的关键</h3><ul><li>损失函数(目标函数)：训练过程中将其最小化，能够衡量当前任务是否已成功完成。</li><li>优化器：决定如何根据损失函数对网络进行更新，执行随机梯度下降（SGD： stochastic gradient descent）的某个变体。</li></ul><p>　　注意：具有多个输出的神经网络可能有多个损失函数，但梯度下降过程必须基于单个标量损失值。因此要将所有损失函数取平均变为一个标量值。</p><h3 id="Keras开发流程"><a href="#Keras开发流程" class="headerlink" title="Keras开发流程"></a>Keras开发流程</h3><ul><li>定义训练数据：输入张量和目标张量。</li><li>定义层组成的网络（或模型），将输入映射到目标。</li><li>配置学习过程：选择损失函数，优化器和需要监控的指标。</li><li>调用模型的fit()方法迭代训练数据。</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models,layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Sequential类定义模型</span></span><br><span class="line"><span class="comment"># model = models.Sequential()</span></span><br><span class="line"><span class="comment"># model.add(layers.Dense(32, activation='relu', input_shape=(784,)))</span></span><br><span class="line"><span class="comment"># model.add(layers.Dense(10, activation='softmax'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数式API定义模型</span></span><br><span class="line">input_tensor = layers.Input(shape=(<span class="number">784</span>,))</span><br><span class="line">x = layers.Dense(<span class="number">32</span>, activation=<span class="string">'relu'</span>)(input_tensor)</span><br><span class="line">output_tensor = layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)(x)</span><br><span class="line">model = models.Model(inputs=input_tensor, outputs=output_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">model.compile(optimizer=optimizers.RMSprop(lr=<span class="number">0.001</span>),       <span class="comment">#优化器</span></span><br><span class="line">              loss=<span class="string">'mse'</span>,                                   <span class="comment">#损失函数</span></span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])                         <span class="comment">#评估函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代训练数据</span></span><br><span class="line">model.fit(input_tensor, target_tensor, batch_size=<span class="number">128</span>, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="电影评论分类：二分类问题"><a href="#电影评论分类：二分类问题" class="headerlink" title="电影评论分类：二分类问题"></a>电影评论分类：二分类问题</h3><p>注意：</p><ul><li>隐藏单元越多（更高维的表示空间），网络越能学习更复杂的表示，但这会使网络的计算代价更大，并且可能导致学习到不好的模式（这种模式可以提高训练数据的性能，但不能提高测试数据的性能）。</li><li>sigmoid函数将任意值压缩到[0, 1]区间内。</li><li>relu（rectified linear unit，整流线性单元）函数，将所有负值归零。</li><li>激活函数：也叫非线性，为了得到更丰富的假设空间，充分利用多层表示的优势。</li><li>对于二分类这种最后输出概率值的问题，损失函数最优解为binary_crossentropy（二元交叉熵）。</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分类问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 1 加载数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#train_data和train_labels为评论组成的列表，而每条评论为单词索引组成的列表</span></span><br><span class="line"><span class="comment">#test_data和test_labels为0、1组成的列表，代表负面和正面</span></span><br><span class="line"><span class="comment">#num_words=10000表示仅保留训练数据中前10000个最常出现的单词</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = imdb.load_data(num_words=<span class="number">10000</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># word_index = imdb.get_word_index()                                   #将单词映射为整数索引的字典</span></span><br><span class="line"><span class="comment"># reverse_word_index = dict(                                           #键值颠倒，整数索引映射为单词</span></span><br><span class="line"><span class="comment">#     [(value, key) for (key, value) in word_index.items()])</span></span><br><span class="line"><span class="comment"># decoded_review = ' '.join(                                           #评论解码，索引减去3，</span></span><br><span class="line"><span class="comment">#     [reverse_word_index.get(i - 3, '?') for i in train_data[0]])     #因为0、1、2为保留索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 2 处理数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对列表进行one-hot编码，转化为0、1组成的向量。</span></span><br><span class="line"><span class="comment">#将整数序列编码为二进制矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span><span class="params">(sequences, dimension=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    results = np.zeros((len(sequences), dimension))                    <span class="comment">#创建一个零矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> enumerate(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)                              <span class="comment">#训练数据向量化</span></span><br><span class="line">x_test = vectorize_sequences(test_data)                                <span class="comment">#测试数据向量化</span></span><br><span class="line">y_train = np.asarray(train_labels).astype(<span class="string">'float32'</span>)                   <span class="comment">#训练标签向量化</span></span><br><span class="line">y_test = np.asarray(test_labels).astype(<span class="string">'float32'</span>)                     <span class="comment">#测试标签向量化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#留出10000个样本作验证集</span></span><br><span class="line">x_val = x_train[:<span class="number">10000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">10000</span>:]</span><br><span class="line">y_val = y_train[:<span class="number">10000</span>]</span><br><span class="line">partial_y_train = y_train[<span class="number">10000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 3 定义模型/构建网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#采用3层全连接层，16为隐藏单元个数，即维度，activation为激活函数</span></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 4 编译模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置优化器，损失函数，评估函数</span></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 5 训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用512个样本组成的小批量，对所有样本进行20次迭代，</span></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘图</span></span><br><span class="line"></span><br><span class="line">history_dict = history.history</span><br><span class="line">loss_values = history_dict[<span class="string">'loss'</span>]</span><br><span class="line">val_loss_values = history_dict[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">epochs = range(<span class="number">1</span>, len(loss_values) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss_values, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">plt.plot(epochs, val_loss_values, <span class="string">'b'</span>, label=<span class="string">'Validation loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">acc_values = history_dict[<span class="string">'acc'</span>]</span><br><span class="line">val_acc_values = history_dict[<span class="string">'val_acc'</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc_values, <span class="string">'bo'</span>, label=<span class="string">'Training acc'</span>)</span><br><span class="line">plt.plot(epochs, val_acc_values, <span class="string">'b'</span>, label=<span class="string">'Validation acc'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/20/YTstRf.png" alt="训练损失和验证损失"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/20/YTsgzT.png" alt="训练精度和验证精度"></th></tr></thead></table><p>　　由上图可见，每轮训练损失在降低，训练精度在上升，符合预期，但验证损失和验证精度并非如此，模型在训练数据上表现更好，但不一定在从未见过的数据上表现更好，这种现象成为<strong>过拟合</strong>（overfit），详见Chapter 4。<br>　　下面是一种简单的训练方法：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">results = model.evaluate(x_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">[<span class="number">0.29506705965518953</span>, <span class="number">0.884119987487793</span>]</span><br></pre></td></tr></table></figure><p>　　用训练好的网络进行预测。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.predict(x_test)</span><br><span class="line">array([[ <span class="number">0.98006207</span>]</span><br><span class="line">       [ <span class="number">0.99758697</span>]</span><br><span class="line">       [ <span class="number">0.99975556</span>]</span><br><span class="line">       ...,</span><br><span class="line">       [ <span class="number">0.82167041</span>]</span><br><span class="line">       [ <span class="number">0.02885115</span>]</span><br><span class="line">       [ <span class="number">0.65371346</span>]], dtype=float32)</span><br></pre></td></tr></table></figure><h3 id="新闻分类：多分类问题"><a href="#新闻分类：多分类问题" class="headerlink" title="新闻分类：多分类问题"></a>新闻分类：多分类问题</h3><ul><li>单标签、多分类（single-label，multiclass classification）：每个数据点只能划分到一个类别。</li><li>多标签、多分类（multilabel，multiclass classification）：每个数据点能划分到多个类别。</li></ul><p>注意：</p><ul><li>编码数据中将标签向量化的两种方法：转化为整数张量或进行one-hot编码。注意两种方法所使用的<strong>损失函数</strong>可能会有所差别。<ul><li>通过分类编码（也称为one-hot编码），使用categorical_crossentropy作为损失函数对标签进行编码。</li><li>将标签编码为整数，使用sparse_categorical_crossentropy作为损失函数对标签进行编码。</li></ul></li><li>如果要在N个类别中对数据点进行分类，则网络最后一层应为大小为N的Dense层。</li><li>在单标签，多类分类问题中，网络应以softmax激活结束，这样可以输出在N个类别上的概率分布。</li><li><strong>分类交叉熵</strong>几乎总是针对多分类问题使用的损失函数，它使网络输出的概率分布与目标的真实分布之间的距离最小化。</li><li>如果需要将数据划分为大量类别，则应避免使用较小的中间层，而在网络中导致信息瓶颈（永久地丢失信息）。</li></ul><p>本例使用路透社数据集。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多分类问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> reuters</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = reuters.load_data(</span><br><span class="line">    num_words=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span><span class="params">(sequences, dimension=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    results = np.zeros((len(sequences), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> enumerate(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)</span><br><span class="line">x_test = vectorize_sequences(test_data)</span><br><span class="line"><span class="comment">#分类编码</span></span><br><span class="line">one_hot_train_labels = to_categorical(train_labels)</span><br><span class="line">one_hot_test_labels = to_categorical(test_labels)</span><br><span class="line"><span class="comment">#将标签转化为整数张量</span></span><br><span class="line"><span class="comment"># y_train = np.array(train_labels)</span></span><br><span class="line"><span class="comment"># y_test = np.array(test_labels)</span></span><br><span class="line"></span><br><span class="line">x_val = x_train[:<span class="number">1000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">1000</span>:]</span><br><span class="line">y_val = one_hot_train_labels[:<span class="number">1000</span>]</span><br><span class="line">partial_y_train = one_hot_train_labels[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,      <span class="comment">#分类交叉熵</span></span><br><span class="line">              metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line">loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">epochs = range(<span class="number">1</span>, len(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">'b'</span>, label=<span class="string">'Validation loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">'acc'</span>]</span><br><span class="line">val_acc = history.history[<span class="string">'val_acc'</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">'bo'</span>, label=<span class="string">'Training acc'</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">'b'</span>, label=<span class="string">'Validation acc'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/21/YbAsqs.png" alt="训练损失和验证损失"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/21/YbA6Zn.png" alt="训练精度和验证精度"></th></tr></thead></table><p>由上图可见，网络在训练9轮后开始过拟合，重新进行训练并进行评估。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">9</span>,</span><br><span class="line">          batch_size=<span class="number">512</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br><span class="line">results = model.evaluate(x_test, one_hot_test_labels)</span><br></pre></td></tr></table></figure><p>在新数据上进行评估。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">predictions = model.predict(x_test)</span><br></pre></td></tr></table></figure><h3 id="预测房价：回归问题"><a href="#预测房价：回归问题" class="headerlink" title="预测房价：回归问题"></a>预测房价：回归问题</h3><p>前面两种分类问题目标是预测输入数据点所对应的单一离散的标签，而回归问题预测一个连续值而不是离散的标签，如根据气象数据预测明天的气温。<br>本例采用波士顿房价数据集，每个样本有多个数据特征，如犯罪率、每个住宅的平均房间数等。目标是房屋价格的中位数，单位千美元。<br>注意：</p><ul><li>本例的每个特征几乎都有不同的取值范围，应当对每个特征值做标准化，如减去特征平均值再除以标准差。</li><li>回归问题常用的损失函数为均方误差（MSE，mean squared error），预测值与目标值之差的平方。</li><li>回归问题使用的评估指标（metrics）为平均绝对误差（MAE，mean absolute error）预测值与目标值之差的绝对值。</li><li>若可用数据很少，使用K折验证可以可靠地评估模型。</li><li>若可用的训练数据很少，最好使用隐藏层较少（1到2个）的网络，避免严重的过拟合</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回归问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> boston_housing</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">(train_data, train_targets), (test_data, test_targets) = boston_housing.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment">#特征值标准化</span></span><br><span class="line">mean = train_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">train_data -= mean</span><br><span class="line">std = train_data.std(axis=<span class="number">0</span>)</span><br><span class="line">train_data /= std</span><br><span class="line"></span><br><span class="line">mean1 = test_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">test_data -= mean1</span><br><span class="line">std1 = test_data.std(axis=<span class="number">0</span>)</span><br><span class="line">test_data /= std1</span><br><span class="line"></span><br><span class="line"><span class="comment">#因为要将同一个模型多次实例化，故用一个函数来构建模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = models.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>,</span><br><span class="line">                           input_shape=(train_data.shape[<span class="number">1</span>],)))</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))                                      <span class="comment">#线性层，标量回归</span></span><br><span class="line">    model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'mse'</span>, metrics=[<span class="string">'mae'</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">#K折验证</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">num_val_samples = len(train_data) // k</span><br><span class="line"><span class="comment"># num_epochs = 100</span></span><br><span class="line"><span class="comment"># all_scores = []</span></span><br><span class="line">num_epochs = <span class="number">500</span></span><br><span class="line">all_mae_histories = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    print(<span class="string">'processing fold #'</span>, i)</span><br><span class="line">    <span class="comment">#准备验证数据：第k个分区的数据</span></span><br><span class="line">    val_data = train_data[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    val_targets = train_targets[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#准备训练数据：其他所有分区的数据</span></span><br><span class="line">    partial_train_data = np.concatenate(</span><br><span class="line">        [train_data[:i * num_val_samples],</span><br><span class="line">         train_data[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    partial_train_targets = np.concatenate(</span><br><span class="line">        [train_targets[:i * num_val_samples],</span><br><span class="line">         train_targets[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    model = build_model()</span><br><span class="line">    <span class="comment"># model.fit(partial_train_data, partial_train_targets,</span></span><br><span class="line">    <span class="comment">#           epochs=num_epochs, batch_size=1, verbose=0)</span></span><br><span class="line">    <span class="comment"># val_mse, val_mae = model.evaluate(val_data, val_targets, verbose=0)</span></span><br><span class="line">    <span class="comment"># all_scores.append(val_mae)</span></span><br><span class="line">    <span class="comment"># mean_scores = np.mean(all_scores)</span></span><br><span class="line"></span><br><span class="line">    history = model.fit(partial_train_data, partial_train_targets,</span><br><span class="line">                        validation_data=(val_data, val_targets),</span><br><span class="line">                        epochs=num_epochs, batch_size=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    print(history.history.keys())</span><br><span class="line">    mae_history = history.history[<span class="string">'val_mae'</span>]</span><br><span class="line">    all_mae_histories.append(mae_history)</span><br><span class="line"></span><br><span class="line">average_mae_history = [</span><br><span class="line">    np.mean([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> all_mae_histories]) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_epochs)]</span><br><span class="line"></span><br><span class="line">plt.plot(range(<span class="number">1</span>, len(average_mae_history) + <span class="number">1</span>), average_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Validation MAE'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#将每个数据点替换为前面数据点的指数移动平均值，以得到光滑曲线。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth_curve</span><span class="params">(points, factor=<span class="number">0.9</span>)</span>:</span></span><br><span class="line">  smoothed_points = []</span><br><span class="line">  <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    <span class="keyword">if</span> smoothed_points:</span><br><span class="line">      previous = smoothed_points[<span class="number">-1</span>]</span><br><span class="line">      smoothed_points.append(previous * factor + point * (<span class="number">1</span> - factor))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      smoothed_points.append(point)</span><br><span class="line">  <span class="keyword">return</span> smoothed_points</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除前10个数据点</span></span><br><span class="line">smooth_mae_history = smooth_curve(average_mae_history[<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.plot(range(<span class="number">1</span>, len(smooth_mae_history) + <span class="number">1</span>), smooth_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Validation MAE'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/21/YqbxS0.png" alt="每轮的验证MAE"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/21/YqqSyT.png" alt="重绘后的每轮的验证MAE"></th></tr></thead></table><p>由上图可知，验证MAE在80轮后不再显著降低，之后开始过拟合，调整参数在训练数据上训练参数。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model = build_model()</span><br><span class="line">model.fit(train_data, train_targets,</span><br><span class="line">          epochs=<span class="number">80</span>, batch_size=<span class="number">16</span>, verbose=<span class="number">0</span>)</span><br><span class="line">test_mse_score, test_mae_score = model.evaluate(test_data, test_targets)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_mae_score</span><br><span class="line"><span class="number">2.6759588718414307</span></span><br></pre></td></tr></table></figure><h2 id="Chapter-4-机器学习基础"><a href="#Chapter-4-机器学习基础" class="headerlink" title="Chapter 4 机器学习基础"></a>Chapter 4 机器学习基础</h2><h3 id="机器学习的四个分支"><a href="#机器学习的四个分支" class="headerlink" title="机器学习的四个分支"></a>机器学习的四个分支</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>最常见的机器学习类型，给定一组样本（通常由人工标注），学习将输入数据映射到已知目标。主要包括分类和回归问题，如光学字符识别、语音识别、图像分类以及语言翻译。另外包括一些主要的变体如下</p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><h3 id="机器学习通用工作流程"><a href="#机器学习通用工作流程" class="headerlink" title="机器学习通用工作流程"></a>机器学习通用工作流程</h3><h4 id="定义问题，收集数据集"><a href="#定义问题，收集数据集" class="headerlink" title="定义问题，收集数据集"></a>定义问题，收集数据集</h4><h4 id="选择衡量成功的指标"><a href="#选择衡量成功的指标" class="headerlink" title="选择衡量成功的指标"></a>选择衡量成功的指标</h4><h4 id="确定评估方法"><a href="#确定评估方法" class="headerlink" title="确定评估方法"></a>确定评估方法</h4><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><h4 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h4><h4 id="模型正则化与调节超参数"><a href="#模型正则化与调节超参数" class="headerlink" title="模型正则化与调节超参数"></a>模型正则化与调节超参数</h4><h2 id="Chapter-5-卷积神经网络"><a href="#Chapter-5-卷积神经网络" class="headerlink" title="Chapter 5 卷积神经网络"></a>Chapter 5 卷积神经网络</h2><p>一个简单的卷积神经网络示例。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#卷积神经网络</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line">train_images = train_images.reshape((<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">train_images = train_images.astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">test_images = test_images.reshape((<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">test_images = test_images.astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">train_labels = to_categorical(train_labels)</span><br><span class="line">test_labels = to_categorical(test_labels)</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># model.summary()</span></span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">5</span>, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">test_loss, test_acc = model.evaluate(test_images, test_labels)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_acc</span><br><span class="line"><span class="number">0.9919000267982483</span></span><br></pre></td></tr></table></figure><h2 id="Windows下的环境搭建"><a href="#Windows下的环境搭建" class="headerlink" title="Windows下的环境搭建"></a><span id="jump">Windows下的环境搭建</span></h2><p>由于懒得装双系统，虚拟机先不说配置不够，搭起来感觉坑很多，遂直接在Windows系统下搭建。</p><h3 id="安装CUDA和cuDNN"><a href="#安装CUDA和cuDNN" class="headerlink" title="安装CUDA和cuDNN"></a>安装CUDA和cuDNN</h3><blockquote><p>CUDA（Compute Unified Device Architecture）：NVIDIA用于自家GPU的并行计算框架，本质是一个工具包（ToolKit）。</p></blockquote><blockquote><p>cuDNN（CUDA Deep Neural Network library）：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。用GPU训练模型，cuDNN不是必须的，但是一般会采用这个加速库。</p></blockquote><ol><li><p>查看显卡支持的CUDA版本<br>NVIDIA控制面板&gt;帮助&gt;系统信息&gt;组件，如图支持10.2版本<br><img src="https://s1.ax1x.com/2020/05/17/Y20vQK.png" alt=""></p></li><li><p>安装对应版本的CUDA</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></p></blockquote><blockquote><p>安装完成后打开cmd，输入命令：<code>nvcc -V</code>，如图</p><img src="https://s1.ax1x.com/2020/05/17/Y2yrUe.png" style="margin-left:0" alt=""></blockquote></li><li><p>编译CUDA（暂时未编译）</p></li><li><p>安装cuDNN</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p></blockquote><blockquote><p>这里需要注册账户才可以下载，可以看到支持的对应CUDA版本<br>将解压后的文件复制到CUDA安装路径中，这里是默认路径<br><code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1</code></p></blockquote></li></ol><h3 id="安装TensorFlow和Keras"><a href="#安装TensorFlow和Keras" class="headerlink" title="安装TensorFlow和Keras"></a>安装TensorFlow和Keras</h3><p>由于本机已经安装过Python3.7，管理多版本Python有点麻烦，故直接<strong>使用pip安装</strong>而不是Anaconda<br>在用pip安装前，<strong>确保pypi源更换为国内镜像</strong>，否则速度超级慢</p><blockquote><p>方法为在C盘的user目录下新建一个pip文件夹，如：C:\Users\xx\pip，在pip文件夹内新建一个pip.ini文件，内容如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>常用国内镜像：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;   # 清华大学</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;     # 阿里云</span><br><span class="line">https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;             # 豆瓣</span><br><span class="line">https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;    # 中国科学技术大学</span><br><span class="line">https:&#x2F;&#x2F;pypi.hustunique.com&#x2F;                # 华中科技大学</span><br></pre></td></tr></table></figure><p></p></blockquote><ol><li>安装Tensorflow<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>安装完成后在python环境中运行<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tf</span><span class="selector-class">.test</span><span class="selector-class">.is_gpu_available</span>()</span><br></pre></td></tr></table></figure>可以查看到GPU信息即安装成功。<br>Tensorflow作为Keras的后端,TensorFlow与CUDA和cuDNN各版本对应如下：<br><img src="https://s1.ax1x.com/2020/05/17/Y24DV1.png" alt=""></li><li>安装Keras<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> keras</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装其他组件"><a href="#安装其他组件" class="headerlink" title="安装其他组件"></a>安装其他组件</h3><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonic Coding</title>
    <url>/post/Python/effective-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Effective Python》学习笔记<a id="more"></a></p><h2 id="程序风格"><a href="#程序风格" class="headerlink" title="程序风格"></a><center>程序风格</center></h2><h3 id="遵循PEP8风格指南"><a href="#遵循PEP8风格指南" class="headerlink" title="遵循PEP8风格指南"></a>遵循PEP8风格指南</h3><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">《Python Enhancement Proposal #8》</a>，简称PEP8，是针对Python代码格式编订的风格指南。</p><h3 id="bytes、str与unicode区别"><a href="#bytes、str与unicode区别" class="headerlink" title="bytes、str与unicode区别"></a>bytes、str与unicode区别</h3><h4 id="首先区分Python3与Python2的两种表示字符序列的类型"><a href="#首先区分Python3与Python2的两种表示字符序列的类型" class="headerlink" title="首先区分Python3与Python2的两种表示字符序列的类型"></a>首先区分Python3与Python2的两种表示字符序列的类型</h4><ul><li>Python3，bytes与str，前者的实例包含原始的8位值，即原始的字节，包含8个二进制位；后者的实例包含Unicode字符</li><li>Python2，str与unicode，前者的实例包含原始的8位值；后者的实例包含Unicode字符</li></ul><h4 id="二进制数据与Unicode字符相互转换"><a href="#二进制数据与Unicode字符相互转换" class="headerlink" title="二进制数据与Unicode字符相互转换"></a>二进制数据与Unicode字符相互转换</h4><p>常见编码方式为UTF-8<br>Unicode字符 → 二进制数据，encode()方法<br>二进制数据 → Unicode字符，decode()方法</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>Python程序中，编码和解码操作放在程序外围，核心部分使用Unicode字符类型</li><li>在只处理7位ASCII时，Python2的str和unicode类型的实例可以等价，而Python3中bytes与str的实例绝对不等价</li><li>Python3中，使用内置open()函数获取文件句柄，该句柄默认采用UTF-8格式来操作文件，问题在于Python3给open()函数添加了名为encoding的新参数，其默认值为’utf-8’，要求必须传入包含Unicode字符的str实例，而不接受包含二进制数据的bytes实例<br>总结为必须使用二进制写入模式open(path, ‘wb’)来开启待操作文件</li></ul><h3 id="用辅助函数取代复杂表达式"><a href="#用辅助函数取代复杂表达式" class="headerlink" title="用辅助函数取代复杂表达式"></a>用辅助函数取代复杂表达式</h3><p>如，从字典中查询并返回得到的第一个整数值:<br><code>red = my_values.get(&#39;red&#39;, [&#39;&#39;])[0] or 0</code><br>未查询到或值为0为空统一返回0，该表达式不易理解，若要频繁使用，将其总结为辅助函数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_int</span><span class="params">(values, key, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">    found =values.get(key, [<span class="string">''</span>])</span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        found = int(found[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = default</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">red = get_first_int(my_values, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><p>somelist[start:end]，其中start所指元素涵盖在切割后的范围内，end所指元素不包括在切割结果之中。例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start从0开始，end倒数从-1开始</span></span><br><span class="line">a[:]                                    <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line">a[:<span class="number">3</span>]                                   <span class="comment">#[1,2,3]</span></span><br><span class="line">a[<span class="number">2</span>:]                                   <span class="comment">#[3,4,5,6]</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]                                  <span class="comment">#[3,4,5]</span></span><br><span class="line">a[<span class="number">-3</span>:<span class="number">-1</span>]                                <span class="comment">#[4,5]</span></span><br></pre></td></tr></table></figure><p>切割列表时，start和end越界不会出问题，利用该特性可以限定输入序列的最大长度。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">first_nine_items</span> = a[:<span class="number">9</span>]</span><br><span class="line"><span class="attr">last_nine_items</span> = a[<span class="number">9</span>:]</span><br></pre></td></tr></table></figure><p>切片后不影响原列表，对list赋值，若使用切片操作，会把原列表处在相关范围内的值替换为新值，即便长度不同也可以替换。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">1</span>]                          <span class="comment">#[1,2,1,1,6]</span></span><br><span class="line">a[:] = [<span class="number">1</span>,<span class="number">1</span>]                            <span class="comment">#[1,1]</span></span><br></pre></td></tr></table></figure><h4 id="步进式切割"><a href="#步进式切割" class="headerlink" title="步进式切割"></a>步进式切割</h4><p>somelist[start:end:stride]</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">odds = a[::<span class="number">2</span>]</span><br><span class="line">evens = a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">b = <span class="string">b'abc'</span></span><br><span class="line">reverse = b[::<span class="number">-1</span>]                       <span class="comment">#负值为反向步进</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>负步长只对字节串和ASCII字符有效，对已编码成UTF-8字节串的Unicode字符无效</li><li>尽量使用stride为正数，且不带start和end索引</li><li>同一切片操作内，不要同时指定start、end和stride，考虑将其拆解为一条步进切割，一条范围切割</li></ul><h3 id="列表与迭代"><a href="#列表与迭代" class="headerlink" title="列表与迭代"></a>列表与迭代</h3><h4 id="用列表推导取代map和filter"><a href="#用列表推导取代map和filter" class="headerlink" title="用列表推导取代map和filter"></a>用列表推导取代map和filter</h4><p><strong>列表推导</strong>(list comprehension)，根据一份列表来制作另外一份。<br><strong>字典</strong>(dict)与<strong>集</strong>(set)也支持推导表达式</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用map，创建lambda函数，结合filter</span></span><br><span class="line">squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br><span class="line">even_squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用列表推导</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="列表推导内含的表达式不宜超过两个"><a href="#列表推导内含的表达式不宜超过两个" class="headerlink" title="列表推导内含的表达式不宜超过两个"></a>列表推导内含的表达式不宜超过两个</h4><p>列表推导支持多重循环</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵简化为一维列表</span></span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]                  <span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]          <span class="comment">#[[1, 4, 9], [16, 25, 36], [49, 64, 81]]</span></span><br></pre></td></tr></table></figure><p>每一级循环也支持多重条件</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处在同一循环级别中的多项条件， 彼此之间默认形成and表达式</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#从矩阵中取出本身能被3整除，且其所在行所有元素之和大于等于10的元素</span></span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] </span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h4 id="用生成器表达式改写数据量较大的列表推导"><a href="#用生成器表达式改写数据量较大的列表推导" class="headerlink" title="用生成器表达式改写数据量较大的列表推导"></a>用生成器表达式改写数据量较大的列表推导</h4><p>首先，列表推导的缺点是：<br>在推导过程中，对于输入序列中的每个值，可能都要创建一个仅含一个元素的新列表，若输入数据量较大，会消耗大量内存。<br>如，读取一份文件并返回每行的字符数，采用列表推导</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file)]</span><br></pre></td></tr></table></figure><p><strong>生成器表达式</strong>(generator expression)：<br>对列表推导和生成器的一种<strong>泛化</strong>(generalization)，生成器表达式运行时，不会呈现整个输出序列，而是估值为<strong>迭代器</strong>(iterator)，该迭代器每次根据生成器表达式产生一项数据。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器表达式，立刻返回一个迭代器</span></span><br><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file))</span><br><span class="line">next(it)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器表达式可以互相组合</span></span><br><span class="line">roots = ((x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure><h4 id="用enumerate取代range"><a href="#用enumerate取代range" class="headerlink" title="用enumerate取代range"></a>用enumerate取代range</h4><p>enumerate可以把各种迭代器包装为生成器，可以在遍历迭代器时获得每个元素的索引，在同时需要下标和值的时候使用。如range</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_num)):</span><br><span class="line">    num = list_num[i]</span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i+<span class="number">1</span>, num))</span><br></pre></td></tr></table></figure><p>使用enumerate</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerator(list_num, <span class="number">1</span>):                  <span class="comment">#起始下标指定为1</span></span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i, num))</span><br></pre></td></tr></table></figure><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><p>Python3中的zip函数，能将两个及以上的迭代器封装为生成器，在遍历过程中逐次产生元组。<br>Python2中，直接产生所有元组，并一次性返回整份列表<br>若提供的迭代器长度不等，zip会提前自动终止</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'adad'</span>, <span class="string">'bob'</span>, <span class="string">'alen'</span>]</span><br><span class="line">letters = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, letter <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    print(name+str(letter))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><center>函数</center></h2><p>函数的问题主要体现在<strong>参数</strong>、<strong>作用域</strong>、<strong>返回值</strong>三个方面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="在闭包里使用外围作用域中的变量"><a href="#在闭包里使用外围作用域中的变量" class="headerlink" title="在闭包里使用外围作用域中的变量"></a>在闭包里使用外围作用域中的变量</h4><p>注意：</p><ul><li>Python支持闭包（closure）：闭包是定义在某个作用域中的函数，可以引用那个作用域中的变量。</li><li>Python的函数时一级对象，可以直接引用函数、将函数赋给变量或者将函数作为参数传递。</li></ul><p>例如，对一份数字列表进行排序，要求出现的特定数字在其他数字排序之前。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sort_priority(numbers, group)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>稍作修改为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">found = sort_priority2(numbers, group)</span><br><span class="line">print(found)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>found的输出结果与预期的True不符，这里我们首先要了解，在表达式中引用变量，Python解释器遵循以下顺序遍历各作用域：</p><ul><li>当前函数作用域</li><li>任何外围作用域（如包含当前函数的其他函数）</li><li>包含当前代码的那个模块的作用域（全局作用域，global scope）</li><li>内置作用域（包含str及len等函数的那个作用域）</li><li>未定义过名称相符变量，抛出NameError异常</li></ul><p>sort_priority2函数中将found赋值为True是在闭包函数helper内进行的，实则是在闭包函数的作用域中定义了一个found变量并赋值为True，与其外围函数sort_priority2作用域中定义的found不同，最后返回的是sort_priority2中赋值为False的found变量。<br>因此，我们需要获取闭包内的数据，可使用nonlocal语句，不支持Python2</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found                  <span class="comment">#声明该found为闭包外围作用域中的found</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>而实际开发中，nonlocal容易遭到滥用，且副作用难以追踪，难以理解，不适用于较长较复杂的函数。有以下两个解决办法：</p><ol><li>将相关状态封装为辅助类<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">            self.found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br><span class="line">print(sorter.found)</span><br></pre></td></tr></table></figure></li><li>用Python的作用域规则，Python2可用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = [<span class="literal">False</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="尽量用异常表示特殊情况，而非返回None"><a href="#尽量用异常表示特殊情况，而非返回None" class="headerlink" title="尽量用异常表示特殊情况，而非返回None"></a>尽量用异常表示特殊情况，而非返回None</h4>例如，两数相除的情况。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:                              <span class="comment">#这种情况没有问题</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:                                  <span class="comment">#错误情况</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure>当分子为0时not result结果为True，结果应为0，却显示Invalid inputs。用异常来表示这种情况：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Result is %.1f'</span> % result)</span><br></pre></td></tr></table></figure><h4 id="用生成器改写直接返回列表的函数"><a href="#用生成器改写直接返回列表的函数" class="headerlink" title="用生成器改写直接返回列表的函数"></a>用生成器改写直接返回列表的函数</h4>若函数产生一系列结果，最简单的方法是返回一个包含所有结果的列表，此方法主要有两个缺点：</li></ol><ul><li>代码拥挤，不清晰</li><li>返回前将所有结果放在列表里，若输入量非常大，会导致内存耗尽</li></ul><p>例如以下函数返回字符串中每个单词首字母的位置。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            result.append(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = index_words(text)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>用生成器改写：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">yield</span> index+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = list(index_words(text))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python自动化控制鼠标和键盘</title>
    <url>/post/Python/auto-gui-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文档：<a href="https://pyautogui.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/</a><a id="more"></a></p><h2 id="安装pyautogui模块"><a href="#安装pyautogui模块" class="headerlink" title="安装pyautogui模块"></a>安装pyautogui模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure><h2 id="鼠标操作模拟"><a href="#鼠标操作模拟" class="headerlink" title="鼠标操作模拟"></a>鼠标操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">width, height = pyautogui.size()            <span class="comment">#返回屏幕宽高像素数的元组</span></span><br><span class="line">pyautogui.position()                        <span class="comment">#返回鼠标当前位置元组</span></span><br><span class="line"></span><br><span class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置移动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.moveRel(<span class="number">100</span>, <span class="number">-1</span>, duration=<span class="number">1</span>)      <span class="comment">#相对位置移动。参数为右,左,时间可选秒数</span></span><br><span class="line"></span><br><span class="line">pyautogui.click(<span class="number">100</span>, <span class="number">200</span>, button=<span class="string">'middle'</span>)    <span class="comment">#完整的单击.默认鼠标左键单击当前位置</span></span><br><span class="line">pyautogui.mouseDown(button=left)            <span class="comment">#按下鼠标按键</span></span><br><span class="line">pyautogui.mouseUp(<span class="number">100</span>, <span class="number">200</span>)                 <span class="comment">#松开鼠标按键</span></span><br><span class="line">pyautogui.doubleClick()                     <span class="comment">#双击鼠标左键</span></span><br><span class="line">pyautogui.middleClick()                     <span class="comment">#单击鼠标中键</span></span><br><span class="line"></span><br><span class="line">pyautogui.dragTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置拖动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.dragRel(<span class="number">100</span>, <span class="number">-1</span>, button=<span class="string">'middle'</span>) <span class="comment">#相对位置拖动。参数为右,左,button可选默认左键</span></span><br><span class="line"></span><br><span class="line">pyautogui.scroll(<span class="number">-200</span>)                      <span class="comment">#鼠标滚轮上下滚动</span></span><br></pre></td></tr></table></figure><h2 id="处理屏幕"><a href="#处理屏幕" class="headerlink" title="处理屏幕"></a>处理屏幕</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">im = pyautogui.screenshot()                 <span class="comment">#返回包含屏幕快照的Image对象</span></span><br><span class="line">im.getpixel((x,y))                          <span class="comment">#返回坐标处像素颜色的RGB元组</span></span><br><span class="line">pyautogui.pixelMatchesColor(x, y, (R, G, B))<span class="comment">#比较(x,y)处与RGB的颜色是否相同</span></span><br><span class="line"></span><br><span class="line">pyautogui.locateOnScreen(<span class="string">'screenshot.png'</span>)  <span class="comment">#参数或为region=(0,0, 300, 400)</span></span><br><span class="line"><span class="comment">#返回screenshot.png匹配当前屏幕成功的图像左边的x坐标，顶边的y坐标，宽度和高度元组</span></span><br><span class="line">pyautogui.center((<span class="number">0</span>,<span class="number">0</span>, <span class="number">300</span>, <span class="number">400</span>))           <span class="comment">#返回中心坐标</span></span><br><span class="line">pyautogui.click((<span class="number">150</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h2 id="键盘操作模拟"><a href="#键盘操作模拟" class="headerlink" title="键盘操作模拟"></a>键盘操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">pyautogui.typewrite(<span class="string">'test'</span>,<span class="number">0.25</span>)            <span class="comment">#发送单个字符表示的虚拟按键,间隔0.25秒</span></span><br><span class="line">pyautogui.typewrite([<span class="string">'a'</span>, <span class="string">'b'</span>])               <span class="comment">#键名作为参数</span></span><br><span class="line"></span><br><span class="line">pyautogui.keyDown(<span class="string">'ctrl'</span>)</span><br><span class="line">pyautogui.press(<span class="string">'c'</span>)</span><br><span class="line">pyautogui.keyUp(<span class="string">'ctrl'</span>)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><p>键名:<a href="https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys</a></p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Auto-GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python处理Excel，CSV和JSON</title>
    <url>/post/Python/excel-csv-json-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Python处理Excel，CSV文件和JSON文件<a id="more"></a></p><h2 id="python处理excel"><a href="#python处理excel" class="headerlink" title="python处理excel"></a>python处理excel</h2><p>文档：<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://openpyxl.readthedocs.io/en/stable/</a></p><h3 id="安装openpyxl模块"><a href="#安装openpyxl模块" class="headerlink" title="安装openpyxl模块"></a>安装openpyxl模块</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> openpyxl</span><br></pre></td></tr></table></figure><h3 id="读取excel"><a href="#读取excel" class="headerlink" title="读取excel"></a>读取excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)     <span class="comment">#返回Workbook对象</span></span><br><span class="line">wb.sheetnames                                           <span class="comment">#返回所有工作表名称的字符串列表</span></span><br><span class="line"></span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]                                     <span class="comment">#wb.get_sheet_by_name('Sheet')</span></span><br><span class="line">sheet1 = wb.active</span><br><span class="line"></span><br><span class="line">sheet[<span class="string">'A'</span>]                                              <span class="comment">#返回第一列</span></span><br><span class="line">sheet[<span class="string">'A1'</span>].value                                       <span class="comment">#.row .column .coordinate(r+c)</span></span><br><span class="line">sheet.cell(row=<span class="number">1</span>, column=<span class="number">1</span>).value</span><br><span class="line">sheet.max_row                                           <span class="comment">#返回一个整数.max_column</span></span><br><span class="line"></span><br><span class="line">openpyxl.cell.column_index_from_string()                <span class="comment">#列字母转换为数字，A→1</span></span><br><span class="line">openpyxl.cell.get_column_letter()                       <span class="comment">#数字转换为列字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切片，遍历</span></span><br><span class="line"><span class="keyword">for</span> rowObj <span class="keyword">in</span> sheet[<span class="string">'A1'</span>:<span class="string">'D14'</span>]:                        <span class="comment">#每个元组代表一行，按行遍历整个区域</span></span><br><span class="line">    <span class="keyword">for</span> cellObj <span class="keyword">in</span> rowObj:                              <span class="comment">#遍历行中的每个单元格</span></span><br><span class="line">        print(cellObj.coordinate, cellObj.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cellObj <span class="keyword">in</span> list(sheet.rows)[<span class="number">0</span>]:                     <span class="comment">#按行按列遍历,或者 sheet[1] | sheet['A']</span></span><br><span class="line">    print(cellObj.value)</span><br></pre></td></tr></table></figure><h3 id="写入excel"><a href="#写入excel" class="headerlink" title="写入excel"></a>写入excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.Workbook()                                <span class="comment">#新建一个空的Workbook对象</span></span><br><span class="line">sheet = wb.active</span><br><span class="line">sheet.title = <span class="string">'test'</span></span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'test'</span>                                    <span class="comment">#将值写入单元格</span></span><br><span class="line"></span><br><span class="line">wb.create_sheet(index=<span class="number">0</span>, title=<span class="string">'ttest'</span>)                 <span class="comment">#新建一个工作表，返回Worksheet对象</span></span><br><span class="line">wb.remove(wb[<span class="string">'Sheet'</span>])                                  <span class="comment">#接受一个Worksheet对象作为其参数</span></span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test.xlsx'</span>)                         <span class="comment">#保存变更，不同名或不同位置会创建副本</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="更新excel表"><a href="#更新excel表" class="headerlink" title="更新excel表"></a>更新excel表</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">update_data = &#123;<span class="string">'apple'</span>:<span class="number">5</span>,</span><br><span class="line">               <span class="string">'lemon'</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="string">'orange'</span>:<span class="number">2</span>&#125;                              <span class="comment">#待更新数据保存在字典中</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)</span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]</span><br><span class="line"><span class="keyword">for</span> rowNum <span class="keyword">in</span> range(<span class="number">2</span>, sheet.max_row+<span class="number">1</span>):</span><br><span class="line">    updatedName = sheet.cell(row=rowNum, column=<span class="number">1</span>).value</span><br><span class="line">    <span class="keyword">if</span> updatedName <span class="keyword">in</span> update_data:</span><br><span class="line">        sheet.cell(row=rowNum, column=<span class="number">2</span>).value = update_data[updatedName]</span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test_updated.xlsx'</span>)</span><br></pre></td></tr></table></figure><h4 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font</span><br><span class="line">fontObj = Font(name=<span class="string">'Calibri'</span>, size=<span class="number">12</span>, bold=true, italic=true)</span><br><span class="line">sheet[<span class="string">'A1'</span>].font = fontObj</span><br></pre></td></tr></table></figure><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="行高列宽"><a href="#行高列宽" class="headerlink" title="行高列宽"></a>行高列宽</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="合并拆分冻结"><a href="#合并拆分冻结" class="headerlink" title="合并拆分冻结"></a>合并拆分冻结</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.merge_cells(<span class="string">'A1:D3'</span>)</span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'merged'</span>                                    <span class="comment">#合并后单元格的值</span></span><br><span class="line"></span><br><span class="line">sheet.unmerge_cells(<span class="string">'A1:A2'</span>)</span><br><span class="line"></span><br><span class="line">sheet.freeze_panes = <span class="string">'A2'</span>                                 <span class="comment">#冻结左上部分</span></span><br></pre></td></tr></table></figure><h2 id="python处理CSV文件"><a href="#python处理CSV文件" class="headerlink" title="python处理CSV文件"></a>python处理CSV文件</h2><h3 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h3><p>csv全称’Comma-Separated Values‘，每行对应电子表格中的一行，单元格之间用逗号分隔。</p><ul><li>值没有类型，全为字符串</li><li>无多个工作表</li><li>不能嵌入图像或图表</li><li>无字体大小和颜色设置</li><li>无法操作单元格，宽高合并等</li></ul><h3 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>)                               <span class="comment">#返回一个File对象</span></span><br><span class="line">fileReader = csv.reader(openFile)                         <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileData = list(fileReader)                               <span class="comment">#fileData[0][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> fileReader:</span><br><span class="line">    print(<span class="string">'row'</span>+str(fileReader.line_num)+str(row))        <span class="comment">#对于大型CSV文件，避免将文件一次性装入内存</span></span><br></pre></td></tr></table></figure><h3 id="Write对象"><a href="#Write对象" class="headerlink" title="Write对象"></a>Write对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>)              <span class="comment">#返回一个File对象</span></span><br><span class="line">fileWrite = csv.writer(openFile)                          <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileWrite.writerow([<span class="number">1</span>, <span class="string">'a,b'</span>, <span class="number">2</span>, <span class="string">'b'</span>])</span><br><span class="line">openfile.close()</span><br><span class="line"></span><br><span class="line">fileWrite = csv.writer(openFile, delimiter=<span class="string">'\t'</span>, lineterminator=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="comment">#delimiter指定分隔符 lineterminator指定行终止符，默认\n</span></span><br></pre></td></tr></table></figure><h2 id="python处理JSON文件"><a href="#python处理JSON文件" class="headerlink" title="python处理JSON文件"></a>python处理JSON文件</h2><p>JSON文件，全称JavaScript Object Notation，是JavaScript程序编写数据结构的原生方式，<br>JSON不能表示Pyton特有的对象，可以存储：字符串、整型、浮点型、布尔型、列表、字典和NoneType。</p><h3 id="loads"><a href="#loads" class="headerlink" title="loads()"></a>loads()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">jsonString = <span class="string">'&#123;"name":"asher", "isCat":true, "num":1&#125;'</span></span><br><span class="line">jsonData = json.loads(jsonString)                         <span class="comment">#返回一个Python字典</span></span><br></pre></td></tr></table></figure><h3 id="dumps"><a href="#dumps" class="headerlink" title="dumps()"></a>dumps()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">pythonData = <span class="string">'&#123;'</span>name<span class="string">':'</span>ashe<span class="string">r', '</span>isCat<span class="string">':True, '</span>num<span class="string">':1&#125;'</span></span><br><span class="line">jsonString = json.dumps(json)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Excel</tag>
        <tag>CSV</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式复习</title>
    <url>/post/tech/regex-review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式复习<a id="more"></a></p><h2 id="常用方法-参数"><a href="#常用方法-参数" class="headerlink" title="常用方法,参数"></a>常用方法,参数</h2><h3 id="group-and-findall"><a href="#group-and-findall" class="headerlink" title="group() and findall()"></a>group() and findall()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexDemo = re.compile(<span class="string">r'(\d)-(\d)'</span>) <span class="comment">#返回Regex对象, </span></span><br><span class="line">                                     <span class="comment">#r为原始字符串\不转义, </span></span><br><span class="line">                                     <span class="comment">#匹配括号须转义\(</span></span><br><span class="line">demo = regexDemo.search(<span class="string">''</span>) <span class="comment">#返回Match对象,仅包含第一次出现的文本</span></span><br><span class="line">demo1 = regexDemo.findall(<span class="string">''</span>) <span class="comment">#无分组返回一个字符串列表，有分组返回一个包含元组的列表，</span></span><br><span class="line">                              <span class="comment">#每一个元组对应一个字符串</span></span><br><span class="line">demo.group(<span class="number">0</span>) <span class="comment">#0 all but one, 1 first group, .groups() all</span></span><br></pre></td></tr></table></figure><h3 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">regexDemo</span><span class="selector-class">.sub</span>(<span class="string">'sub'</span>,<span class="string">'subed'</span>) <span class="selector-id">#sub</span>替换<span class="selector-tag">subed</span>里匹配的字符串</span><br></pre></td></tr></table></figure><h3 id="re-DOTALL"><a href="#re-DOTALL" class="headerlink" title="re.DOTALL"></a>re.DOTALL</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.DOTALL) <span class="comment">#可以匹配换行符</span></span><br></pre></td></tr></table></figure><h3 id="re-IGNORECASE-I"><a href="#re-IGNORECASE-I" class="headerlink" title="re.IGNORECASE/I"></a>re.IGNORECASE/I</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.I) <span class="comment">#不区分大小写</span></span><br></pre></td></tr></table></figure><h3 id="re-VERBOSE"><a href="#re-VERBOSE" class="headerlink" title="re.VERBOSE"></a>re.VERBOSE</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'''</span></span><br><span class="line"><span class="string">            .*  #test</span></span><br><span class="line"><span class="string">            \d+ #test1</span></span><br><span class="line"><span class="string">            '''</span>, re.VERBOSE) <span class="comment">#忽略regex中的空白符和注释 组合参数用 |</span></span><br></pre></td></tr></table></figure><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><h3><a href="#" class="headerlink" title="|"></a>|</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'a | b'</span>) <span class="comment">#匹配a或者b，同时出现匹配前者</span></span><br><span class="line">re.compile(<span class="string">r'a(aple | nchor)'</span>) <span class="comment">#匹配同一前缀</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)?man'</span>) <span class="comment">#匹配?前的分组wo零次或一次</span></span><br><span class="line">re.compile(<span class="string">r'bat(wo&#123;,5&#125;?)man'</span>) <span class="comment">#后加?表示非贪心匹配,最少0次</span></span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="*"></a>*</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配*前的分组wo零次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="+"></a>+</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配+前的分组wo一次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title="{}"></a>{}</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)&#123;,5&#125;man'</span>) <span class="comment">#匹配&#123;&#125;前的分组wo指定次数(范围), 例中为0到5次 默认贪心匹配</span></span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title="^,$"></a>^,$</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[^bat]'</span>) <span class="comment">#匹配不包含^后的任意字符,如batman匹配mn</span></span><br><span class="line">re.compile(<span class="string">r'^\d+$'</span>) <span class="comment">#匹配从开始到结束都是数字的字符串</span></span><br></pre></td></tr></table></figure><h2 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h2><p>自定义</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[0-9a-z]'</span>) <span class="comment">#[]内不需要转义</span></span><br></pre></td></tr></table></figure><h3 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.at'</span>) <span class="comment">#匹配除换行外的任意一个字符，如cat，bat</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><tbody><tr><td>\d 0-9的任何数字</td><td align="center">\D 除0-9外的任何字符</td></tr><tr><td>\w 任何字母、数字和下划线</td><td align="center">\W 类比</td></tr><tr><td>\s 空格、制表符或换行符</td><td align="center">\S类比</td></tr></tbody></table></div><h2 id="常用Regex"><a href="#常用Regex" class="headerlink" title="常用Regex"></a>常用Regex</h2><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">emailRegex</span> = re.compile(r<span class="string">'''(</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9._%+-]+</span></span><br><span class="line"><span class="string">    @</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9.-]+</span></span><br><span class="line"><span class="string">    \.[a-zA-Z]&#123;2,4&#125;</span></span><br><span class="line"><span class="string">    )'''</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Re-从零开始的Python学习</title>
    <url>/post/Python/Python-basis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python基础</p><a id="more"></a><p>学习Python之前，最好熟悉一下Python的语言和风格规范<br><a href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html" target="_blank" rel="noopener">https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html</a><br>原项目：<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">https://github.com/google/styleguide</a></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>指数:<code>2**3=8</code><br>取整:<code>22/8=2</code> <code>22/8=2.75</code><br>表达式=操作符+值（可归约为一个值）<code>！=</code>语句<br>布尔操作符:and,or,not</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整型(int),<br>浮点型(float),<br>字符串(str) ,<br><code>&#39;a&#39;+&#39;b&#39;=&#39;ab&#39;</code><br><code>&#39;a&#39;*3=&#39;aaa&#39;</code><br>布尔(Boolean),</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><code>spam = input() //返回字符串类型</code><br><code>len(&#39;&#39;) //返回整型</code><br><code>str(),int(),float() //只能进行一次类型转换，如int(&#39;0.1&#39;)不正确 int(0.1)=0</code></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line"><span class="built_in">os</span>.getcwd()                         #当前工作目录</span><br><span class="line"><span class="built_in">os</span>.chdir(<span class="string">'C:\\users'</span>)               #更改路径</span><br><span class="line"><span class="built_in">os</span>.makedirs(<span class="string">'C:\\users\\test'</span>)      #创建目录</span><br><span class="line"><span class="built_in">os</span>.listdir(<span class="string">''</span>)                      #返回路径中包含的所有文件及文件夹的字符串列表</span><br><span class="line"></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'usr'</span>,<span class="string">'bin'</span>,<span class="string">'spam'</span>)    #usr\bin\spam</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'C:\\users'</span>,<span class="string">'a.txt'</span>)   #C:\users\a.txt</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.abspath(<span class="string">''</span>)                 #返回参数的绝对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isabs(<span class="string">''</span>)                   #参数为绝对路径返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.relpath(<span class="built_in">path</span>, start)        #返回从start路径到<span class="built_in">path</span>的相对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.dirname(<span class="string">''</span>) </span><br><span class="line">+ <span class="built_in">os</span>.<span class="built_in">path</span>.basename(<span class="string">''</span>)              #<span class="string">'C:\\users'</span>+<span class="string">'test.exe'</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.split(<span class="string">''</span>)                   #返回包含dirname和basename的字符串元组</span><br><span class="line"><span class="string">''</span>.split(<span class="built_in">os</span>.<span class="built_in">path</span>.sep)               #返回一个包含路径中各文件夹名称的字符串列表</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.getsize(<span class="string">''</span>)                 #返回文件的字节数</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.exists(<span class="string">''</span>)                  #文件或文件夹存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isfile(<span class="string">''</span>)                  #文件存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isdir(<span class="string">''</span>)                   #文件夹存在，返回True</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">file1</span> = open(<span class="string">''</span>，<span class="string">'w'</span>)               <span class="comment">#返回一个File对象，w写模式，a添加模式，r读模式</span></span><br><span class="line"><span class="attr">fileContent</span> = file1.read()</span><br><span class="line"><span class="attr">fileContent</span> = file1readlines()</span><br></pre></td></tr></table></figure><h3 id="文件复制删除"><a href="#文件复制删除" class="headerlink" title="文件复制删除"></a>文件复制删除</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import shutil,<span class="built_in">os</span></span><br><span class="line">shutil.copy(source, destination)    #复制单个文件，destination为文件名则复制后改名，下同</span><br><span class="line">shutil.copytree(source, destination)#复制整个文件夹及其包含的文件和文件夹</span><br><span class="line">shutil.move(source, destination)    #移动单个文件，同名会复写</span><br><span class="line"><span class="built_in">os</span>.unlink(<span class="built_in">path</span>)                     #永久删除<span class="built_in">path</span>处的文件</span><br><span class="line"><span class="built_in">os</span>.rmdir(<span class="built_in">path</span>)                      #永久删除<span class="built_in">path</span>出的文件夹，必须为空</span><br><span class="line">shutil.rmtree(<span class="built_in">path</span>)                 #永久删除<span class="built_in">path</span>处的文件夹及其包含的文件及文件夹，可用send2trash</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">rename</span>(oldname,newname)          #用<span class="built_in">os</span>模块中的<span class="built_in">rename</span>方法对文件改名</span><br></pre></td></tr></table></figure><h3 id="变量保存"><a href="#变量保存" class="headerlink" title="变量保存"></a>变量保存</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import shelve, pprint</span><br><span class="line">shelfFile = shelve.<span class="built_in">open</span>(<span class="string">''</span>)         <span class="comment">#用shelve模块保存变量</span></span><br><span class="line"><span class="built_in">value</span> = [<span class="string">''</span>,<span class="string">''</span>]</span><br><span class="line">shelfFile[<span class="string">'keys'</span>] = <span class="built_in">value</span>           <span class="comment">#将value列表保存在shelfFile中，关联keys键值</span></span><br><span class="line"><span class="comment">#pprint.pformat(value)              #将value列表转换为字符串写入文件</span></span><br><span class="line"><span class="comment">#shelfFile.write('')                </span></span><br><span class="line">shelfFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><h3 id="文件夹遍历"><a href="#文件夹遍历" class="headerlink" title="文件夹遍历"></a>文件夹遍历</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">os</span>.walk(path)                       <span class="comment">#返回path的当前文件夹名称的字符串，foldername</span></span><br><span class="line">                                    <span class="comment">#当前文件夹子文件夹字符串列表，subfoldernames</span></span><br><span class="line">                                    <span class="comment">#当前文件夹中的文件的字符串列表,filename</span></span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h3><p>异常发生时finally块的代码必定执行，可用于异常发生时执行清理工作，如确保程序能可靠的关闭文件句柄。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">handle = open(file)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = handle.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    handle.close()</span><br></pre></td></tr></table></figure><h3 id="else块"><a href="#else块" class="headerlink" title="else块"></a>else块</h3><p>try块没有发生异常，就执行else块的代码。如从字符串中加载JSON数据，返回字典中某个键对应的值。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_json_key</span><span class="params">(data, key)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_dict = json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> KeyError <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result_dict[key]</span><br></pre></td></tr></table></figure><h3 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test = <span class="string">'ok'</span></span><br><span class="line"><span class="keyword">assert</span> test == <span class="string">'ok'</span>, <span class="string">'The test need to be ok'</span>           <span class="comment">#解决赋值出错的定位问题</span></span><br></pre></td></tr></table></figure><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging                                          <span class="comment">#等级：DEBUG &lt;INFO &lt;WARNING &lt;ERROR &lt;CRITICAL</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">''</span>,level=logging.DEBUG, format=<span class="string">' %(asctime)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">logging.debug(<span class="string">'debug'</span>)</span><br><span class="line">logging.info(<span class="string">'info'</span>)</span><br><span class="line">logging.disable(logging.CRITICAL)                       <span class="comment">#禁用CRITICAL及以下等级的所有消息</span></span><br></pre></td></tr></table></figure><h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><h3 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h3><p>返回自Unix纪元，即协调世界时间（UTC）：1970年1月1日0点 以来的秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#简单测试程序执行时间</span></span><br><span class="line">startTime = time.time()</span><br><span class="line">function()</span><br><span class="line">endTime = time.time()</span><br></pre></td></tr></table></figure><h3 id="time-sleep"><a href="#time-sleep" class="headerlink" title="time.sleep()"></a>time.sleep()</h3><p>参数为秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#for循环中sleep，按下CTRL+C可以停止并抛出KeyboardInterrupt异常</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.125</span>, <span class="number">2</span>)                                         <span class="comment">#四舍五入至两位小数，不填则到整数</span></span><br></pre></td></tr></table></figure><h3 id="datetime-datetime"><a href="#datetime-datetime" class="headerlink" title="datetime.datetime()"></a>datetime.datetime()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.year&gt;dt.microsecond                                  <span class="comment">#datetime对象支持四则和比较操作符</span></span><br><span class="line">datetime.datetime.fromtimestamp(time.time())</span><br></pre></td></tr></table></figure><h3 id="datetime-timedelta"><a href="#datetime-timedelta" class="headerlink" title="datetime.timedelta()"></a>datetime.timedelta()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">daysAfter = datetime.timedelta(days=<span class="number">13</span>)</span><br><span class="line">print(dt+daysAfter)                                     <span class="comment">#13天后的日期</span></span><br></pre></td></tr></table></figure><h3 id="datetime-strftime-和strptimr"><a href="#datetime-strftime-和strptimr" class="headerlink" title="datetime.strftime()和strptimr()"></a>datetime.strftime()和strptimr()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>)                        <span class="comment">#datetime对象转换成字符串</span></span><br><span class="line">datetime.datetime.strptime(<span class="string">'2015/10/21 16:29:00'</span>, <span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/02/17/3C1sYt.jpg" alt=""></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line">print(<span class="string">'Start of program.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeANap</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'Wake up!'</span>)</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=takeANap)</span><br><span class="line">threadObj.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'End of program.'</span>)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Start of program.</span><br><span class="line">End of program.</span><br><span class="line">Wake up!</span><br></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=<span class="keyword">print</span>, args=[<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>],kwargs=&#123;<span class="string">'sep'</span>: <span class="string">' &amp; '</span>&#125;)</span><br><span class="line">threadObj.start()</span><br><span class="line">print(<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>, sep=<span class="string">' &amp; '</span>)                <span class="comment">#args常规参数，kwargs关键字参数</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="批量有序重命名文件"><a href="#批量有序重命名文件" class="headerlink" title="批量有序重命名文件"></a>批量有序重命名文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,re</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">path = <span class="string">'C:\\Users\\Desktop\\test\\'</span></span><br><span class="line">prefix = <span class="string">'picture'</span></span><br><span class="line">suffix = <span class="string">'.py'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    fileregex = re.compile(<span class="string">r'\.\w*'</span>)                    <span class="comment">#取得后缀名</span></span><br><span class="line">    extension = <span class="string">''</span>.join(fileregex.findall(file)[<span class="number">-1</span>:])   <span class="comment">#列表转换为字符串</span></span><br><span class="line">    <span class="keyword">if</span> suffix:</span><br><span class="line">        newName = prefix+str(num)+suffix</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newName = prefix+str(num)+extension</span><br><span class="line">    <span class="keyword">if</span> extension == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span>                                        <span class="comment">#过滤掉文件夹</span></span><br><span class="line">    os.rename(path+file, path+newName)</span><br><span class="line">    print(file+<span class="string">' to '</span>+newName+<span class="string">' rename succeed!'</span>)</span><br><span class="line">    num = num+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT解决点进文章自动下滑到&lt;!-- more --&gt;后面</title>
    <url>/post/Hexo/hexo_issues/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hexo 版本v4.0.0 | 主题 – NexT.Gemini v7.6.0<br>若使用<code>&lt;!-- more --&gt;</code>标签来截取文章概要，当点击全文时，文章链接后会加上#more使页面自动下滑到<code>&lt;!-- more --&gt;</code>的后面<a id="more"></a><br>不想使用这一特性，有以下2个办法<br>1.找到<code>themes\next\layout\_macro</code>下的post.swig文件，将</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;#more"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里的#more删除，即</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.将主题配置文件中的<code>scroll_to_more: true</code>改为<code>scroll_to_more: false</code>这个方法对我没用，可能NexT在新版本中移除了这项配置<br>其他问题可以参考<a href="https://github.com/theme-next/hexo-theme-next/issues" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues</a>以及官方文档<a href="https://hexo-theme-next.netlify.app/" target="_blank" rel="noopener">https://hexo-theme-next.netlify.app/</a></p>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>死亡日记</title>
    <url>/post/Life/daliy/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="3ee71bc45f84975ce4030da589382a5a5d10d12d2e69e471ab3b76980460399b">5052a65d98f5b2298cedff0f1d1d501bed1f97ef5ba2db09796c0adabdfaf78d7998413a1efd8358221496574e82442b8b0805c0ca28a1ee879362a9df93da3759869d196edf3f9ffb342c2802ffb3bd60647af6801905232ed3203de2c3bb334205863506e0eb36b26ef15c79e7d7a7491d14b0142570f29fd4327ae5d05cd09510e14b0ba50f1a8ab65cadf8844434c357ed39b1dbe3e01ac5e9b3c9fcac5645d6c840497e9bc78eae94b637d51f2ba24ad46defcc424bb02975ec596a3bf2d00d86fc115752c5558200dd1f7d18dd6585f19f5914e7214fd77ac830b7a2c030989a27d3533529b91e24a943d0aba28b12e980e609ea13131659b328e2ed1dd39acfa72d7154062e165d98f7518f8dee61aa98cbe82ee65327ca359959b9510f5db4dcbf39b3f885fdf49e2244b4f0efe82bd5317bbc7102394ec7d36a5b37d5a702f59ee5ecb751c5d094ece39a6f17f9f581d8fe3114541fb5a58193f3e79e943575087504904f30452476c0254a1f3fec649008e01152765d2962eba3dc729cde30d0e7cbaba0de0638ae709fdcb1e612934c62d6e452aed9ac9ef83ce6f3ac26c344f18d1a4fe4043b3c4fdb4a3208a8bfc7760fcfb90fa9a966d45c1f1b9f0b8c51efc406a20bae1f8db6e495623ec5d2ba5fd75a7631a77ff6b2bba6c9fdc11b92bd764a67dcb0e60c7010d22594b0b4139588211ae054bdaf6e0128cc5eb9ffdcff259c42984dc8b3635c268008bc40043310d652c090a8365a83164004d553c2e364b691fd7c01817f7ddacff1adb28b3725819a318e19e168efcdc8b42781d3278956d3ab7586ae4be8c2ca8f15aa47fe1195fea214b0ce310367b783f75a0f3c46915f743d38d43ff4c00b2e33291daddb67ddacc23329530059fc79eeaabe608678b504842477c2509d1753bc9f5ec70ce42d2cadaa6265aa1804250cbc5e2944cc37534cb6fd43923c147abe1fde0477f540ba07e221be3454c6f83c64f397d1fb0180fc97ac071fc4639f79e38fed2832c4418ad7b0dc27800782b8e3f25508108d128b7095596150288d170d0abfbaa8862f09e76dee2582b05f3c937e16f892dc9559fbd49b40cafe7f3ad7e0848d9cffd8663cb28f6c5e24b6c3f2c689a953e6c6ca645eea6e3199a3378038f4842d5303c2248995a08e5956d5aeef70dfdf8e864f5197f1a00c920644fa362d6bdddbdc291839a3ad101ce770a36d8b1ba3e220a2b2ada093b8a8ba8988c3d3000e602d223726651fca2e7eb095ac2b54e2208e0e7b353c95cd9eadbaf9f2055ecf865b713ad7ef1e13e2f442dce4b2724b92bc501a5514bed297fbba8be6bd767a9e79522376c45bf214295e98289ac78fa5e401d3f3c22a3577d79c94633108775281b788dfc06ecd05ceb5bbe73c22423e6e1815bad3697786fbf748d02e207c63938ca0ee814791b7f08d1b55be81815e47acbea56b95bf4a4e2af24547544dc2c799d1277cf01472afbec24c96c2d24e0a1884f8183c4f9c631e2efae2d648f59ce60f0fb09b22dd1eab2881af1068f1935b828f4d450edc267af436d7f0fef7636e822ca0c9b739c1a9c5cf0d9850f6a07b901f7041322b11af7318ea1a688bfa52a579bbb54edb1955ce18229c2d14c4de20a82975cce0c4edef9e04ed1effb6739c1f6069a73073a0795159b24ea7deacbda9f90d358c55de29d161d5786f350b360de9d167ea99320aebc695c7c64f84204a9d2f63d5795064592114fe77e1256e35d724257a06e1d3d455a3a033674eae67c72b633b8ea71b98b889c1ca6581baba73dcedc6bf5be458a31ae7660f108b3845e8fc01ec63396fd11b709165d8db6a7220cdba400ec19dc3c63f0326a720af299d7bd3006ee50b6ed7bd70f7d0fe283fb9906b94c10c3bd3f3253094da265b848dec7477bef4d1ac6f87258e16979ee6fcf2ac60473487f6b3cb27e2799e1d547caec7e738659372a1157ce2c921f3baf5ae44ade3814622a2ec041e176dce0efe43a87baaf37b418aca0ee5b5f65e6e11f206dd4c42c6d5540078d4b63830689056bac191e084641bc8db8d2d3432eab9212e6a14fbc3568d66806ee85cda3c0329acdb0d1c86d66efa44e1e6cee8c51b910f0225c39e1878aaa3af2a75e6aa1c05dda6159ed2cea32b8541c30f430cf6737cfa40f175d383463bdd9d7cc6e9582a9348be3e6f6f56d07a86fda34a9b728565168a02a943abf2d94751646438040893a16310d5fdcfc7b971c3836f58cb5e7033598402af22eaf176087fcfe8626f9434464a556480393836070c614f6168e7db326f50106e07988db58eaccf45b765cfb3b2030778575a7b0775a0f61c397094106e58bd8df783b452c1a4efdceb0be4e4a901de8fb04a0ec299825f48aefabd94c66eb6d06fbbf0e91002fb9e255014a3b9eebbc0361edecae7a9e0637adae9df825eb5928eaa31fb92450125c7cad35ebccc016fbc07c79cdd1ae7e7373d3a9b3b9af34f00b0376944b72938b38e537fab25b1a0537854bb5fc67d239ff3fd72485ac43963e73ada1d253e5be6900b93915f7c723227a677bb63455ddfd1050cda4d3b2d2313523e98eae41ee435502fb8fb5a3a85a6cd2938be47a566a7f35c5a191feb1bbf1c6de15d4564c6ccc72ed1cfed05b2a27137dde49f5dd5cd4fa7cc0eed76fe31620b0ec6998dc1d1b9cddb7550499c5124ce5582e7b9096a52d69fc2f0719eb9a847b4b3ad8733b3d899fd8c6acf3da5bdb893297a886eb4843a4de32481c1743265c80e0fd51869f5d7fe52f375c81e901bc4c520414189b50dfa6233f2dd1431f1e010bc039ad5f590bc368dcf75d472296ff39a6e8faa6a12acb17ace983ef54a80636a77429c90d5a610301d301c626f119f22b874d228dee91aa6efb550eee9edcdf0a6eb652236a6a6f67c0fecaf4d6ec7ebb3c4ceab91520ede7aff3ac8034e7f58ee2fed40e7558b6f5daa480fa51c7c8810846b5454ee8f3d70c745d406f0d5156abe355f51418d4f267b644be346d4601ef1fd57a3c3ea53dc6a2f7c092e59663f7717753968c2b9485f28b6409b22be17c35e0ced24fa69f4edbda82c7fa3977029a958966b16f7ef198914e58479d79d836ecc30fb29c63b2d09b76d8dcb4d3c439968792ef7a0927b8758eae70c1be3b0dff6fd7c53eba914513ffe29acf4ca0323b84e7240db74126293effda20592112369f45980e11b94dbb26132c20d9de2da53729496b6efc6996a719c9d2a726043957b9e3cba17ac0a18df33965db51b336d27c9af298fe8ccd19d358b22fe51b7722ca216d3546203bf1cfc04eb9286df15c1258fdf4238321f1823e62bb7e8841b9ca3440191e624fafcdeb61fae98eb5b7e375c91c99cb135bb6a09eec95f66ef81c1e35c38cbe972bd3c51c7c777e5b18605ce68b01802eaae9429c994fb00c0e19ff682f9a1f90fe59e7faa4309b8f5a3db31a5a944d3cafaa45895e675675c162fc583fdbf0610259258b167ebd3f0af7773481cc538bb4ac5ee31c31e9786cdf3d55c94caf38921385e56dda6c03739c874a5b138be0117bc21059bdad64efb2cbd5ce7a0e07c797f83340a9b0edd06973f2676c8506838d46d3881181565567062315747c1602082348a2905c8a54f7716b6aad528ef561ef667990155ebd15c3d6050d6b4beaa8a731b406215a8cb5482a674c4b362a2ba68dfe83c8d11133c662865cd60b71918c3b0aaa7484214ba2129e582b99e196a28a095e22a78d9a308c1025174126b088414f56d922c369a9aca29b4958ea55d012e355c0cf0b51324bdd598c587e47f6279f94e9cf81a895f82ef270023327d126941669f02905aad17ab98a1aa5275cf9a4fe821ce1968ef62a88aa41a74ef5a48e2d354224229bf65db74f3f670e56e32e76b78352324c6d97c482aa750b5253b3aede48256bb6a14860694dffc0010a567e695b2344bbc99a75d19993a4b10371a2eef6e23907f4e147ddbac763805ba55f0834d71a79fd43cee52684254bec2ce6763ab1c2443f62ca09f126804daef8722d59d03b011c2380bba8ee099270ca470cc708031eba431a631507248a44af4531bc47193f18e72d98a2d6a64734f96a0575a319c61b0394eb602fbd622e553283891d7865ca7c47d3b7479dcbb52d8e0c12db4985ec85060d0b2da66699c2e1efd976d997dccb37e58d090d27c12f7964d0e3b6e68e487cd6491c030ca861d8076f2e00c07136a457de6a3a5e6ac01a9919723f5404310186d334e460e60697b54f57e86fb05ba6392c08c7129b7b3bac8178ed033ffd175bcff136660dfd2388e35b9eedd2f1e1b4c246c96a39397596c49d82d7e204e3e449250cca76c33e959e83dbab0fc8b6c904de91cc525d7632da237d245372eb0c9a77393a0bab71a3440cf3bfd891e3061b48816c7677a98ceab22400c617ea86df3a5c591f3a1251f9c89e85266f49f1065ef120325e038db2d58e486209f37f2e38c6b6b9c7116511cef7e19c8def72407d9c12ba8d6e48233001e4d9e9c9c6eb05768d68db77e4bd82247fff05422294a3b2313d8c2484f64112c4feaff721649835c1b82a161a1ade1d475c271fd9654d2fab41e42764aa11c4b2189c4c0607ba85a142ad736e9aa957d6da499172be25bf1c7b042f44068820d8aced16211d84b40c7e89456acbdaf5880b0798e7dbef7b7afa6c1802c116272853b5765cc1cdf7e592a8b26b3a5b7274b5c83ece03de88563a25da092fe5be15ca71989f14273d1a44e793a87e2193e39399bf97fd1aec58b0c995789fc64fe55c0ddc78691d4c849f9d40096c7d6fc1e767674d9da3faab26d9d54066535c8f01609420bf84834ebe0319620b09529672f51da3ea83d205d00451695b19721c96cb81f6acf38e9155089d74f9bee83a21b1bf9b894f650ecf5815579e050b2af530ad3ecf25e9597ceccdef87e729d56dc15d672e8b59b51e6c85d13b234fe8421fdd2ad027820daea47362f49f76c1a2fb80e5e002ac94f84e9654bd6730183a8dc7a9b688f69dba224bc64c99e60f68450bc345a90c08efdcca6ece6651cce83004944d80a2ad7c9ed62f314138d0d1b72bbc61cda8b7bc94c56e742a56fd98a4e3cb2ec11d2f7d1aaadf1e40080eb9285d924e1ff6446aae8dc804c1306660ceb2e4261bf58226d556dfa7a2432b803ea4e69f122a5157721bd8e466dea1500a3ea9fb7632bfea9b758c07890201c31f4c0b227f8f2a2bf96f0be3505968fe5cafb72d98b181027b106cf1f7b08eddff8c2bcc51b6c514e892741ae94e7f9289f54dda7f3028abbbd4154acc8a608ae5c68566fa70d377757cc4ccd323e11dc14a5d743ace9b51692fdaf01a93345e617dc6c97782d79653241305616511e95d49fad8892fa61ac1b387c917d4370fb297e0006ebb57a6dc17c66f19accac5340422f66a30fcae1a5836eabcf9be47976a36266e9796aaacb0efce20352a114afa7680872d762a766ffdb462f87f21c44297d743472dfba9419af656abf0a58a4da1590186835e01b210a060866644fa696433d7baf15d3f4b423cbf500cc8f1439c091eea28e1995e68e43b50f2904b96bf3cd0e7fb86d06d9835c4467134ac835328cf957d797daff5af8de97955bb5d215b449f5e5a27233520775b8d82170894e7074fac8346dc43bc23d6d5b6e14389fd18cae148c43b1957302bf26aad3cb6893840bc3165e00a806fe50c795f134410f57dbbdc3cd7a2e54f62f58e54507a78d2e2cb1f09f83a30c6b41faea50cdfc09904253332b879a08cc99dff0dad1ba688c335a847b69f263ab009fa81b53f43cc1647b433a9110f16bfa240c55e96807538c23e1cfd36598cffdc3690fee73de434b8be417876333f45230314d6b854dedda25590cb048cb7065eba35e4b318d9a425861d432e94cb2587fc6b5b0751bb378904c916db0ad27f84d592b3f216ae8f1051551d85b19add35ba5b0932d2385ee501a675cada31dde47e8d111b840b116590870fea220a60a0d0735636eafbfb82bec4b1a633c20ac4e822951cb038867a4f20baadb1781cb9e0daafff09768d6015d38ba7b4b95a3688041187094a5075be5463ea978cf4e7734f11207d1f34997613445ab7f583bd68ef54e242005b4874dec27402260a26adaf8c23f4c37516f82ab3a03abf91cf8b2910e89e772c2b453482e422f7d02cbf0edbc1bd63991c4dc2af8ff24baa39bbd08ae92ec3bc456a45eedaad6c8b13297e0045b4ee714ccc7f1e24db2db959b4650f01f0df6072d31edab8e6236f5306042a116d67139de33e49422622ef78c87e5e7c827733b7ddfe82d4442103d7c578460709ee763c2fb653bed7c8ed62374999132361d84b268451a2fd8d644d1316fcb8ac5649ae69d7c1d4cfd5721d411ba072405f640ee577b1e4d922ae791d1af579caeed182d14893c820f2ad6059cdba73233ddf1dc9633183406c0af64f0e449554197ba0ec3c8f1c12c0a16e7a22c2e9bed82974c1f9c3fe9e1ce10bfe80344c5651bbce90f3be43107d7343ace2af6da894ca6264b56291bd56813e688b252093038fb830bfbe6776c3d08daa1d6ff71f4775a41a4dcffc3b5a549cff40161318df9a8b2e32d2dd9ff46e584ce03bcb8d4e855c9a81f2c4b53a6d882815a8eb017ca0dc845354dcafeccccbee09d360a2e6cbb80b97dac16f7ada3d808bc074452c89c1eec4d597957318104bee33a67401e08cf807d48d503a4061ef1e8cc3d1192f5a8f96c9baebb6695d3effaff9830dfae1bad7dafff935aaf194be6424ba56c40ed4c107c1e6875c43fcdbe48265c60795c9fd828cbb27b4071a01dc57b2a514a673d03f293f85305f3fa1a3cf8a7361d57750af6874282034430b5a3e3a1f497d8ad8b0c94bd0ca61e510db74acc4bbf4729a09448286ce16ae939c09963dd13299f65e551e0866c0c930d41cd4d6903cb2e584c8216ffa664c4916e45053d4a615456826b0f1b9ac85b7428b925605d4c41fb7eb80474c2fa0a1e31f14b8c34348f87bb80a677ef0a42a868376c25a6eaa0c519ff957b5d850bc6d3401e34e33adde634ca28897b613a75e5eeadf4ff84e6bd5496a5cd1b2d2e1bf0adfb6e71c27cb07e5616a4747630f0df2c7c5becf0bef0e3f5483f3a1026139ea614a3de2a6e26ff974848e9444a72e4d32a3fd25d5ede42fa43a68655a79ec0f0455621b3393a5aeb852ace32b71a4b78b48be83491925639acea362eb2905b5a7a99f6574126545aa53368a98a6506b9cd7c5e8ea47ecdc421b259a3dc7e79f1a79ddcb9c31680b263558492f3e319dde1eb4beecc8b38a2f4af7eff5745945bff61d352c8bd4ac56e74e1afa1457a7d1b884c7e57695301f1da5b2974c15af086c174de35dfd55e9352dff4a0a2f9c4be822fe75797ca3636af89d1f240a8ce46dc34405e908a9cda25099cff1ec44207099c3a944d2127883f59e0d966725e6825aaec4efbb084edb1530f2e286f983753fca075851aa6dbb6d5c9cf0a2b0aec5e8682e010adebe0a69e946f5e270d8bb637ec07a38a657080b134c52b7367f174863068507a3bb267616a526b791000961da6e6c467b761852618d54fac8f550d23cef43a723988f70e683186cbaaa843f52bbb3e02624c246d4aafafd7db98d3be99d5615ae5c37273a947652a5b772db5e766f94fbdda0eb60e1c74587f61dd23f30365474e6e4affef0ddf097a5876c8d49967f115de45475cc08d7d708407efa1eeff7d77c972cbbbd07b3c3f90a735cc6e61b6197f95cfac8ca345e1c19642c536b31ad617aca92b582c7d7da7134542eab6a1eb7a1448bddfe310dcb4b77d77cf43a8d3362df58bacdbe45e1ee4506175fbc19fb4fc21268736648b39335dfb91d44e7355943e0c5aae6459d19f8fd3030ed43f7448d54ac90b9ef5261aaba07d619643d47319da64bc476e85a6f4ba2eec17b21be69b8ef6658242314745a648aa7ce5a3e094b5df1c8e87e68d3d846206b141409e3ea8549d9c574547321ea4e8f8</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
</search>
