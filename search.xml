<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用命令</title>
    <url>/post/Tips/common-commands/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>包括Hexo等<a id="more"></a></p><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br>新建文章：<code>hexo new page --path _posts/Hexo/hexo-commands &quot;Hexo常用命令&quot;</code><br>生成静态文件和上传：<code>hexo g -d</code><br>本地运行：<code>hexo s --debug</code></p>]]></content>
      <categories>
        <category>Tips</category>
      </categories>
  </entry>
  <entry>
    <title>《Python深度学习》笔记</title>
    <url>/post/DeepLearning/deep-learning-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Python深度学习》笔记<a id="more"></a><br><a href="#jump">Windows下的环境搭建</a></p><h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1 基本概念"></a>Chapter 1 基本概念</h2><p>首先理清人工智能、机器学习和深度学习的概念和关系，<br>人工智能&gt;机器学习&gt;深度学习<br>深度学习是机器学习的子集，而机器学习则是人工智能的子集</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p><strong>简洁定义</strong>：将通常由人类完成的智力任务自动化。<br><strong>发展</strong>：<em>符号主义人工智能</em>（symbolic AI）→<em>机器学习</em>（machine learning）<br><strong>符号主义人工智能</strong>：编写足够多的明确规则来处理知识，用于解决定义明确的逻辑问题，如下国际象棋，但对于图像分类、语音识别等难以给出明确规则的复杂、模糊的问题将无法解决。</p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><img src="https://i.loli.net/2020/05/16/iweKFoO9k862ufD.png" alt=""><br>　　机器学习将某个任务相关的示例输入机器学习系统，系统从中找到统计结构，最终找到规则将任务自动化，其与经典程序设计不同如上图。<br>　　机器学习的三个要素如下：<br>　　（1）输入数据点。<br>　　（2）预期输出的示例。<br>　　（3）衡量算法效果好坏的方法。<br>　　机器学习和深度学习的核心问题在于<strong>有意义地变换数据</strong> ，即学习输入数据的有用<strong>表示</strong>（表征数据或将数据编码），如彩色图像可以编码为RGB（红-绿-蓝）格式或HSV（色相-饱和度-明度）格式，在应对不同任务时，不同的表示方式将会产生很大的差异，所以机器学习模型的目的就是为输入数据寻找合适的表示。<br>　　<strong>定义</strong>：在预先定义好的可能性空间中（假设空间），利用反馈信号的指引来寻找输入数据的有用表示。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>　　深度学习强调从连续的<strong>层</strong>中进行学习，这些层对应越来越有意义的<strong>表示</strong>。<br>　　模型包含的层数成为模型的<strong>深度</strong>，这些分层总是通过<strong>神经网络</strong>（neural network）模型学习得到。<br>　　<strong>定义</strong>：学习数据表示的多级方法，相当于多级信息蒸馏操作。<br>　　<strong>深度学习工作原理</strong>：<br>　　神经网络每层对输入数据所做的具体操作保存在该层的<strong>权重</strong>中，其本质是一串数字，每层实现的变换由其权重来<strong>参数化</strong>，<strong>学习</strong>即为每层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。<br>　　输入网络预测值和真实目标值通过<strong>损失函数</strong>计算一个距离值，利用这个距离值作为反馈信号通过<strong>优化器</strong>实现<strong>反向传播算法</strong>来对权重值进行微调，以降低当前示例的损失值，随着示例的增多，损失值逐渐降低，输出值与目标值尽可能接近。如下图。<br><img src="https://i.loli.net/2020/05/16/zomZXBxty67UqEN.png" alt="深度学习工作原理图"></p><h2 id="Chapter-2-神经网络的数学基础"><a href="#Chapter-2-神经网络的数学基础" class="headerlink" title="Chapter 2 神经网络的数学基础"></a>Chapter 2 神经网络的数学基础</h2><h3 id="张量（tensor）"><a href="#张量（tensor）" class="headerlink" title="张量（tensor）"></a>张量（tensor）</h3><p>定义：又叫多维Numpy数组，作为机器学习的基本数据结构，是一个数据容器，包含的数据几乎总是数值数据，如矩阵是二维张量，张量是矩阵向任意维度的推广[ 张量的<strong>维度</strong>（dimension）通常叫做<strong>轴</strong>（axis）]</p><h3 id="标量（scalar）"><a href="#标量（scalar）" class="headerlink" title="标量（scalar）"></a>标量（scalar）</h3><p>定义：仅包含一个数字的张量，又叫标量张量、零维张量、0D张量。在Numpy数组中，一个float32或float64的数字就是一个标量。<br>标量张量有0个轴（ndim == 0），轴的个数又叫<strong>阶</strong>（rank）。如下代码查看一个标量张量的轴的个数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="number">12</span>)</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a>向量（vector）</h3><p>定义：数字组成的数组，又叫一维张量或1D张量，只有一个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>该向量有5个元素，为5D向量，有1个轴，沿着轴有5个维度。而5D张量有5个轴，沿着某个轴可能有任意个维度。</p><h3 id="矩阵（matrix）"><a href="#矩阵（matrix）" class="headerlink" title="矩阵（matrix）"></a>矩阵（matrix）</h3><p>定义：多个向量组成的数组，又叫二维张量或2D张量，有2个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>第一个轴上的元素叫行，[12, 3, 22, 121, 4]是x的第一行，第二个轴上的元素叫列，[12, 12, 12]是x的第一列。</p><h3 id="3D张量与更高维张量"><a href="#3D张量与更高维张量" class="headerlink" title="3D张量与更高维张量"></a>3D张量与更高维张量</h3><p>定义：多个矩阵组成的数组，有3个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]],</span><br><span class="line">            [[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>深度学习一般处理0D到4D张量，处理视频数据可能会遇到5D张量。</p><h3 id="张量的关键属性"><a href="#张量的关键属性" class="headerlink" title="张量的关键属性"></a>张量的关键属性</h3><ul><li><strong>轴的个数</strong>（阶、维度）：Python库中为ndim。</li><li><strong>形状</strong>：张量沿某个轴的维度大小（元素个数），如前面的3D张量的形状为（3， 3， 5）。</li><li><strong>数据类型</strong>：张量所包含数据的类型，Python库中为dtype，如float32、float64、unit8等，极少数情况有字符（char）张量，Numpy等大多数库都不存在字符串张量，因为<span style="border-bottom:2px solid red">张量存储在预先分配的连续内存段中</span>，而字符串长度可变，无法用这种方式存储。</li></ul><p>代码示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line">print(train_images.shape)</span><br><span class="line">print(train_images.ndim);</span><br><span class="line">print(train_images.dtype);</span><br><span class="line"></span><br><span class="line"><span class="comment">#该3D张量中的第四个数字</span></span><br><span class="line">digit = train_images[<span class="number">4</span>]</span><br><span class="line">plt.imshow(digit, cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">uint8</span><br><span class="line"></span><br><span class="line"><span class="comment">#由上可见，train_images是一个由8位整数组成的3维张量，即60000个28*28整数矩阵组成的数组，每个矩阵是一张灰度图像。</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/18/Yf6u1H.png" alt="该3D张量中的第四个数字"></p><h3 id="张量切片"><a href="#张量切片" class="headerlink" title="张量切片"></a>张量切片</h3><p>类似于Python的切片操作，示例:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择第10~100个数字（不包括100），将其放在形为（90，28，28）的数组中</span></span><br><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>]     <span class="comment">#[10:100, 0:28, 0:28]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可沿着张量轴在任意两个索引间进行选择，也可使用负索引</span></span><br><span class="line">my_slice = train_images[, <span class="number">14</span>:, <span class="number">14</span>:]       <span class="comment">#右下角14*14</span></span><br><span class="line">my_slice = train_images[, <span class="number">7</span>:<span class="number">-7</span>, <span class="number">7</span>:<span class="number">-7</span>]       <span class="comment">#中心14*14</span></span><br></pre></td></tr></table></figure><h3 id="数据批量"><a href="#数据批量" class="headerlink" title="数据批量"></a>数据批量</h3><p>　　所有数据张量的第一个轴称为<strong>样本轴</strong>或<strong>0轴</strong>（samples axis）。<br>　　深度学习模型会将数据集拆分成小批量，形如<code>batch = train_images[:128]</code>。<br>　　对于这种批量张量，第一个轴为<strong>批量轴</strong>（batch axis）或<strong>批量维度</strong>（batch dimension）。</p><h3 id="现实世界中的数据张量"><a href="#现实世界中的数据张量" class="headerlink" title="现实世界中的数据张量"></a>现实世界中的数据张量</h3><ul><li><strong>向量数据</strong>：2D 张量，形状为 (samples, features) 。</li><li><strong>时间序列数据或序列数据</strong>：3D 张量，形状为 (samples, timesteps, features) 。</li><li><strong>图像</strong>：4D张量，形状为 (samples, height, width, channels) 或 (samples, channels,<br>height, width) 。</li><li><strong>视频</strong>：5D张量，形状为 (samples, frames, height, width, channels) 或 (samples,<br>frames, channels, height, width)</li></ul><h4 id="向量数据"><a href="#向量数据" class="headerlink" title="向量数据"></a>向量数据</h4><p>　　常见的数据。每个数据点被编码为一个向量，因此一个数据批量就被编码为 2D 张量（即向量组成的数组），其中第一个轴是<strong>样本轴</strong>，第二个轴是<strong>特征轴</strong> <span style="border-bottom:2px solid red">(samples, features)</span>。如<br>　　人口统计数据集，其中包括每个人的年龄、邮编和收入。每个人可以表示为包含 3 个值的向量，而整个数据集包含 100 000 个人，因此可以存储在形状为 (100000, 3) 的 2D张量中。</p><h4 id="时间序列数据或序列数据"><a href="#时间序列数据或序列数据" class="headerlink" title="时间序列数据或序列数据"></a>时间序列数据或序列数据</h4><p>　　当时间对于数据很重要时，将数据存储在带有时间轴的3D张量中。每个样本被编码为一个向量序列（即2D张量），因此一个数据批量就被编码为一个3D张量 <span style="border-bottom:2px solid red">(samples, timesteps, features)</span>。如图：<br><img src="https://s1.ax1x.com/2020/05/18/YhClMF.png" alt="">　　依据惯例，时间轴始终是第二个轴。<br>　　例如股票价格数据集：<br>　　要构建一个股票价格数据集：每一分钟，我们将股票的当前价格，前一分钟的最高价格和前一分钟的最低价格保存下来，那么就被编码为一个3D向量。整个交易日就编码为一个有390个3D向量的2D张量（390，3）。250天的数据就编码为3D张量（250，390，3）。</p><h4 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h4><p>　　图像通常具有三个维度：<strong>高度</strong>、<strong>宽度</strong>和<strong>颜色深度</strong>。虽然灰度图像（比如 MNIST 数字图像）只有一个颜色通道，因此可以保存在 2D 张量中，但按照惯例，图像张量始终都是 3D 张量，灰度图像的彩色通道只有一维。因此，如果图像大小为 256×256，那么 128 张灰度图像组成的批量可以保存在一个形状为 (128, 256, 256, 1) 的张量中，而 128 张彩色图像组成的批量则可以保存在一个形状为 (128, 256, 256, 3) 的张量中。<br><img src="https://s1.ax1x.com/2020/05/18/YhipjS.png" alt="">　　图像张量的形状有两种约定：通道在后（channels-last）的约定（在 TensorFlow 中使用）和通道在前（channels-first）的约定（在 Theano 中使用）。<br>　　Google 的 TensorFlow 机器学习框架将颜色深度轴放在最后：<span style="border-bottom:2px solid red"> (samples, height, width, color_depth)</span>,例如(128, 256, 256, 3) 。<br>　　Theano将图像深度轴放在批量轴之后：<span style="border-bottom:2px solid red">(samples, color_depth, height, width)</span>，例如(128, 3, 256, 256)。<br>　　Keras 框架同时支持这两种格式。</p><h4 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h4><p>　　视频数据是现实生活中需要用到 5D 张量的少数数据类型之一。视频可以看作一系列帧，每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_depth) 的 3D 张量中，因此一系列帧可以保存在一个形状为 (frames, height, width,color_depth) 的 4D 张量中，而不同视频组成的批量则可以保存在一个 5D 张量中，其形状为<span style="border-bottom:2px solid red">(samples, frames, height, width, color_depth) </span>。<br>　　例如，一个以每秒 4 帧采样的 60 秒 YouTube 视频片段，视频尺寸为 144×256，这个视频共有 240 帧。4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3)的张量中。总共有 106 168 320 个值！如果张量的数据类型（ dtype ）是 float32 ，每个值都是32 位，那么这个张量共有 405MB。现实生活中遇到的视频要小得多，因为它们不以float32 格式存储，而且通常被大大压缩，比如 MPEG 格式。</p><h3 id="张量运算——神经网络的“齿轮”"><a href="#张量运算——神经网络的“齿轮”" class="headerlink" title="张量运算——神经网络的“齿轮”"></a>张量运算——神经网络的“齿轮”</h3><p>本节和下一节主要是高等数学和线性代数在神经网络中的运用，下面只简单提一下这些数学知识在神经网络中的相关概念。</p><h4 id="逐元素运算（element-wise）"><a href="#逐元素运算（element-wise）" class="headerlink" title="逐元素运算（element-wise）"></a>逐元素运算（element-wise）</h4><p>运算独立地应用于张两种地每个元素，适合大规模并行实现。如：</p><ul><li>relu运算：relu(x) == max(x, 0)</li><li>四则运算（前提是运算对象形状相同）</li></ul><h4 id="广播（broadcast）"><a href="#广播（broadcast）" class="headerlink" title="广播（broadcast）"></a>广播（broadcast）</h4><p>两个形状不同地张量相加，较小地张量会被广播，以匹配较大的张量。如：<br>x形状为（32，10），y形状为（10，），则x+y会为y添加空的第一个轴（广播轴）→（1，10），再沿新轴重复32次→（32，10）。<br>但以上过程不会在运算中实际发生，只是想象的思维模型。</p><h4 id="张量点积（tensor-product）"><a href="#张量点积（tensor-product）" class="headerlink" title="张量点积（tensor product）"></a>张量点积（tensor product）</h4><p>类似于线性代数中矩阵的乘法，Keras和Numpy中使用<code>numpy.dot(x, y)</code>实现。<br>形如(a, b, c, d).(d, e)-&gt;(a, b, c, e)，<img src="https://s1.ax1x.com/2020/05/19/Y4DYO1.jpg" alt=""></p><h4 id="张量变形（tensor-reshaping）"><a href="#张量变形（tensor-reshaping）" class="headerlink" title="张量变形（tensor reshaping）"></a>张量变形（tensor reshaping）</h4><p>改变张量的行列，但元素总数不变。<code>x.reshape((2,6))</code><br>行列互换称为<strong>转置</strong>（transposition）<code>numpy.transpose(x)</code></p><h4 id="张量运算的几何解释"><a href="#张量运算的几何解释" class="headerlink" title="张量运算的几何解释"></a>张量运算的几何解释</h4><p>类似高数中的向量变换以及更高维的延申。</p><h3 id="基于梯度的优化——神经网络的“引擎”"><a href="#基于梯度的优化——神经网络的“引擎”" class="headerlink" title="基于梯度的优化——神经网络的“引擎”"></a>基于梯度的优化——神经网络的“引擎”</h3><p>　　对每个神经层用下述方法对输入数据进行变换。<br>　　<code>output = relu(dot(W, input) + b)</code><br>　　在这个表达式中，W 和b 都是张量，均为该层的属性。它们被称为该层的<strong>权重</strong>（weight）或<strong>可训练参数</strong>（trainable parameter），分别对应kernel 和bias 属性。这些权重包含网络从观察训练数据中学到的信息。<br>　　一开始，这些权重矩阵取较小的随机值，这一步叫作<strong>随机初始化</strong>（random initialization）。当然，W 和b 都是随机的，relu(dot(W, input) + b) 肯定不会得到任何有用的表示。虽然得到的表示是没有意义的，但这是一个起点。下一步则是根据反馈信号逐渐调节这些权重。这个逐渐调节的过程叫作<strong>训练</strong>，也就是机器学习中的<strong>学习</strong>。<br>　　上述过程发生在一个<strong>训练循环</strong>（training loop）内，其具体过程如下。必要时一直重复这些步骤。</p><ul><li>抽取训练样本x 和对应目标y 组成的数据批量。</li><li>在x 上运行网络［这一步叫作前向传播（forward pass）］，得到预测值y_pred。</li><li>计算网络在这批数据上的损失，用于衡量y_pred 和y 之间的距离。</li><li>更新网络的所有权重，使网络在这批数据上的损失略微下降。</li></ul><p>最终得到的网络在训练数据上的损失非常小，即预测值y_pred 和预期目标y 之间的距离非常小。<br><span style="border-bottom:2px solid red">详情参见：<a href="https://www.ituring.com.cn/book/tupubarticle/23177" target="_blank" rel="noopener">https://www.ituring.com.cn/book/tupubarticle/23177</a></span></p><h2 id="神经网络入门"><a href="#神经网络入门" class="headerlink" title="神经网络入门"></a>神经网络入门</h2><h2 id="Windows下的环境搭建"><a href="#Windows下的环境搭建" class="headerlink" title="Windows下的环境搭建"></a><span id="jump">Windows下的环境搭建</span></h2><p>由于懒得装双系统，虚拟机先不说配置不够，搭起来感觉坑很多，遂直接在Windows系统下搭建。</p><h3 id="安装CUDA和cuDNN"><a href="#安装CUDA和cuDNN" class="headerlink" title="安装CUDA和cuDNN"></a>安装CUDA和cuDNN</h3><blockquote><p>CUDA（Compute Unified Device Architecture）：NVIDIA用于自家GPU的并行计算框架，本质是一个工具包（ToolKit）。</p></blockquote><blockquote><p>cuDNN（CUDA Deep Neural Network library）：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。用GPU训练模型，cuDNN不是必须的，但是一般会采用这个加速库。</p></blockquote><ol><li><p>查看显卡支持的CUDA版本<br>NVIDIA控制面板&gt;帮助&gt;系统信息&gt;组件，如图支持10.2版本<br><img src="https://s1.ax1x.com/2020/05/17/Y20vQK.png" alt=""></p></li><li><p>安装对应版本的CUDA</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></p></blockquote><blockquote><p>安装完成后打开cmd，输入命令：<code>nvcc -V</code>，如图</p><img src="https://s1.ax1x.com/2020/05/17/Y2yrUe.png" style="margin-left:0" alt=""></blockquote></li><li><p>编译CUDA（暂时未编译）</p></li><li><p>安装cuDNN</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p></blockquote><blockquote><p>这里需要注册账户才可以下载，可以看到支持的对应CUDA版本<br>将解压后的文件复制到CUDA安装路径中，这里是默认路径<br><code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1</code></p></blockquote></li></ol><h3 id="安装TensorFlow和Keras"><a href="#安装TensorFlow和Keras" class="headerlink" title="安装TensorFlow和Keras"></a>安装TensorFlow和Keras</h3><p>由于本机已经安装过Python3.7，管理多版本Python有点麻烦，故直接<strong>使用pip安装</strong>而不是Anaconda<br>在用pip安装前，<strong>确保pypi源更换为国内镜像</strong>，否则速度超级慢</p><blockquote><p>方法为在C盘的user目录下新建一个pip文件夹，如：C:\Users\xx\pip，在pip文件夹内新建一个pip.ini文件，内容如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>常用国内镜像：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;   # 清华大学</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;     # 阿里云</span><br><span class="line">https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;             # 豆瓣</span><br><span class="line">https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;    # 中国科学技术大学</span><br><span class="line">https:&#x2F;&#x2F;pypi.hustunique.com&#x2F;                # 华中科技大学</span><br></pre></td></tr></table></figure><p></p></blockquote><ol><li>安装Tensorflow<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>安装完成后在python环境中运行<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tf</span><span class="selector-class">.test</span><span class="selector-class">.is_gpu_available</span>()</span><br></pre></td></tr></table></figure>可以查看到GPU信息即安装成功。<br>Tensorflow作为Keras的后端,TensorFlow与CUDA和cuDNN各版本对应如下：<br><img src="https://s1.ax1x.com/2020/05/17/Y24DV1.png" alt=""></li><li>安装Keras<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> keras</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装其他组件"><a href="#安装其他组件" class="headerlink" title="安装其他组件"></a>安装其他组件</h3><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonic Coding</title>
    <url>/post/Python/effective-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Effective Python》学习笔记<a id="more"></a></p><h2 id="程序风格"><a href="#程序风格" class="headerlink" title="程序风格"></a><center>程序风格</center></h2><h3 id="遵循PEP8风格指南"><a href="#遵循PEP8风格指南" class="headerlink" title="遵循PEP8风格指南"></a>遵循PEP8风格指南</h3><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">《Python Enhancement Proposal #8》</a>，简称PEP8，是针对Python代码格式编订的风格指南。</p><h3 id="bytes、str与unicode区别"><a href="#bytes、str与unicode区别" class="headerlink" title="bytes、str与unicode区别"></a>bytes、str与unicode区别</h3><h4 id="首先区分Python3与Python2的两种表示字符序列的类型"><a href="#首先区分Python3与Python2的两种表示字符序列的类型" class="headerlink" title="首先区分Python3与Python2的两种表示字符序列的类型"></a>首先区分Python3与Python2的两种表示字符序列的类型</h4><ul><li>Python3，bytes与str，前者的实例包含原始的8位值，即原始的字节，包含8个二进制位；后者的实例包含Unicode字符</li><li>Python2，str与unicode，前者的实例包含原始的8位值；后者的实例包含Unicode字符</li></ul><h4 id="二进制数据与Unicode字符相互转换"><a href="#二进制数据与Unicode字符相互转换" class="headerlink" title="二进制数据与Unicode字符相互转换"></a>二进制数据与Unicode字符相互转换</h4><p>常见编码方式为UTF-8<br>Unicode字符 → 二进制数据，encode()方法<br>二进制数据 → Unicode字符，decode()方法</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>Python程序中，编码和解码操作放在程序外围，核心部分使用Unicode字符类型</li><li>在只处理7位ASCII时，Python2的str和unicode类型的实例可以等价，而Python3中bytes与str的实例绝对不等价</li><li>Python3中，使用内置open()函数获取文件句柄，该句柄默认采用UTF-8格式来操作文件，问题在于Python3给open()函数添加了名为encoding的新参数，其默认值为’utf-8’，要求必须传入包含Unicode字符的str实例，而不接受包含二进制数据的bytes实例<br>总结为必须使用二进制写入模式open(path, ‘wb’)来开启待操作文件</li></ul><h3 id="用辅助函数取代复杂表达式"><a href="#用辅助函数取代复杂表达式" class="headerlink" title="用辅助函数取代复杂表达式"></a>用辅助函数取代复杂表达式</h3><p>如，从字典中查询并返回得到的第一个整数值:<br><code>red = my_values.get(&#39;red&#39;, [&#39;&#39;])[0] or 0</code><br>未查询到或值为0为空统一返回0，该表达式不易理解，若要频繁使用，将其总结为辅助函数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_int</span><span class="params">(values, key, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">    found =values.get(key, [<span class="string">''</span>])</span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        found = int(found[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = default</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">red = get_first_int(my_values, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><p>somelist[start:end]，其中start所指元素涵盖在切割后的范围内，end所指元素不包括在切割结果之中。例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start从0开始，end倒数从-1开始</span></span><br><span class="line">a[:]                                    <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line">a[:<span class="number">3</span>]                                   <span class="comment">#[1,2,3]</span></span><br><span class="line">a[<span class="number">2</span>:]                                   <span class="comment">#[3,4,5,6]</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]                                  <span class="comment">#[3,4,5]</span></span><br><span class="line">a[<span class="number">-3</span>:<span class="number">-1</span>]                                <span class="comment">#[4,5]</span></span><br></pre></td></tr></table></figure><p>切割列表时，start和end越界不会出问题，利用该特性可以限定输入序列的最大长度。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">first_nine_items</span> = a[:<span class="number">9</span>]</span><br><span class="line"><span class="attr">last_nine_items</span> = a[<span class="number">9</span>:]</span><br></pre></td></tr></table></figure><p>切片后不影响原列表，对list赋值，若使用切片操作，会把原列表处在相关范围内的值替换为新值，即便长度不同也可以替换。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">1</span>]                          <span class="comment">#[1,2,1,1,6]</span></span><br><span class="line">a[:] = [<span class="number">1</span>,<span class="number">1</span>]                            <span class="comment">#[1,1]</span></span><br></pre></td></tr></table></figure><h4 id="步进式切割"><a href="#步进式切割" class="headerlink" title="步进式切割"></a>步进式切割</h4><p>somelist[start:end:stride]</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">odds = a[::<span class="number">2</span>]</span><br><span class="line">evens = a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">b = <span class="string">b'abc'</span></span><br><span class="line">reverse = b[::<span class="number">-1</span>]                       <span class="comment">#负值为反向步进</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>负步长只对字节串和ASCII字符有效，对已编码成UTF-8字节串的Unicode字符无效</li><li>尽量使用stride为正数，且不带start和end索引</li><li>同一切片操作内，不要同时指定start、end和stride，考虑将其拆解为一条步进切割，一条范围切割</li></ul><h3 id="列表与迭代"><a href="#列表与迭代" class="headerlink" title="列表与迭代"></a>列表与迭代</h3><h4 id="用列表推导取代map和filter"><a href="#用列表推导取代map和filter" class="headerlink" title="用列表推导取代map和filter"></a>用列表推导取代map和filter</h4><p><strong>列表推导</strong>(list comprehension)，根据一份列表来制作另外一份。<br><strong>字典</strong>(dict)与<strong>集</strong>(set)也支持推导表达式</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用map，创建lambda函数，结合filter</span></span><br><span class="line">squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br><span class="line">even_squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用列表推导</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="列表推导内含的表达式不宜超过两个"><a href="#列表推导内含的表达式不宜超过两个" class="headerlink" title="列表推导内含的表达式不宜超过两个"></a>列表推导内含的表达式不宜超过两个</h4><p>列表推导支持多重循环</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵简化为一维列表</span></span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]                  <span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]          <span class="comment">#[[1, 4, 9], [16, 25, 36], [49, 64, 81]]</span></span><br></pre></td></tr></table></figure><p>每一级循环也支持多重条件</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处在同一循环级别中的多项条件， 彼此之间默认形成and表达式</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#从矩阵中取出本身能被3整除，且其所在行所有元素之和大于等于10的元素</span></span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] </span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h4 id="用生成器表达式改写数据量较大的列表推导"><a href="#用生成器表达式改写数据量较大的列表推导" class="headerlink" title="用生成器表达式改写数据量较大的列表推导"></a>用生成器表达式改写数据量较大的列表推导</h4><p>首先，列表推导的缺点是：<br>在推导过程中，对于输入序列中的每个值，可能都要创建一个仅含一个元素的新列表，若输入数据量较大，会消耗大量内存。<br>如，读取一份文件并返回每行的字符数，采用列表推导</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file)]</span><br></pre></td></tr></table></figure><p><strong>生成器表达式</strong>(generator expression)：<br>对列表推导和生成器的一种<strong>泛化</strong>(generalization)，生成器表达式运行时，不会呈现整个输出序列，而是估值为<strong>迭代器</strong>(iterator)，该迭代器每次根据生成器表达式产生一项数据。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器表达式，立刻返回一个迭代器</span></span><br><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file))</span><br><span class="line">next(it)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器表达式可以互相组合</span></span><br><span class="line">roots = ((x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure><h4 id="用enumerate取代range"><a href="#用enumerate取代range" class="headerlink" title="用enumerate取代range"></a>用enumerate取代range</h4><p>enumerate可以把各种迭代器包装为生成器，可以在遍历迭代器时获得每个元素的索引，在同时需要下标和值的时候使用。如range</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_num)):</span><br><span class="line">    num = list_num[i]</span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i+<span class="number">1</span>, num))</span><br></pre></td></tr></table></figure><p>使用enumerate</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerator(list_num, <span class="number">1</span>):                  <span class="comment">#起始下标指定为1</span></span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i, num))</span><br></pre></td></tr></table></figure><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><p>Python3中的zip函数，能将两个及以上的迭代器封装为生成器，在遍历过程中逐次产生元组。<br>Python2中，直接产生所有元组，并一次性返回整份列表<br>若提供的迭代器长度不等，zip会提前自动终止</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'adad'</span>, <span class="string">'bob'</span>, <span class="string">'alen'</span>]</span><br><span class="line">letters = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, letter <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    print(name+str(letter))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><center>函数</center></h2><p>函数的问题主要体现在<strong>参数</strong>、<strong>作用域</strong>、<strong>返回值</strong>三个方面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="在闭包里使用外围作用域中的变量"><a href="#在闭包里使用外围作用域中的变量" class="headerlink" title="在闭包里使用外围作用域中的变量"></a>在闭包里使用外围作用域中的变量</h4><p>注意：</p><ul><li>Python支持闭包（closure）：闭包是定义在某个作用域中的函数，可以引用那个作用域中的变量。</li><li>Python的函数时一级对象，可以直接引用函数、将函数赋给变量或者将函数作为参数传递。</li></ul><p>例如，对一份数字列表进行排序，要求出现的特定数字在其他数字排序之前。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sort_priority(numbers, group)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>稍作修改为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">found = sort_priority2(numbers, group)</span><br><span class="line">print(found)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>found的输出结果与预期的True不符，这里我们首先要了解，在表达式中引用变量，Python解释器遵循以下顺序遍历各作用域：</p><ul><li>当前函数作用域</li><li>任何外围作用域（如包含当前函数的其他函数）</li><li>包含当前代码的那个模块的作用域（全局作用域，global scope）</li><li>内置作用域（包含str及len等函数的那个作用域）</li><li>未定义过名称相符变量，抛出NameError异常</li></ul><p>sort_priority2函数中将found赋值为True是在闭包函数helper内进行的，实则是在闭包函数的作用域中定义了一个found变量并赋值为True，与其外围函数sort_priority2作用域中定义的found不同，最后返回的是sort_priority2中赋值为False的found变量。<br>因此，我们需要获取闭包内的数据，可使用nonlocal语句，不支持Python2</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found                  <span class="comment">#声明该found为闭包外围作用域中的found</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>而实际开发中，nonlocal容易遭到滥用，且副作用难以追踪，难以理解，不适用于较长较复杂的函数。有以下两个解决办法：</p><ol><li>将相关状态封装为辅助类<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">            self.found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br><span class="line">print(sorter.found)</span><br></pre></td></tr></table></figure></li><li>用Python的作用域规则，Python2可用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = [<span class="literal">False</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="尽量用异常表示特殊情况，而非返回None"><a href="#尽量用异常表示特殊情况，而非返回None" class="headerlink" title="尽量用异常表示特殊情况，而非返回None"></a>尽量用异常表示特殊情况，而非返回None</h4>例如，两数相除的情况。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:                              <span class="comment">#这种情况没有问题</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:                                  <span class="comment">#错误情况</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure>当分子为0时not result结果为True，结果应为0，却显示Invalid inputs。用异常来表示这种情况：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Result is %.1f'</span> % result)</span><br></pre></td></tr></table></figure><h4 id="用生成器改写直接返回列表的函数"><a href="#用生成器改写直接返回列表的函数" class="headerlink" title="用生成器改写直接返回列表的函数"></a>用生成器改写直接返回列表的函数</h4>若函数产生一系列结果，最简单的方法是返回一个包含所有结果的列表，此方法主要有两个缺点：</li></ol><ul><li>代码拥挤，不清晰</li><li>返回前将所有结果放在列表里，若输入量非常大，会导致内存耗尽</li></ul><p>例如以下函数返回字符串中每个单词首字母的位置。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            result.append(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = index_words(text)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>用生成器改写：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">yield</span> index+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = list(index_words(text))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python自动化控制鼠标和键盘</title>
    <url>/post/Python/auto-gui-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文档：<a href="https://pyautogui.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/</a><a id="more"></a></p><h2 id="安装pyautogui模块"><a href="#安装pyautogui模块" class="headerlink" title="安装pyautogui模块"></a>安装pyautogui模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure><h2 id="鼠标操作模拟"><a href="#鼠标操作模拟" class="headerlink" title="鼠标操作模拟"></a>鼠标操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">width, height = pyautogui.size()            <span class="comment">#返回屏幕宽高像素数的元组</span></span><br><span class="line">pyautogui.position()                        <span class="comment">#返回鼠标当前位置元组</span></span><br><span class="line"></span><br><span class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置移动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.moveRel(<span class="number">100</span>, <span class="number">-1</span>, duration=<span class="number">1</span>)      <span class="comment">#相对位置移动。参数为右,左,时间可选秒数</span></span><br><span class="line"></span><br><span class="line">pyautogui.click(<span class="number">100</span>, <span class="number">200</span>, button=<span class="string">'middle'</span>)    <span class="comment">#完整的单击.默认鼠标左键单击当前位置</span></span><br><span class="line">pyautogui.mouseDown(button=left)            <span class="comment">#按下鼠标按键</span></span><br><span class="line">pyautogui.mouseUp(<span class="number">100</span>, <span class="number">200</span>)                 <span class="comment">#松开鼠标按键</span></span><br><span class="line">pyautogui.doubleClick()                     <span class="comment">#双击鼠标左键</span></span><br><span class="line">pyautogui.middleClick()                     <span class="comment">#单击鼠标中键</span></span><br><span class="line"></span><br><span class="line">pyautogui.dragTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置拖动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.dragRel(<span class="number">100</span>, <span class="number">-1</span>, button=<span class="string">'middle'</span>) <span class="comment">#相对位置拖动。参数为右,左,button可选默认左键</span></span><br><span class="line"></span><br><span class="line">pyautogui.scroll(<span class="number">-200</span>)                      <span class="comment">#鼠标滚轮上下滚动</span></span><br></pre></td></tr></table></figure><h2 id="处理屏幕"><a href="#处理屏幕" class="headerlink" title="处理屏幕"></a>处理屏幕</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">im = pyautogui.screenshot()                 <span class="comment">#返回包含屏幕快照的Image对象</span></span><br><span class="line">im.getpixel((x,y))                          <span class="comment">#返回坐标处像素颜色的RGB元组</span></span><br><span class="line">pyautogui.pixelMatchesColor(x, y, (R, G, B))<span class="comment">#比较(x,y)处与RGB的颜色是否相同</span></span><br><span class="line"></span><br><span class="line">pyautogui.locateOnScreen(<span class="string">'screenshot.png'</span>)  <span class="comment">#参数或为region=(0,0, 300, 400)</span></span><br><span class="line"><span class="comment">#返回screenshot.png匹配当前屏幕成功的图像左边的x坐标，顶边的y坐标，宽度和高度元组</span></span><br><span class="line">pyautogui.center((<span class="number">0</span>,<span class="number">0</span>, <span class="number">300</span>, <span class="number">400</span>))           <span class="comment">#返回中心坐标</span></span><br><span class="line">pyautogui.click((<span class="number">150</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h2 id="键盘操作模拟"><a href="#键盘操作模拟" class="headerlink" title="键盘操作模拟"></a>键盘操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">pyautogui.typewrite(<span class="string">'test'</span>,<span class="number">0.25</span>)            <span class="comment">#发送单个字符表示的虚拟按键,间隔0.25秒</span></span><br><span class="line">pyautogui.typewrite([<span class="string">'a'</span>, <span class="string">'b'</span>])               <span class="comment">#键名作为参数</span></span><br><span class="line"></span><br><span class="line">pyautogui.keyDown(<span class="string">'ctrl'</span>)</span><br><span class="line">pyautogui.press(<span class="string">'c'</span>)</span><br><span class="line">pyautogui.keyUp(<span class="string">'ctrl'</span>)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><p>键名:<a href="https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys</a></p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Auto-GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python处理Excel，CSV和JSON</title>
    <url>/post/Python/excel-csv-json-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Python处理Excel，CSV文件和JSON文件<a id="more"></a></p><h2 id="python处理excel"><a href="#python处理excel" class="headerlink" title="python处理excel"></a>python处理excel</h2><p>文档：<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://openpyxl.readthedocs.io/en/stable/</a></p><h3 id="安装openpyxl模块"><a href="#安装openpyxl模块" class="headerlink" title="安装openpyxl模块"></a>安装openpyxl模块</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> openpyxl</span><br></pre></td></tr></table></figure><h3 id="读取excel"><a href="#读取excel" class="headerlink" title="读取excel"></a>读取excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)     <span class="comment">#返回Workbook对象</span></span><br><span class="line">wb.sheetnames                                           <span class="comment">#返回所有工作表名称的字符串列表</span></span><br><span class="line"></span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]                                     <span class="comment">#wb.get_sheet_by_name('Sheet')</span></span><br><span class="line">sheet1 = wb.active</span><br><span class="line"></span><br><span class="line">sheet[<span class="string">'A'</span>]                                              <span class="comment">#返回第一列</span></span><br><span class="line">sheet[<span class="string">'A1'</span>].value                                       <span class="comment">#.row .column .coordinate(r+c)</span></span><br><span class="line">sheet.cell(row=<span class="number">1</span>, column=<span class="number">1</span>).value</span><br><span class="line">sheet.max_row                                           <span class="comment">#返回一个整数.max_column</span></span><br><span class="line"></span><br><span class="line">openpyxl.cell.column_index_from_string()                <span class="comment">#列字母转换为数字，A→1</span></span><br><span class="line">openpyxl.cell.get_column_letter()                       <span class="comment">#数字转换为列字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切片，遍历</span></span><br><span class="line"><span class="keyword">for</span> rowObj <span class="keyword">in</span> sheet[<span class="string">'A1'</span>:<span class="string">'D14'</span>]:                        <span class="comment">#每个元组代表一行，按行遍历整个区域</span></span><br><span class="line">    <span class="keyword">for</span> cellObj <span class="keyword">in</span> rowObj:                              <span class="comment">#遍历行中的每个单元格</span></span><br><span class="line">        print(cellObj.coordinate, cellObj.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cellObj <span class="keyword">in</span> list(sheet.rows)[<span class="number">0</span>]:                     <span class="comment">#按行按列遍历,或者 sheet[1] | sheet['A']</span></span><br><span class="line">    print(cellObj.value)</span><br></pre></td></tr></table></figure><h3 id="写入excel"><a href="#写入excel" class="headerlink" title="写入excel"></a>写入excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.Workbook()                                <span class="comment">#新建一个空的Workbook对象</span></span><br><span class="line">sheet = wb.active</span><br><span class="line">sheet.title = <span class="string">'test'</span></span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'test'</span>                                    <span class="comment">#将值写入单元格</span></span><br><span class="line"></span><br><span class="line">wb.create_sheet(index=<span class="number">0</span>, title=<span class="string">'ttest'</span>)                 <span class="comment">#新建一个工作表，返回Worksheet对象</span></span><br><span class="line">wb.remove(wb[<span class="string">'Sheet'</span>])                                  <span class="comment">#接受一个Worksheet对象作为其参数</span></span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test.xlsx'</span>)                         <span class="comment">#保存变更，不同名或不同位置会创建副本</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="更新excel表"><a href="#更新excel表" class="headerlink" title="更新excel表"></a>更新excel表</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">update_data = &#123;<span class="string">'apple'</span>:<span class="number">5</span>,</span><br><span class="line">               <span class="string">'lemon'</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="string">'orange'</span>:<span class="number">2</span>&#125;                              <span class="comment">#待更新数据保存在字典中</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)</span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]</span><br><span class="line"><span class="keyword">for</span> rowNum <span class="keyword">in</span> range(<span class="number">2</span>, sheet.max_row+<span class="number">1</span>):</span><br><span class="line">    updatedName = sheet.cell(row=rowNum, column=<span class="number">1</span>).value</span><br><span class="line">    <span class="keyword">if</span> updatedName <span class="keyword">in</span> update_data:</span><br><span class="line">        sheet.cell(row=rowNum, column=<span class="number">2</span>).value = update_data[updatedName]</span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test_updated.xlsx'</span>)</span><br></pre></td></tr></table></figure><h4 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font</span><br><span class="line">fontObj = Font(name=<span class="string">'Calibri'</span>, size=<span class="number">12</span>, bold=true, italic=true)</span><br><span class="line">sheet[<span class="string">'A1'</span>].font = fontObj</span><br></pre></td></tr></table></figure><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="行高列宽"><a href="#行高列宽" class="headerlink" title="行高列宽"></a>行高列宽</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="合并拆分冻结"><a href="#合并拆分冻结" class="headerlink" title="合并拆分冻结"></a>合并拆分冻结</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.merge_cells(<span class="string">'A1:D3'</span>)</span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'merged'</span>                                    <span class="comment">#合并后单元格的值</span></span><br><span class="line"></span><br><span class="line">sheet.unmerge_cells(<span class="string">'A1:A2'</span>)</span><br><span class="line"></span><br><span class="line">sheet.freeze_panes = <span class="string">'A2'</span>                                 <span class="comment">#冻结左上部分</span></span><br></pre></td></tr></table></figure><h2 id="python处理CSV文件"><a href="#python处理CSV文件" class="headerlink" title="python处理CSV文件"></a>python处理CSV文件</h2><h3 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h3><p>csv全称’Comma-Separated Values‘，每行对应电子表格中的一行，单元格之间用逗号分隔。</p><ul><li>值没有类型，全为字符串</li><li>无多个工作表</li><li>不能嵌入图像或图表</li><li>无字体大小和颜色设置</li><li>无法操作单元格，宽高合并等</li></ul><h3 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>)                               <span class="comment">#返回一个File对象</span></span><br><span class="line">fileReader = csv.reader(openFile)                         <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileData = list(fileReader)                               <span class="comment">#fileData[0][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> fileReader:</span><br><span class="line">    print(<span class="string">'row'</span>+str(fileReader.line_num)+str(row))        <span class="comment">#对于大型CSV文件，避免将文件一次性装入内存</span></span><br></pre></td></tr></table></figure><h3 id="Write对象"><a href="#Write对象" class="headerlink" title="Write对象"></a>Write对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>)              <span class="comment">#返回一个File对象</span></span><br><span class="line">fileWrite = csv.writer(openFile)                          <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileWrite.writerow([<span class="number">1</span>, <span class="string">'a,b'</span>, <span class="number">2</span>, <span class="string">'b'</span>])</span><br><span class="line">openfile.close()</span><br><span class="line"></span><br><span class="line">fileWrite = csv.writer(openFile, delimiter=<span class="string">'\t'</span>, lineterminator=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="comment">#delimiter指定分隔符 lineterminator指定行终止符，默认\n</span></span><br></pre></td></tr></table></figure><h2 id="python处理JSON文件"><a href="#python处理JSON文件" class="headerlink" title="python处理JSON文件"></a>python处理JSON文件</h2><p>JSON文件，全称JavaScript Object Notation，是JavaScript程序编写数据结构的原生方式，<br>JSON不能表示Pyton特有的对象，可以存储：字符串、整型、浮点型、布尔型、列表、字典和NoneType。</p><h3 id="loads"><a href="#loads" class="headerlink" title="loads()"></a>loads()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">jsonString = <span class="string">'&#123;"name":"asher", "isCat":true, "num":1&#125;'</span></span><br><span class="line">jsonData = json.loads(jsonString)                         <span class="comment">#返回一个Python字典</span></span><br></pre></td></tr></table></figure><h3 id="dumps"><a href="#dumps" class="headerlink" title="dumps()"></a>dumps()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">pythonData = <span class="string">'&#123;'</span>name<span class="string">':'</span>ashe<span class="string">r', '</span>isCat<span class="string">':True, '</span>num<span class="string">':1&#125;'</span></span><br><span class="line">jsonString = json.dumps(json)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Excel</tag>
        <tag>CSV</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式复习</title>
    <url>/post/tech/regex-review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式复习<a id="more"></a></p><h2 id="常用方法-参数"><a href="#常用方法-参数" class="headerlink" title="常用方法,参数"></a>常用方法,参数</h2><h3 id="group-and-findall"><a href="#group-and-findall" class="headerlink" title="group() and findall()"></a>group() and findall()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexDemo = re.compile(<span class="string">r'(\d)-(\d)'</span>) <span class="comment">#返回Regex对象, </span></span><br><span class="line">                                     <span class="comment">#r为原始字符串\不转义, </span></span><br><span class="line">                                     <span class="comment">#匹配括号须转义\(</span></span><br><span class="line">demo = regexDemo.search(<span class="string">''</span>) <span class="comment">#返回Match对象,仅包含第一次出现的文本</span></span><br><span class="line">demo1 = regexDemo.findall(<span class="string">''</span>) <span class="comment">#无分组返回一个字符串列表，有分组返回一个包含元组的列表，</span></span><br><span class="line">                              <span class="comment">#每一个元组对应一个字符串</span></span><br><span class="line">demo.group(<span class="number">0</span>) <span class="comment">#0 all but one, 1 first group, .groups() all</span></span><br></pre></td></tr></table></figure><h3 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">regexDemo</span><span class="selector-class">.sub</span>(<span class="string">'sub'</span>,<span class="string">'subed'</span>) <span class="selector-id">#sub</span>替换<span class="selector-tag">subed</span>里匹配的字符串</span><br></pre></td></tr></table></figure><h3 id="re-DOTALL"><a href="#re-DOTALL" class="headerlink" title="re.DOTALL"></a>re.DOTALL</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.DOTALL) <span class="comment">#可以匹配换行符</span></span><br></pre></td></tr></table></figure><h3 id="re-IGNORECASE-I"><a href="#re-IGNORECASE-I" class="headerlink" title="re.IGNORECASE/I"></a>re.IGNORECASE/I</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.I) <span class="comment">#不区分大小写</span></span><br></pre></td></tr></table></figure><h3 id="re-VERBOSE"><a href="#re-VERBOSE" class="headerlink" title="re.VERBOSE"></a>re.VERBOSE</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'''</span></span><br><span class="line"><span class="string">            .*  #test</span></span><br><span class="line"><span class="string">            \d+ #test1</span></span><br><span class="line"><span class="string">            '''</span>, re.VERBOSE) <span class="comment">#忽略regex中的空白符和注释 组合参数用 |</span></span><br></pre></td></tr></table></figure><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><h3><a href="#" class="headerlink" title="|"></a>|</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'a | b'</span>) <span class="comment">#匹配a或者b，同时出现匹配前者</span></span><br><span class="line">re.compile(<span class="string">r'a(aple | nchor)'</span>) <span class="comment">#匹配同一前缀</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)?man'</span>) <span class="comment">#匹配?前的分组wo零次或一次</span></span><br><span class="line">re.compile(<span class="string">r'bat(wo&#123;,5&#125;?)man'</span>) <span class="comment">#后加?表示非贪心匹配,最少0次</span></span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="*"></a>*</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配*前的分组wo零次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="+"></a>+</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配+前的分组wo一次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title="{}"></a>{}</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)&#123;,5&#125;man'</span>) <span class="comment">#匹配&#123;&#125;前的分组wo指定次数(范围), 例中为0到5次 默认贪心匹配</span></span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title="^,$"></a>^,$</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[^bat]'</span>) <span class="comment">#匹配不包含^后的任意字符,如batman匹配mn</span></span><br><span class="line">re.compile(<span class="string">r'^\d+$'</span>) <span class="comment">#匹配从开始到结束都是数字的字符串</span></span><br></pre></td></tr></table></figure><h2 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h2><p>自定义</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[0-9a-z]'</span>) <span class="comment">#[]内不需要转义</span></span><br></pre></td></tr></table></figure><h3 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.at'</span>) <span class="comment">#匹配除换行外的任意一个字符，如cat，bat</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><tbody><tr><td>\d 0-9的任何数字</td><td align="center">\D 除0-9外的任何字符</td></tr><tr><td>\w 任何字母、数字和下划线</td><td align="center">\W 类比</td></tr><tr><td>\s 空格、制表符或换行符</td><td align="center">\S类比</td></tr></tbody></table></div><h2 id="常用Regex"><a href="#常用Regex" class="headerlink" title="常用Regex"></a>常用Regex</h2><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">emailRegex</span> = re.compile(r<span class="string">'''(</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9._%+-]+</span></span><br><span class="line"><span class="string">    @</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9.-]+</span></span><br><span class="line"><span class="string">    \.[a-zA-Z]&#123;2,4&#125;</span></span><br><span class="line"><span class="string">    )'''</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础</title>
    <url>/post/Python/Python-basis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python基础</p><a id="more"></a><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>指数:<code>2**3=8</code><br>取整:<code>22/8=2</code> <code>22/8=2.75</code><br>表达式=操作符+值（可归约为一个值）<code>！=</code>语句<br>布尔操作符:and,or,not</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整型(int),<br>浮点型(float),<br>字符串(str) ,<br><code>&#39;a&#39;+&#39;b&#39;=&#39;ab&#39;</code><br><code>&#39;a&#39;*3=&#39;aaa&#39;</code><br>布尔(Boolean),</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><code>spam = input() //返回字符串类型</code><br><code>len(&#39;&#39;) //返回整型</code><br><code>str(),int(),float() //只能进行一次类型转换，如int(&#39;0.1&#39;)不正确 int(0.1)=0</code></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line"><span class="built_in">os</span>.getcwd()                         #当前工作目录</span><br><span class="line"><span class="built_in">os</span>.chdir(<span class="string">'C:\\users'</span>)               #更改路径</span><br><span class="line"><span class="built_in">os</span>.makedirs(<span class="string">'C:\\users\\test'</span>)      #创建目录</span><br><span class="line"><span class="built_in">os</span>.listdir(<span class="string">''</span>)                      #返回路径中包含的所有文件及文件夹的字符串列表</span><br><span class="line"></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'usr'</span>,<span class="string">'bin'</span>,<span class="string">'spam'</span>)    #usr\bin\spam</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'C:\\users'</span>,<span class="string">'a.txt'</span>)   #C:\users\a.txt</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.abspath(<span class="string">''</span>)                 #返回参数的绝对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isabs(<span class="string">''</span>)                   #参数为绝对路径返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.relpath(<span class="built_in">path</span>, start)        #返回从start路径到<span class="built_in">path</span>的相对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.dirname(<span class="string">''</span>) </span><br><span class="line">+ <span class="built_in">os</span>.<span class="built_in">path</span>.basename(<span class="string">''</span>)              #<span class="string">'C:\\users'</span>+<span class="string">'test.exe'</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.split(<span class="string">''</span>)                   #返回包含dirname和basename的字符串元组</span><br><span class="line"><span class="string">''</span>.split(<span class="built_in">os</span>.<span class="built_in">path</span>.sep)               #返回一个包含路径中各文件夹名称的字符串列表</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.getsize(<span class="string">''</span>)                 #返回文件的字节数</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.exists(<span class="string">''</span>)                  #文件或文件夹存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isfile(<span class="string">''</span>)                  #文件存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isdir(<span class="string">''</span>)                   #文件夹存在，返回True</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">file1</span> = open(<span class="string">''</span>，<span class="string">'w'</span>)               <span class="comment">#返回一个File对象，w写模式，a添加模式，r读模式</span></span><br><span class="line"><span class="attr">fileContent</span> = file1.read()</span><br><span class="line"><span class="attr">fileContent</span> = file1readlines()</span><br></pre></td></tr></table></figure><h3 id="文件复制删除"><a href="#文件复制删除" class="headerlink" title="文件复制删除"></a>文件复制删除</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import shutil,<span class="built_in">os</span></span><br><span class="line">shutil.copy(source, destination)    #复制单个文件，destination为文件名则复制后改名，下同</span><br><span class="line">shutil.copytree(source, destination)#复制整个文件夹及其包含的文件和文件夹</span><br><span class="line">shutil.move(source, destination)    #移动单个文件，同名会复写</span><br><span class="line"><span class="built_in">os</span>.unlink(<span class="built_in">path</span>)                     #永久删除<span class="built_in">path</span>处的文件</span><br><span class="line"><span class="built_in">os</span>.rmdir(<span class="built_in">path</span>)                      #永久删除<span class="built_in">path</span>出的文件夹，必须为空</span><br><span class="line">shutil.rmtree(<span class="built_in">path</span>)                 #永久删除<span class="built_in">path</span>处的文件夹及其包含的文件及文件夹，可用send2trash</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">rename</span>(oldname,newname)          #用<span class="built_in">os</span>模块中的<span class="built_in">rename</span>方法对文件改名</span><br></pre></td></tr></table></figure><h3 id="变量保存"><a href="#变量保存" class="headerlink" title="变量保存"></a>变量保存</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import shelve, pprint</span><br><span class="line">shelfFile = shelve.<span class="built_in">open</span>(<span class="string">''</span>)         <span class="comment">#用shelve模块保存变量</span></span><br><span class="line"><span class="built_in">value</span> = [<span class="string">''</span>,<span class="string">''</span>]</span><br><span class="line">shelfFile[<span class="string">'keys'</span>] = <span class="built_in">value</span>           <span class="comment">#将value列表保存在shelfFile中，关联keys键值</span></span><br><span class="line"><span class="comment">#pprint.pformat(value)              #将value列表转换为字符串写入文件</span></span><br><span class="line"><span class="comment">#shelfFile.write('')                </span></span><br><span class="line">shelfFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><h3 id="文件夹遍历"><a href="#文件夹遍历" class="headerlink" title="文件夹遍历"></a>文件夹遍历</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">os</span>.walk(path)                       <span class="comment">#返回path的当前文件夹名称的字符串，foldername</span></span><br><span class="line">                                    <span class="comment">#当前文件夹子文件夹字符串列表，subfoldernames</span></span><br><span class="line">                                    <span class="comment">#当前文件夹中的文件的字符串列表,filename</span></span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h3><p>异常发生时finally块的代码必定执行，可用于异常发生时执行清理工作，如确保程序能可靠的关闭文件句柄。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">handle = open(file)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = handle.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    handle.close()</span><br></pre></td></tr></table></figure><h3 id="else块"><a href="#else块" class="headerlink" title="else块"></a>else块</h3><p>try块没有发生异常，就执行else块的代码。如从字符串中加载JSON数据，返回字典中某个键对应的值。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_json_key</span><span class="params">(data, key)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_dict = json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> KeyError <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result_dict[key]</span><br></pre></td></tr></table></figure><h3 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test = <span class="string">'ok'</span></span><br><span class="line"><span class="keyword">assert</span> test == <span class="string">'ok'</span>, <span class="string">'The test need to be ok'</span>           <span class="comment">#解决赋值出错的定位问题</span></span><br></pre></td></tr></table></figure><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging                                          <span class="comment">#等级：DEBUG &lt;INFO &lt;WARNING &lt;ERROR &lt;CRITICAL</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">''</span>,level=logging.DEBUG, format=<span class="string">' %(asctime)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">logging.debug(<span class="string">'debug'</span>)</span><br><span class="line">logging.info(<span class="string">'info'</span>)</span><br><span class="line">logging.disable(logging.CRITICAL)                       <span class="comment">#禁用CRITICAL及以下等级的所有消息</span></span><br></pre></td></tr></table></figure><h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><h3 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h3><p>返回自Unix纪元，即协调世界时间（UTC）：1970年1月1日0点 以来的秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#简单测试程序执行时间</span></span><br><span class="line">startTime = time.time()</span><br><span class="line">function()</span><br><span class="line">endTime = time.time()</span><br></pre></td></tr></table></figure><h3 id="time-sleep"><a href="#time-sleep" class="headerlink" title="time.sleep()"></a>time.sleep()</h3><p>参数为秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#for循环中sleep，按下CTRL+C可以停止并抛出KeyboardInterrupt异常</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.125</span>, <span class="number">2</span>)                                         <span class="comment">#四舍五入至两位小数，不填则到整数</span></span><br></pre></td></tr></table></figure><h3 id="datetime-datetime"><a href="#datetime-datetime" class="headerlink" title="datetime.datetime()"></a>datetime.datetime()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.year&gt;dt.microsecond                                  <span class="comment">#datetime对象支持四则和比较操作符</span></span><br><span class="line">datetime.datetime.fromtimestamp(time.time())</span><br></pre></td></tr></table></figure><h3 id="datetime-timedelta"><a href="#datetime-timedelta" class="headerlink" title="datetime.timedelta()"></a>datetime.timedelta()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">daysAfter = datetime.timedelta(days=<span class="number">13</span>)</span><br><span class="line">print(dt+daysAfter)                                     <span class="comment">#13天后的日期</span></span><br></pre></td></tr></table></figure><h3 id="datetime-strftime-和strptimr"><a href="#datetime-strftime-和strptimr" class="headerlink" title="datetime.strftime()和strptimr()"></a>datetime.strftime()和strptimr()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>)                        <span class="comment">#datetime对象转换成字符串</span></span><br><span class="line">datetime.datetime.strptime(<span class="string">'2015/10/21 16:29:00'</span>, <span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/02/17/3C1sYt.jpg" alt=""></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line">print(<span class="string">'Start of program.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeANap</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'Wake up!'</span>)</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=takeANap)</span><br><span class="line">threadObj.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'End of program.'</span>)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Start of program.</span><br><span class="line">End of program.</span><br><span class="line">Wake up!</span><br></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=<span class="keyword">print</span>, args=[<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>],kwargs=&#123;<span class="string">'sep'</span>: <span class="string">' &amp; '</span>&#125;)</span><br><span class="line">threadObj.start()</span><br><span class="line">print(<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>, sep=<span class="string">' &amp; '</span>)                <span class="comment">#args常规参数，kwargs关键字参数</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="批量有序重命名文件"><a href="#批量有序重命名文件" class="headerlink" title="批量有序重命名文件"></a>批量有序重命名文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,re</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">path = <span class="string">'C:\\Users\\Desktop\\test\\'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    fileregex = re.compile(<span class="string">r'\.\w*'</span>)                    <span class="comment">#取得后缀名</span></span><br><span class="line">    extension = <span class="string">''</span>.join(fileregex.findall(file)[<span class="number">-1</span>:])   <span class="comment">#列表转换为字符串</span></span><br><span class="line">    newName = str(num)+extension</span><br><span class="line">    <span class="keyword">if</span> extension == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span>                                        <span class="comment">#过滤掉文件夹</span></span><br><span class="line">    os.rename(path+file, path+newName)</span><br><span class="line">    num = num+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT解决点进文章自动下滑到&lt;!-- more --&gt;后面</title>
    <url>/post/Hexo/hexo_issues/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hexo 版本v4.0.0 | 主题 – NexT.Gemini v7.6.0<br>若使用<code>&lt;!-- more --&gt;</code>标签来截取文章概要，当点击全文时，文章链接后会加上#more使页面自动下滑到<code>&lt;!-- more --&gt;</code>的后面<a id="more"></a><br>不想使用这一特性，有以下2个办法<br>1.找到<code>themes\next\layout\_macro</code>下的post.swig文件，将</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;#more"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里的#more删除，即</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.将主题配置文件中的<code>scroll_to_more: true</code>改为<code>scroll_to_more: false</code>这个方法对我没用，可能NexT在新版本中移除了这项配置<br>其他问题可以参考<a href="https://github.com/theme-next/hexo-theme-next/issues" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues</a>以及官方文档<a href="https://hexo-theme-next.netlify.app/" target="_blank" rel="noopener">https://hexo-theme-next.netlify.app/</a></p>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>死亡日记</title>
    <url>/post/Life/daliy/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c3d45676453ffee4776539b61fbebb83f5804ff7526a98812eab805923a6490e">5052a65d98f5b2298cedff0f1d1d501bed1f97ef5ba2db09796c0adabdfaf78d7998413a1efd8358221496574e82442b8b0805c0ca28a1ee879362a9df93da3759869d196edf3f9ffb342c2802ffb3bd60647af6801905232ed3203de2c3bb334205863506e0eb36b26ef15c79e7d7a7491d14b0142570f29fd4327ae5d05cd09510e14b0ba50f1a8ab65cadf8844434c357ed39b1dbe3e01ac5e9b3c9fcac5645d6c840497e9bc78eae94b637d51f2ba24ad46defcc424bb02975ec596a3bf2d00d86fc115752c5558200dd1f7d18dd6585f19f5914e7214fd77ac830b7a2c030989a27d3533529b91e24a943d0aba28b12e980e609ea13131659b328e2ed1dd39acfa72d7154062e165d98f7518f8dee61aa98cbe82ee65327ca359959b9510f5db4dcbf39b3f885fdf49e2244b4f059128118fcf683e0175a0023ddaf0afc8bd2bcf7c486b577d4741ae6d0e963f3f58e97bceb4e740bfc88b90bc2efe380bf6fe0c9264361e81d575f3807df3f19f0588b4b6622c43872cf915fff127260080d5b3936e553baa53f5c7c9faa5a90635b70de1d293bf2c78896f64ba5522871f3cfb816328f0673573f5c0c253d08a5e06f2c9e0ab24c17b3b289054dec9c955df1ed8dc2e147e1ae4fc2f78a54b17f1a332325c0d2386d97ddf7eda71702e2b17508e603e8cc17eb5fd57c49f62ab8b4fe9f1a11664a59f9c37245e4a590b6b931df6cc87a7c5e3869e1fe0f9a3e7ac7030e4d3e2c8b978d63a30a633763b38a5ea07a48764f1088881b738c7df5765367be578d6fde7515d79f8cdd9e06db9efe703ffe53dd5c4a8e75eefc37106160c237104791fd45d284d36f1a7feded7d272bc7d29faa9777c18560c76ef4e92c68c9b9e1a6be91e04b1e3e7a05321e280d6685136fd920d1c96b9767d294de40fbf21bf9f8b9b828017387882afc7690e4b4ef0a7f736b9a62e6b5e808cdbf20d66710a6c8496bc7ce968ecd1ffab82849e6adf972eac1b55769c07723d1aa8c8c02519474e31495288d6b9aecce70585005b9475dda507e3f3611ff3de07ae7813d9d7a26e239a1e4b56950bba0aff9f59b92d77e351e3ff4defc15126bd765bfa2f263cde2ef4169338362d07408e0da907cbcd461eb1de4bb8334d48df2d4a16c06b6f198f003994eff0baaecc78ec1fd786256d9ed07c040fe8233e8388f9d2ceb7e4d444c70c41c1c89510dc9a2970db660dcc33daea6b0777b7cb18b2f82ac425099c690f125125cedfae4ce769d78e962e3f5ea7980e16510ac467b9994f8c1a6c7f5ffabaf2a00308ca0fede9c718279d54df5faf4762692031206d0b2bcfadc8e05560920ae6c7bdf7b70842a09e36de676959989801e239b6a3a4e349bc90f122cfc9c1e533c54426eca899842b6d0749c2ef2b571b9c9064eeaf33476fd480c78973344e366695aee9383eca0bc42f1d6f3746f55af8456c40e536ab39df66e06caf9c6cf1e7d6c3557c93fd49df2be340ed7037d910f8711706bc6732a1423bc89c03955ea12580c77adf1f541097ab142447b9c394ceb8664f549ec02f26b6c8a18c1b9093e85dd5ccf0f6dc990b18c9a0a66b518138183dc96b5ff4b355b889efb649304f46227a6736416e92d9568421b71ec5292b61ae45cfc00bc35ca6a2a8b649c865fed87f11455ec2b9a43a7eef64d365197537bd7628cbc6d54b72417857b474a7b8b04aa0d541727341b0f7215778dcf4cce1a5f679f468b14e62cca7c7d40c4e63f4879695d5969b8bc4c57bec9a4956c0c8366a68b57b40f503a94930e73984454fbeea112231878a6f9cdfe808a3dddd294ecfe7366737a59a6e7d046c9dce658ef96310974b3812840460efced1a714e423edb684de20156a26c68f25ffaaab66a43a71c9cfaaf86b32d647d3d01c3bb12b337b8df8f5309a70f16ab439fd969cb0820baa36ca6deb8b7635c12bf88624ef720ff0a5f4ae2fadf7a58d7201b2ba8bfeb17a715606d9054c967014945500a2c4f74bc32fb03b381bbe4561717c16c6242d9c427f1f0dd92d04e9fd3f60d3df5a4b6c8fbea3a525f0eadbee23f43f0595d292970ce8cd702aca1240631b4484b7e1e22cf68656ccf89f01035beb9912f8ffa8047ed75f8d7ed76be9ebcee97e9f2604ca76c7dce23b1413453c8f7f1200b0fe501041e63f3fd81d312e747e9f6e721caa1a15db19ab0c2bc138fb1dedab610c953727d3ec30608ec991ab6540b52d08446c62eb4ba5cc0ae146e146c6d925d8f1b6ef4fadac6935a73a8a9e0f6b9c6219e880c0167caa859a6ec210beb02e3d0aa82d5348d82a081b4dadd8788e4595e7b26b6de0b9e60bbcc465c356e42fca92c4772fd898d38e4be18edd6e50df7531e5f385edb28aa38c962d69b230d4648a63c543ec678582f68cf746379bc8ef1e71aa3c4cc126400efc33d7c69125cb191b556a89e5c7108396921c64c275d9bf2b8fa328e28b83cc82057ad009133b3faa409b94c96af52f0b7107e82909dbf1273ff4a04a84343cde6b89a2cd0dba93b7d5bcfd8309e02fb08393eadc10cb026e46bcd93c68ef6227e70a07eefa8a372a6a2de1dce77dd5539e823dd2012bb910be4deaa218df6b966b4c7d314bd90550173d3e3988a54202fe6e715ec32b6ea095be046bcc496f1339f8c15e6500a3db9fe0929405814b7a9acf485d92890497b36b52822b68390a3020565a512c788830da3af52707965aacced0ff547ec8fec834afb86604e153d7aa055db9ba8880c41fcdfcbe1d3402c831773fcc8fec69da7f7e593e7968cbbbbe86a3fbe1dd7d43951414a9400652cfbed5a25ca50b8233f02e63b69da2f0131b17f3b7449db90519916014651d630aff1437acc9cda6414d01e52d25f8e7556c0ce3768a4b79ce41d8d154a8e725a66438f1d27c008da9d1cec01303a325539843cd8b95eb4463cdcf33c5def96ae01458dc42b4b1afb202ae76cb29baaf783f8d00ebcb29e09131e44fb82364e1e3e5fe868e565c1c0a214bb88d118ae4a7013f28b6809c03753bcc63e42b68bc28a9448eb347f3ae8d8986998ce74a165130b3811aca337c33516550f7e4182674624e2d756477c4ef4f665f92f4dc68ac83119fd754233d5c663065be239da7531e3dfef6378f9337af72db4ee07416c582cefe751edc5c9bf59e224839710a1f0f8a4e6f96507f74e41a6943980d382ca35ebacd3aaab9c5a05d560b2f89af22b99a4f61e749e23a05c62bb73217cb543459878016d5240dea28c213dc186cfe436043e3a96ebcfc402c3953d3535e36d499064e320ec8e3d83538e50b4a7d2abe40368fdc69cad357d1f20c9c9f59ec018d31afea94b7708b47dd3a9641b52a1ac3ecc866077f666270c9519a6f7426f532cb7590dd8597e855fb5c65b0aac3349ebc6ad7109e5c022416f1e67a5577da2c622e2a2fc701f538f7de7309a256c0887822f64ca308f9423982ab19442935747043369a3b865802b5501969d3c17cfd05679ed1473a237f330977a55dbe296076c09fc1d74661cdea3011f82621ebc3fa8ccf3024c5c449256092c48259c92ee19e4a0e59741289ee6dbae8aa300f2b1e2ca0e439552a2b33c812b3a6185200cbcae74f5e92ad6a1fefcd7ba706480b197651a8849d855769aaa0051db095706fe6a7285197dc0b88a3e336a1a0cadd16c9fc5b365839bd80e169037de35693331a1a2de3233d14f6e8d4d54b03dcfe0869560dd51924c90a527d707f09f32224ebab3e41faef7dfd560702a382285b02cd929de8f89ca1c749bad73d14026e2cd77773ba44a582e8426ba55f150a2e745ae75de4b82481167232ca7cbb2303ea6e97ca5995e71006a859472ca58709ce6de1779390d4518a2f917a9acca7daa8156aa0883f60e81969ebf55b1909ccb08370618cbcda030255506407fe26fba477a29fd177aa519fbfcfd531f828aacc91c94fd1747c43d6f0a996fe4bb6e35f3eaf97a00f7ffbc80980c9bd2d59b8df2bd84ba8c1bfa5ba8f59e9786870d966277481143a654a93bd509a33e1447741ddf11b4dc69ae1187bd710bec072861de8804e2d954f99e01e9207380706dbf14d00502b84e5448bcbe71e7e222a6f703f2ec8ee899e8b9216ff39fc5ee342a649d75377dfc0aa93cc18d88526f340c5648a89f947f4c931c1dfa32fd4bec0d9e3e4109b4af596105e99cc6c9df6ea000ab168118b1a01c88126c1e526ff0cab1900ffd2a27946683a31bf503b06c03209bf57fe60c44991ed690a2454c2cb86cf9cbd13ced141444038e00fc8357789e2fdd2c713fd684341e9c532b96bdb485ddb4c2d2a9618d60bba78a45b0961f8f4adab1f14894f848a5c23fdbf13ccd5e5a37b68dc36677deac90e703e0d913e35cb47abde179b82d48411bf35fe818066f2f044aedfd93215bf5bd7046b0fb999fffe72afd2be6bf97511ba02acfa4d2204a3e94f269a40e723a1e794cded697fb62862fb285d4d6fda6bdbe471b547d926a9e3033c11586d58c1c4bf522ca556fdaf895cce703e6b09b0d43d18bc37305e4752da63c1f7f7cd488c4ce383280896b8a3c9250a675406d62b0c2ccc791713d53cd4eae095396fb4beeab7523e79179ca815e27515f6249a00ae8234b31d2bdc1f83ef5bf952435c152d9bfbe7ce55e7a838e63d04e46b6eee8def2ab8fc5c1887ab2d7cf186fd49453eed20a2bf484a30fedf82b7d296a7c4a30ae6698baa29fe20497b5e1e6c4c7f25410d6b99a69dac2dafc7135f91c5af4c20825e1c676a5df768d2108f696b8f29cd93c0b39234e70ddc16354b5181d61f5bbff4ea4e133f97551a85696e3804f89d9d474a3d262b40ea04746427df6135638805e91e11aa8f4bc7778c6b21d465fc35879c206b2183f99fbdd70c8ba30abc50f93e5f43dc464928092b9078dcda88627008ede2381537c9348f4ff4dde524ae0abbe2edf1826adf6123c50cbb760e51a132c09f3e2a1a0a798f4adce722725</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
</search>
