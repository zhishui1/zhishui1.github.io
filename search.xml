<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《Redis开发与运维》笔记</title>
    <url>/post/Redis/redis-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Redis开发与运维》学习笔记<a id="more"></a></p><h2 id="Ch-1-初识Redis"><a href="#Ch-1-初识Redis" class="headerlink" title="Ch 1 初识Redis"></a>Ch 1 初识Redis</h2><p>Redis（REmote Dictionary Server）——一种基于键值对的NoSQL数据库。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul><li><strong>速度快</strong><ul><li>所有数据存放在内存中。</li><li>基于C语言实现。</li><li>单线程架构。</li><li>源代码优化好。</li></ul></li><li><strong>基于键值对的数据结构服务器</strong><ul><li>Redis的值主要支持5种数据结构：字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）。</li><li>同时在字符串基础上演变了位图（Bitmaps）、HyperLogLog以及GEO（地理信息定位）等数据结构。</li></ul></li><li><strong>丰富的功能</strong><ul><li>键过期功能，实现缓存。</li><li>发布订阅功能，实现消息系统。</li><li>支持LUA脚本功能，用LUA创造出新的Redis命令。</li><li>简单的事务功能。</li><li>流水线功能，客户端能将命令一次性传到Redis。</li></ul></li><li><strong>简单稳定</strong><ul><li>源码相对较少。</li><li>使用单线程模型。</li><li>不依赖OS中的类库。</li><li>自己实现了事件处理的相关功能。</li></ul></li><li><strong>客户端语言多</strong><ul><li>提供简单的TCP通信协议</li><li>支持Java、PHP、Python、C、C++、Nodejs等. <a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a></li></ul></li><li><strong>持久化</strong><ul><li>RDB和AOF。</li></ul></li><li><strong>主从复制</strong><ul><li>分布式Redis的基础，实现多个相同数据的Redis副本。</li></ul></li><li><strong>高可用和分布式</strong></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>缓存</li><li>排行榜系统（列表和有序集合）</li><li>计数器应用（播放数、浏览数等）</li><li>社交网络（赞踩、粉丝、共同好友等）</li><li>消息队列系统</li><li>数据规模不宜过大、适用热数据（经常访问）</li></ul><h3 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h3><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><p><a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.redis.io/releases/redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-6.0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-6.0.9 redis   <span class="comment">#创建软链接</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>若显示 <code>install: 无法创建普通文件&#39;/usr/local/bin/redis-server&#39;: 权限不够</code><br>则执行<code>su root</code>获取root权限<br>不记得密码执行<code>sudo passwd root</code>修改密码<br>安装成功查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -v</span></span><br><span class="line">redis-cli 6.0.9</span><br></pre></td></tr></table></figure><h4 id="Redis配置、启动、操作和关闭"><a href="#Redis配置、启动、操作和关闭" class="headerlink" title="Redis配置、启动、操作和关闭"></a>Redis配置、启动、操作和关闭</h4><ul><li>三种启动方式<ul><li>默认配置启动<code>redis-server</code></li><li>运行启动（加上需修改的参数）<code>redis-server --port 6380</code></li><li>配置文件启动<code>redis-sever /opt/redis/redis.conf</code></li></ul></li><li>Redis命令行客户端<ul><li>交互式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set good day</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>命令方式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 get good</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li></ul></li><li>停止Redis服务<br><code>redis-cli shutdown</code> （可选参数nosave|save是否生成持久化文件）</li></ul><h2 id="Ch-2-API的理解和使用"><a href="#Ch-2-API的理解和使用" class="headerlink" title="Ch 2 API的理解和使用"></a>Ch 2 API的理解和使用</h2><h3 id="基础知识、操作"><a href="#基础知识、操作" class="headerlink" title="基础知识、操作"></a>基础知识、操作</h3><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><ul><li>查看所有键<br><code>keys *</code><br>keys命令会遍历所有键，时间复杂度为O（n），线上环境禁止使用。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "good"</span><br><span class="line">2) "hello"</span><br></pre></td></tr></table></figure></li><li>键总数<br><code>dbsize</code><br>直接获取Redis内置的键总数变量，时间复杂度为O（1）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>检查键是否存在<br><code>exists key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists no_hello</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>删除键<br><code>del key1 key2 key3~</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del good hello</span><br><span class="line">(integer) 2                       #返回成功删除键的个数</span><br></pre></td></tr></table></figure></li><li>键过期<br><code>expire key seconds</code><br>对键添加过期时间，过期自动删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire hello 10   #单位：s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) 5                       #剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl hello</span><br><span class="line">(integer) -2                      #-2键不存在，-1键为设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li>键的数据结构类型<br><code>type key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; type a</span><br><span class="line">none</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h4><p>优点：改进内部编码而不影响外部数据结构和命令，适应各种场景更加灵活，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjAmUx.png" alt=""></p><h4 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h4><ul><li>单线程首先不会出现并发问题，可以简化数据结构和算法的实现，并且避免了线程切换和竞态产生的消耗，但不适合某个命令执行时间过长的场景。</li><li>纯内存访问，重要基础。</li><li>非阻塞I/O，使用epoll作为I/O多路复用技术的实现以及自身事件模型，如图。<br><img src="https://s3.ax1x.com/2020/12/31/rjnP8x.png" alt=""></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Redis最基础的数据结构，键是字符串类型，字符串类型的值可以是字符串（JSON、XML等）、数字、二进制，值最大不能超过512MB。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>常用命令<ul><li>设置值<br><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code><br>ex seconds：为键设置秒级过期时间。<br>px milliseconds：为键设置毫秒级过期时间。<br>nx：等价于<code>setnx key value</code>，键必须不存在才能设置成功，用于添加（可以用于实现分布式锁）。<br>xx：等价于<code>setex key seconds value</code>，键必须存在才能设置成功，用于更新。</li><li>获取值<br><code>get key</code></li><li>批量设置值<br><code>mset key value key value···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li>批量获取值<br><code>mget key key key···</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget a b c d</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure></li><li>计数<br><code>incr key</code><br>用于对值做自增操作。<br>值必须是整数.<br>键不存在，按值为0自增，返回结果为1。<br>还有：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">decr key                    #自减</span><br><span class="line">incrby key incerement       #自增指定数字</span><br><span class="line">decrby key decrement        #自减指定数字</span><br><span class="line">incrbyfloat key incerement  #自增浮点数</span><br></pre></td></tr></table></figure></li></ul></li><li>不常用命令<ul><li>追加值<br><code>append key value</code><br>向字符串尾部追加值</li><li>字符串长度<br><code>strlen key</code><br>返回字节数</li><li>设置并返回原值<br><code>getset key value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset nice day</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset nice try</span><br><span class="line">"day"</span><br></pre></td></tr></table></figure></li><li>设置指定位置的字符<br><code>setrange key offset value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure></li><li>获取部分字符串<br><code>getrange key start end</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line">"be"</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>int<br>8个字节的长整型。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 8653</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure></li><li>embstr<br>小于等于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure></li><li>raw<br>大于39个字节的字符串。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key "hello world···"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>缓存功能<br>Redis作为缓存层，MySQL作为存储层，如下图。<br><img src="https://s3.ax1x.com/2020/12/31/rvp9KI.png" alt=""><br>例如下面用于获取用户信息的伪代码。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id</span><br><span class="line">  value = redis.get(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">    userInfo = deserialize(value);    <span class="comment">#反序列化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo != null)</span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));   <span class="comment">#一小时过期时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">long incrVideoCounter(long id) &#123;</span><br><span class="line">  key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">  <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>共享Session<br>分布式Web服务使用Redis将用户的Session进行集中管理。<br><img src="https://s3.ax1x.com/2020/12/31/rvEkCV.png" alt=""></li><li>限速<br>例如网站限制一个IP地址在一定时间内的访问次数等。<br>用户获取验证码一分钟不超过5次的伪代码如下。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line">// SET key value EX <span class="number">60</span> NX</span><br><span class="line">isExists = redis.set(key,<span class="number">1</span>,<span class="string">"EX 60"</span>,<span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != null || redis.incr(key) &lt;=<span class="number">5</span>)&#123;</span><br><span class="line">  // 通过</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  // 限速</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>键值本身又是一对键值对结构，形如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = &#123;&#123;filed1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul><li>设置值<br><code>hset key filed value</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取值<br><code>hget key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">"tom"</span><br></pre></td></tr></table></figure></li><li>删除field<br><code>hdel key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:1 name age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li>计算field个数<br><code>hlen key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li>批量设置或获取filed-value<br><code>hmset key filed1 value1 filed2 value2</code><br><code>hmget key filed1 field2...</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:1 name tom age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name age</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>判断filed是否存在<br><code>hexists key filed</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li>获取所有field<br><code>hkeys key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br></pre></td></tr></table></figure></li><li>获取所有value<br><code>hvals key</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) "tom"</span><br><span class="line">2) "18"</span><br></pre></td></tr></table></figure></li><li>获取所有的field-value<br><code>hgetall key</code>（个数较多会导致阻塞）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) "name"</span><br><span class="line">2) "tom"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br></pre></td></tr></table></figure></li><li>自增<br><code>hincrby key filed</code><br><code>hincrbyfloat key filed</code></li><li>计算value的字符串长度<br><code>hstrlen key filed</code>（Redis&gt;3.2）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen user:1 name</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li></ul><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于hash-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于hash-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>hashtable（哈希表）<br>不满足ziplist时采用，O(1)。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>哈希类型是稀疏的，而关系型数据库是完全结构化的，且Redis不适合做复杂的关系查询，<br>以下为获取用户信息的伪代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo getUserInfo(long id)&#123;</span><br><span class="line">  // 用户id作为key后缀</span><br><span class="line">  userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">  // 使用hgetall获取所有用户信息映射关系</span><br><span class="line">  userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">  <span class="keyword">if</span> (userInfoMap != null) &#123;</span><br><span class="line">    // 将映射关系转换为UserInfo</span><br><span class="line">    userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 从MySQL中获取用户信息</span><br><span class="line">    userInfo = mysql.get(id);</span><br><span class="line">    // 将userInfo变为映射关系使用hmset保存到Redis中</span><br><span class="line">    redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">    // 添加过期时间</span><br><span class="line">    redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种缓存用户信息方法对比。</p><ul><li>原生字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 name tom</span><br><span class="line">set user:1 age 18</span><br></pre></td></tr></table></figure>每个属性一个键，简单直观，但内存占用大，用户信息内聚性差。</li><li>序列化字符串类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1 serialize(userinfo)</span><br></pre></td></tr></table></figure>简化编程，但序列化和反序列化有一定开销，且每次更新都要进行反序列化和序列化。</li><li>哈希类型<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset user:1 name tom age 18</span><br></pre></td></tr></table></figure>简单直观，合理使用可减少内存占用，但要注意两种内部编码的转换，hashtable会消耗更多内存。</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>可以存储多个<strong>有序</strong>、<strong>重复</strong>的字符串，每个字符串称为元素（个数不大于2^32-1），可以充当<strong>栈</strong>和<strong>队列</strong>。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul><li>添加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpush key value1 value2           #从右侧插入</span><br><span class="line">lpush key value1 value2           #从左侧插入</span><br><span class="line">linsert key before|after me you   #在me之前或之后插入you</span><br></pre></td></tr></table></figure></li><li>查找<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrange key start end              #从左至右为0到N-1，从右至左为-1到-N，end包含自身，0到-1为全部</span><br><span class="line">lindex key index                  #获取指定下标的元素</span><br><span class="line">llen key                          #获取列表长度</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpop key                          #从右侧删除</span><br><span class="line">lpop key                          #从右侧删除</span><br><span class="line">lrem key count value              #删除值等于value的元素</span><br><span class="line">                                  #count&gt;0，从左至右，最多删除count个元素</span><br><span class="line">                                  #count&lt;0，从右至左，最多删除count绝对值个元素</span><br><span class="line">                                  #count=0，删除所有</span><br><span class="line">ltrim key start end               #保留列表中start到end的元素</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure></li><li>阻塞式弹出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blpop key1 key2 timeout</span><br><span class="line">brpop key1 key2 timeout</span><br></pre></td></tr></table></figure>列表为空时，timeout=3则客户端等到3s后返回，timeout=0则一直阻塞。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 3</span><br><span class="line">(nil)</span><br><span class="line">(3.09s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">...阻塞中...</span><br></pre></td></tr></table></figure>此期间添加了数据element1，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list:test element1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br><span class="line">(90.81s)</span><br></pre></td></tr></table></figure>列表不为空，客户端立即返回。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:test 0</span><br><span class="line">1) "list:test"</span><br><span class="line">2) "element1"</span><br></pre></td></tr></table></figure>若多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取弹出的值。</li></ul><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）<br>使用更紧凑的结构实现多个元素的连续存储，更加节省内存。<br>使用场景：<ul><li>哈希元素类型个数小于hash-max-ziplist-entries配置（默认512个——field个数）</li><li>同时所有的值小于hash-max-ziplist-value配置（默认64字节——value值大小）</li></ul></li><li>linkedlist（链表）<br>不满足ziplist时采用。</li></ul><p>注：Redis 3.2 版本提供了quicklist编码，是以一个ziplist为节点的linkedlist，结合了两者的优势。</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>消息队列<br>使用lpush和brpop命令组合实现阻塞队列，如图。<br><img src="https://s3.ax1x.com/2021/01/03/s9MDTP.png" alt=""></li><li>文章列表<br>如分页展示文章列表。<ul><li>每篇文章使用哈希存储<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset acticle:1 title xx timestamp 1476536196 content xxxx</span><br></pre></td></tr></table></figure></li><li>向用户文章列表添加文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush user:1:acticles article:1 article:2</span><br></pre></td></tr></table></figure></li><li>分页获取用户文章列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">articles = lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">  hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush+lpop=Stack（ 栈）</span><br><span class="line">lpush+rpop=Queue（ 队列）</span><br><span class="line">lpsh+ltrim=Capped Collection（ 有限集合）</span><br><span class="line">lpush+brpop=Message Queue（ 消息队列）</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）用来保存多个<strong>无序</strong>字符串元素，且不允许有重复的元素，不支持下标索引。<br>一个集合可以存储2^32-1个元素<br>Redis支持集合内的增删改查以及集合间取交集、并集和差集。</p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ul><li>集合内操作<ul><li>添加元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd key element1 element2</span><br></pre></td></tr></table></figure></li><li>删除元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem key element1 element2</span><br></pre></td></tr></table></figure></li><li>计算元素个数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scard key  #时间复杂度O(1)，直接调用Redis内部变量</span><br></pre></td></tr></table></figure></li><li>判断元素是否在集合中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></li><li>随机从集合返回指定个数的元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srandmember key count  #count默认为1</span><br></pre></td></tr></table></figure></li><li>从集合随机弹出count个元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop key count #Redis&gt;3.2，count默认为1</span><br></pre></td></tr></table></figure></li><li>获取所有元素<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li></ul></li><li>集合间操作<ul><li>交集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter key1 key2</span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sunion key1 key2</span><br></pre></td></tr></table></figure></li><li>差集<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure></li><li>将交集、并集和差集的结果保存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将key1和key2运算的结果保存在destination_key中</span></span><br><span class="line">sinterstore destination_key key1 key2</span><br><span class="line">sunionstore destination_key key1 key2</span><br><span class="line">sdiffstore destination_key key1 key2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>intset（整数集合）<br>更加节省内存。<br>使用场景：<ul><li>集合中都是整数且元素个数小于set-max-intset-entries配置（默认512个）</li></ul></li><li>hashtable（哈希表）<br>不满足intset时采用。</li></ul><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合典型的使用场景是<strong>标签</strong>（用于提升用户体验和增强用户黏度）。<br>注：用户和标签的关系维护应在一个事务内执行，防止部分命令失败造成的数据不一致。</p><ul><li>给用户添加标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>给标签添加用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>删除用户下的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem user:1:tags tag1 tag2</span><br></pre></td></tr></table></figure>删除标签下的用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">srem tag1:users user:1 user:2</span><br></pre></td></tr></table></figure></li><li>计算用户共同感兴趣的标签<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure></li></ul><p>主要应用场景：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd=Tagging（标签）</span><br><span class="line">spop/srandmember=Random item（生成随机数， 比如抽奖）</span><br><span class="line">sadd+sinter=Social Graph（社交需求）</span><br></pre></td></tr></table></figure><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆录</title>
    <url>/post/Life/memories/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>脑海中闪过的片段<a id="more"></a><br>时常有一些回忆片段涌现出脑海，借此记录下来。</p>]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>Python进阶</title>
    <url>/post/Python/fluent-python-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《流畅的Python》学习笔记<a id="more"></a><br>学习Python之前，最好熟悉一下Python的语言和风格规范<br><a href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html" target="_blank" rel="noopener">https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html</a><br>原项目：<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">https://github.com/google/styleguide</a></p><center><span style="font-weight:700;font-size:24px">序幕</span></center><h2 id="Ch1-Python数据模型"><a href="#Ch1-Python数据模型" class="headerlink" title="Ch1 Python数据模型"></a>Ch1 Python数据模型</h2><p>数据（对象）模型是对Python框架的描述，规范了这门语言自身构建模块的接口，这些模块包括序列、迭代器、函数、类和上下文管理器等。<br>而无论在哪种框架下编程，都会大量实现会被框架本身调用的方法，Python里会使用特殊方法去激活一些基本的对象操作，这类方法称为魔术方法（magic method）或双下方法（dunder method），形如<code>__getitem__</code>。</p><h3 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h3><p>如下代码段：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="comment">#collections.namedtuple用于构建一个简单的类，</span></span><br><span class="line"><span class="comment">#该类用来构建只有少数属性但没有方法的对象，如数据库条目。</span></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'方块 梅花 红桃 黑桃'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="string">"""提供了元素定位deck[0]</span></span><br><span class="line"><span class="string">        将[]操作交给self._cards列表，所以deck类自动支持切片操作且可迭代（支持反向迭代reversed(deck)）</span></span><br><span class="line"><span class="string">        迭代通常是隐式的，若一个集合类型未实现__contains__方法，那么in运算就会按顺序做一次迭代搜索</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    card1 = Cards(<span class="number">3</span>, <span class="string">'红桃'</span>)</span><br><span class="line">    print(card1)</span><br><span class="line">    deck = FrenchDeck()</span><br><span class="line">    print(len(deck))</span><br><span class="line">    print(deck[<span class="number">-1</span>])</span><br><span class="line">    print(choice(deck))</span><br><span class="line">    print(Card(<span class="string">'7'</span>, <span class="string">'红桃'</span>))</span><br><span class="line">    <span class="comment"># TODO(xyr): 排序和洗牌</span></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">    Card(rank=<span class="number">3</span>, suit=<span class="string">'红桃'</span>)</span><br><span class="line">    <span class="number">52</span></span><br><span class="line">    Card(rank=<span class="string">'A'</span>, suit=<span class="string">'黑桃'</span>)</span><br><span class="line">    Card(rank=<span class="string">'3'</span>, suit=<span class="string">'黑桃'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h3><ul><li>首先，特殊方法是为了被Python解释器调用，而非自己调用，除非有大量元编程存在，或者在自己的子类的<code>__init__</code>方法中调用超累的构造器。</li><li>特殊方法的调用一般是隐式的，比如<code>for i in x:</code>调用的其实是iter(x)，而这个函数背后则是<code>x.__iter__()</code>方法（前提是这个方法已经在x中被实现）。</li><li>通过内置的函数（len、str等）使用特殊方法是最好的选择。</li><li>如果是Python内置的类型（list、str等），CPython的<code>__len__</code>实际上会直接返回PyVarObject（表示内存中长度可变的内置对象的C语言结构体）里的ob_size属性。</li><li>不要随意添加特殊方法，以防在后面的更新中被Python内部使用而产生冲突。</li></ul><h4 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h4><p>利用特殊方法，可以让自定义对象通过“+”（或别的运算符）进行运算，例如下面的一个自定义的二维向量类，其中的+、*和abs（取绝对值或取模）运算即是由这些特殊方法实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line">        <span class="comment"># return bool(self.x or self.y)  #更加高效</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)  <span class="comment">#未考虑交换律</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    v1 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    v2 = Vector(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    print(v1+v2)</span><br><span class="line">    print(abs(v1))</span><br><span class="line">    print(v1*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">    Vector(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="number">5.0</span></span><br><span class="line">    Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h4><ul><li>Python通过内置函数repr将一个对象用字符串的形式表达出来，repr就是通过<code>__repr__</code>这个特殊方法得到一个对象的字符串的形式，若未实现<code>__repr__</code>，打印一个向量实例时得到的会是<code>&lt;Vector object at 0x10e100070&gt;</code></li><li>格式化字符串的两种方法，使用<code>%</code>和使用<code>str.format</code>均利用了repr。</li><li><code>__repr__</code>中使用<code>%r</code>来获取对象各个属性的标准字符串表示形式。</li><li><code>__repr__</code>所返回的字符串应准确无歧义，且尽可能表达出如何用代码创建出这个被打印的对象。</li><li><code>__repr__</code>和<code>__str__</code>的区别在于前者方便记录和调试日志，后者在<code>str()</code>函数被使用，或<code>print()</code>打印对象时被调用，且返回的字符串对终端用户更友好。两者优先实现<code>__repr__</code>，因为一个函数没有<code>__str__</code>而去调用它会用<code>__repr__</code>来代替。（详见<a href="http://stackoverflow.com/questions/1436703/differencebetween-str-and-repr-in-python）" target="_blank" rel="noopener">http://stackoverflow.com/questions/1436703/differencebetween-str-and-repr-in-python）</a></li></ul><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>通过<code>__add__</code>和<code>__mul__</code>实现了+和*，这里不改变操作对象，而是返回一个新创建的向量对象。</p><h4 id="自定义的布尔值"><a href="#自定义的布尔值" class="headerlink" title="自定义的布尔值"></a>自定义的布尔值</h4><ul><li><code>bool(x)</code>背后调用<code>x.__bool__()</code>，若未实现<code>__bool__</code>方法，那么<code>bool(x)</code>会尝试调用<code>x.__len__()</code>，0为False，否则返回True。</li><li>默认情况下自定义类的实例总为真，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。</li><li>更高效的<code>__bool__</code>方法，<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h3><p>Python语言参考手册中的“DataModel”，<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">（https://docs.python.org/3/reference/datamodel.html）</a>一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。<br><img src="https://s3.ax1x.com/2021/01/04/sP0shD.jpg" alt=""></p><h3 id="为什么len不是普通方法"><a href="#为什么len不是普通方法" class="headerlink" title="为什么len不是普通方法"></a>为什么len不是普通方法</h3><p>“实用胜于纯粹，不能让特例特殊到破坏既定规则。”<br>len之所以不是一个普通方法，是为了让Python自带的数据结构可以走后门，abs也是同理。但是多亏了它是特殊方法，我们也可以把len用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点。</p><center><span style="font-weight:700;font-size:24px">数据结构</span></center><h2 id="Ch2-序列构成的数组"><a href="#Ch2-序列构成的数组" class="headerlink" title="Ch2 序列构成的数组"></a>Ch2 序列构成的数组</h2><h3 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h3><h3 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h3><h3 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h3><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h3 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h3><h3 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h3><h3 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h3><h3 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h3><h3 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>WireShark网络分析</title>
    <url>/post/Networks/wireshark/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>WireShark网络分析</p><a id="more"></a><p>官网：<a href="https://www.wireshark.org/" target="_blank" rel="noopener">https://www.wireshark.org/</a></p><h2 id="《Wireshark网络分析的艺术》笔记"><a href="#《Wireshark网络分析的艺术》笔记" class="headerlink" title="《Wireshark网络分析的艺术》笔记"></a>《Wireshark网络分析的艺术》笔记</h2><h3 id="关于TCP的延迟确认机制可能带来的性能问题，"><a href="#关于TCP的延迟确认机制可能带来的性能问题，" class="headerlink" title="关于TCP的延迟确认机制可能带来的性能问题，"></a>关于TCP的延迟确认机制可能带来的性能问题，</h3><ul><li><strong>延迟确认的优点</strong>：在延迟的时间内，客户端有数据要发，就可以在发数据时捎带确认信息，省去一个纯粹的确认包（实际为帧，后面全称为包），进而节省带宽。</li><li><strong>可能会导致的问题</strong>：网络拥塞时大量重传影响性能，或因延迟太久导致超时重传，或TCP窗口极小。</li><li><strong>解决</strong>：启用SACK会在ACK中附带已收到的包号（或者关闭延迟确认），从而解决延迟确认带来的性能问题。<br>在Wireshark抓包中使用Filter：<code>tcp.analysis.ack_rtt&gt;0.2 and tcp.len==0</code>将超过200ms的确认包筛选出来</li></ul><h3 id="关于TCP的三次握手失败分析"><a href="#关于TCP的三次握手失败分析" class="headerlink" title="关于TCP的三次握手失败分析"></a>关于TCP的三次握手失败分析</h3><ul><li><strong>主要原因</strong>：</li></ul>]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>WireShark</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫基础</title>
    <url>/post/Python/python-spider/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Python3网络爬虫开发实战》笔记<a id="more"></a></p><h2 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h2><h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><p>URI,URL,URN 2</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/post/Tips/common-commands/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>包括Hexo、Django等<a id="more"></a></p><h2 id="Django常用命令"><a href="#Django常用命令" class="headerlink" title="Django常用命令"></a>Django常用命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h3 id="新建文章："><a href="#新建文章：" class="headerlink" title="新建文章："></a>新建文章：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo new page --path _posts/Hexo/hexo-commands <span class="string">"Hexo常用命令"</span></span><br></pre></td></tr></table></figure><h3 id="生成静态文件和上传："><a href="#生成静态文件和上传：" class="headerlink" title="生成静态文件和上传："></a>生成静态文件和上传：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h3 id="本地运行："><a href="#本地运行：" class="headerlink" title="本地运行："></a>本地运行：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tips</category>
      </categories>
  </entry>
  <entry>
    <title>《Python深度学习》笔记</title>
    <url>/post/DeepLearning/deep-learning-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Python深度学习》笔记<a id="more"></a><br><a href="#jump">Windows下的环境搭建</a>，<br>英文电子版<a href="https://livebook.manning.com/book/deep-learning-with-python/" target="_blank" rel="noopener">https://livebook.manning.com/book/deep-learning-with-python/</a><br>Keras中文文档：<a href="https://keras.io/zh/" target="_blank" rel="noopener">https://keras.io/zh/</a></p><h2 id="Chapter-1-基本概念"><a href="#Chapter-1-基本概念" class="headerlink" title="Chapter 1 基本概念"></a>Chapter 1 基本概念</h2><p>首先理清人工智能、机器学习和深度学习的概念和关系，<br>人工智能&gt;机器学习&gt;深度学习<br>深度学习是机器学习的子集，而机器学习则是人工智能的子集</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p><strong>简洁定义</strong>：将通常由人类完成的智力任务自动化。<br><strong>发展</strong>：<em>符号主义人工智能</em>（symbolic AI）→<em>机器学习</em>（machine learning）<br><strong>符号主义人工智能</strong>：编写足够多的明确规则来处理知识，用于解决定义明确的逻辑问题，如下国际象棋，但对于图像分类、语音识别等难以给出明确规则的复杂、模糊的问题将无法解决。</p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><img src="https://i.loli.net/2020/05/16/iweKFoO9k862ufD.png" alt=""><br>　　机器学习将某个任务相关的示例输入机器学习系统，系统从中找到统计结构，最终找到规则将任务自动化，其与经典程序设计不同如上图。<br>　　机器学习的三个要素如下：<br>　　（1）输入数据点。<br>　　（2）预期输出的示例。<br>　　（3）衡量算法效果好坏的方法。<br>　　机器学习和深度学习的核心问题在于<strong>有意义地变换数据</strong> ，即学习输入数据的有用<strong>表示</strong>（表征数据或将数据编码），如彩色图像可以编码为RGB（红-绿-蓝）格式或HSV（色相-饱和度-明度）格式，在应对不同任务时，不同的表示方式将会产生很大的差异，所以机器学习模型的目的就是为输入数据寻找合适的表示。<br>　　<strong>定义</strong>：在预先定义好的可能性空间中（假设空间），利用反馈信号的指引来寻找输入数据的有用表示。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>　　深度学习强调从连续的<strong>层</strong>中进行学习，这些层对应越来越有意义的<strong>表示</strong>。<br>　　模型包含的层数成为模型的<strong>深度</strong>，这些分层总是通过<strong>神经网络</strong>（neural network）模型学习得到。<br>　　<strong>定义</strong>：学习数据表示的多级方法，相当于多级信息蒸馏操作。<br>　　<strong>深度学习工作原理</strong>：<br>　　神经网络每层对输入数据所做的具体操作保存在该层的<strong>权重</strong>中，其本质是一串数字，每层实现的变换由其权重来<strong>参数化</strong>，<strong>学习</strong>即为每层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。<br>　　输入网络预测值和真实目标值通过<strong>损失函数</strong>计算一个距离值，利用这个距离值作为反馈信号通过<strong>优化器</strong>实现<strong>反向传播算法</strong>来对权重值进行微调，以降低当前示例的损失值，随着示例的增多，损失值逐渐降低，输出值与目标值尽可能接近。如下图。<br><img src="https://i.loli.net/2020/05/16/zomZXBxty67UqEN.png" alt="深度学习工作原理图"></p><h2 id="Chapter-2-神经网络的数学基础"><a href="#Chapter-2-神经网络的数学基础" class="headerlink" title="Chapter 2 神经网络的数学基础"></a>Chapter 2 神经网络的数学基础</h2><h3 id="张量（tensor）"><a href="#张量（tensor）" class="headerlink" title="张量（tensor）"></a>张量（tensor）</h3><p>定义：又叫多维Numpy数组，作为机器学习的基本数据结构，是一个数据容器，包含的数据几乎总是数值数据，如矩阵是二维张量，张量是矩阵向任意维度的推广[ 张量的<strong>维度</strong>（dimension）通常叫做<strong>轴</strong>（axis）]</p><h3 id="标量（scalar）"><a href="#标量（scalar）" class="headerlink" title="标量（scalar）"></a>标量（scalar）</h3><p>定义：仅包含一个数字的张量，又叫标量张量、零维张量、0D张量。在Numpy数组中，一个float32或float64的数字就是一个标量。<br>标量张量有0个轴（ndim == 0），轴的个数又叫<strong>阶</strong>（rank）。如下代码查看一个标量张量的轴的个数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="number">12</span>)</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a>向量（vector）</h3><p>定义：数字组成的数组，又叫一维张量或1D张量，只有一个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>该向量有5个元素，为5D向量，有1个轴，沿着轴有5个维度。而5D张量有5个轴，沿着某个轴可能有任意个维度。</p><h3 id="矩阵（matrix）"><a href="#矩阵（matrix）" class="headerlink" title="矩阵（matrix）"></a>矩阵（matrix）</h3><p>定义：多个向量组成的数组，又叫二维张量或2D张量，有2个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>第一个轴上的元素叫行，[12, 3, 22, 121, 4]是x的第一行，第二个轴上的元素叫列，[12, 12, 12]是x的第一列。</p><h3 id="3D张量与更高维张量"><a href="#3D张量与更高维张量" class="headerlink" title="3D张量与更高维张量"></a>3D张量与更高维张量</h3><p>定义：多个矩阵组成的数组，有3个轴，如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]],</span><br><span class="line">            [[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>],</span><br><span class="line">             [<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">4</span>]]])</span><br><span class="line">print(x.ndim)</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>深度学习一般处理0D到4D张量，处理视频数据可能会遇到5D张量。</p><h3 id="张量的关键属性"><a href="#张量的关键属性" class="headerlink" title="张量的关键属性"></a>张量的关键属性</h3><ul><li><strong>轴的个数</strong>（阶、维度）：Python库中为ndim。</li><li><strong>形状</strong>：张量沿某个轴的维度大小（元素个数），如前面的3D张量的形状为（3， 3， 5）。</li><li><strong>数据类型</strong>：张量所包含数据的类型，Python库中为dtype，如float32、float64、unit8等，极少数情况有字符（char）张量，Numpy等大多数库都不存在字符串张量，因为<span style="border-bottom:2px solid red">张量存储在预先分配的连续内存段中</span>，而字符串长度可变，无法用这种方式存储。</li></ul><p>代码示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line">print(train_images.shape)</span><br><span class="line">print(train_images.ndim);</span><br><span class="line">print(train_images.dtype);</span><br><span class="line"></span><br><span class="line"><span class="comment">#该3D张量中的第四个数字</span></span><br><span class="line">digit = train_images[<span class="number">4</span>]</span><br><span class="line">plt.imshow(digit, cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">uint8</span><br><span class="line"></span><br><span class="line"><span class="comment">#由上可见，train_images是一个由8位整数组成的3维张量，即60000个28*28整数矩阵组成的数组，每个矩阵是一张灰度图像。</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/18/Yf6u1H.png" alt="该3D张量中的第四个数字"></p><h3 id="张量切片"><a href="#张量切片" class="headerlink" title="张量切片"></a>张量切片</h3><p>类似于Python的切片操作，示例:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择第10~100个数字（不包括100），将其放在形为（90，28，28）的数组中</span></span><br><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>]     <span class="comment">#[10:100, 0:28, 0:28]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可沿着张量轴在任意两个索引间进行选择，也可使用负索引</span></span><br><span class="line">my_slice = train_images[, <span class="number">14</span>:, <span class="number">14</span>:]       <span class="comment">#右下角14*14</span></span><br><span class="line">my_slice = train_images[, <span class="number">7</span>:<span class="number">-7</span>, <span class="number">7</span>:<span class="number">-7</span>]       <span class="comment">#中心14*14</span></span><br></pre></td></tr></table></figure><h3 id="数据批量"><a href="#数据批量" class="headerlink" title="数据批量"></a>数据批量</h3><p>　　所有数据张量的第一个轴称为<strong>样本轴</strong>或<strong>0轴</strong>（samples axis）。<br>　　深度学习模型会将数据集拆分成小批量，形如<code>batch = train_images[:128]</code>。<br>　　对于这种批量张量，第一个轴为<strong>批量轴</strong>（batch axis）或<strong>批量维度</strong>（batch dimension）。</p><h3 id="现实世界中的数据张量"><a href="#现实世界中的数据张量" class="headerlink" title="现实世界中的数据张量"></a>现实世界中的数据张量</h3><ul><li><strong>向量数据</strong>：2D 张量，形状为 (samples, features) 。</li><li><strong>时间序列数据或序列数据</strong>：3D 张量，形状为 (samples, timesteps, features) 。</li><li><strong>图像</strong>：4D张量，形状为 (samples, height, width, channels) 或 (samples, channels,<br>height, width) 。</li><li><strong>视频</strong>：5D张量，形状为 (samples, frames, height, width, channels) 或 (samples,<br>frames, channels, height, width)</li></ul><h4 id="向量数据"><a href="#向量数据" class="headerlink" title="向量数据"></a>向量数据</h4><p>　　常见的数据。每个数据点被编码为一个向量，因此一个数据批量就被编码为 2D 张量（即向量组成的数组），其中第一个轴是<strong>样本轴</strong>，第二个轴是<strong>特征轴</strong> <span style="border-bottom:2px solid red">(samples, features)</span>。如<br>　　人口统计数据集，其中包括每个人的年龄、邮编和收入。每个人可以表示为包含 3 个值的向量，而整个数据集包含 100 000 个人，因此可以存储在形状为 (100000, 3) 的 2D张量中。</p><h4 id="时间序列数据或序列数据"><a href="#时间序列数据或序列数据" class="headerlink" title="时间序列数据或序列数据"></a>时间序列数据或序列数据</h4><p>　　当时间对于数据很重要时，将数据存储在带有时间轴的3D张量中。每个样本被编码为一个向量序列（即2D张量），因此一个数据批量就被编码为一个3D张量 <span style="border-bottom:2px solid red">(samples, timesteps, features)</span>。如图：<br><img src="https://s1.ax1x.com/2020/05/18/YhClMF.png" alt="">　　依据惯例，时间轴始终是第二个轴。<br>　　例如股票价格数据集：<br>　　要构建一个股票价格数据集：每一分钟，我们将股票的当前价格，前一分钟的最高价格和前一分钟的最低价格保存下来，那么就被编码为一个3D向量。整个交易日就编码为一个有390个3D向量的2D张量（390，3）。250天的数据就编码为3D张量（250，390，3）。</p><h4 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h4><p>　　图像通常具有三个维度：<strong>高度</strong>、<strong>宽度</strong>和<strong>颜色深度</strong>。虽然灰度图像（比如 MNIST 数字图像）只有一个颜色通道，因此可以保存在 2D 张量中，但按照惯例，图像张量始终都是 3D 张量，灰度图像的彩色通道只有一维。因此，如果图像大小为 256×256，那么 128 张灰度图像组成的批量可以保存在一个形状为 (128, 256, 256, 1) 的张量中，而 128 张彩色图像组成的批量则可以保存在一个形状为 (128, 256, 256, 3) 的张量中。<br><img src="https://s1.ax1x.com/2020/05/18/YhipjS.png" alt="">　　图像张量的形状有两种约定：通道在后（channels-last）的约定（在 TensorFlow 中使用）和通道在前（channels-first）的约定（在 Theano 中使用）。<br>　　Google 的 TensorFlow 机器学习框架将颜色深度轴放在最后：<span style="border-bottom:2px solid red"> (samples, height, width, color_depth)</span>,例如(128, 256, 256, 3) 。<br>　　Theano将图像深度轴放在批量轴之后：<span style="border-bottom:2px solid red">(samples, color_depth, height, width)</span>，例如(128, 3, 256, 256)。<br>　　Keras 框架同时支持这两种格式。</p><h4 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h4><p>　　视频数据是现实生活中需要用到 5D 张量的少数数据类型之一。视频可以看作一系列帧，每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_depth) 的 3D 张量中，因此一系列帧可以保存在一个形状为 (frames, height, width,color_depth) 的 4D 张量中，而不同视频组成的批量则可以保存在一个 5D 张量中，其形状为<span style="border-bottom:2px solid red">(samples, frames, height, width, color_depth) </span>。<br>　　例如，一个以每秒 4 帧采样的 60 秒 YouTube 视频片段，视频尺寸为 144×256，这个视频共有 240 帧。4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3)的张量中。总共有 106 168 320 个值！如果张量的数据类型（ dtype ）是 float32 ，每个值都是32 位，那么这个张量共有 405MB。现实生活中遇到的视频要小得多，因为它们不以float32 格式存储，而且通常被大大压缩，比如 MPEG 格式。</p><h3 id="张量运算——神经网络的“齿轮”"><a href="#张量运算——神经网络的“齿轮”" class="headerlink" title="张量运算——神经网络的“齿轮”"></a>张量运算——神经网络的“齿轮”</h3><p>　　本节和下一节主要是高等数学和线性代数在神经网络中的运用，下面只简单提一下这些数学知识在神经网络中的相关概念。</p><h4 id="逐元素运算（element-wise）"><a href="#逐元素运算（element-wise）" class="headerlink" title="逐元素运算（element-wise）"></a>逐元素运算（element-wise）</h4><p>　　运算独立地应用于张两种地每个元素，适合大规模并行实现。如：</p><ul><li>relu运算：relu(x) == max(x, 0)</li><li>四则运算（前提是运算对象形状相同）</li></ul><h4 id="广播（broadcast）"><a href="#广播（broadcast）" class="headerlink" title="广播（broadcast）"></a>广播（broadcast）</h4><p>　　两个形状不同地张量相加，较小地张量会被广播，以匹配较大的张量。如：<br>　　x形状为（32，10），y形状为（10，），则x+y会为y添加空的第一个轴（广播轴）→（1，10），再沿新轴重复32次→（32，10）。<br>　　但以上过程不会在运算中实际发生，只是想象的思维模型。</p><h4 id="张量点积（tensor-product）"><a href="#张量点积（tensor-product）" class="headerlink" title="张量点积（tensor product）"></a>张量点积（tensor product）</h4><p>　　类似于线性代数中矩阵的乘法，Keras和Numpy中使用<code>numpy.dot(x, y)</code>实现。<br>　　形如(a, b, c, d).(d, e)-&gt;(a, b, c, e)，<img src="https://s1.ax1x.com/2020/05/19/Y4DYO1.jpg" alt=""></p><h4 id="张量变形（tensor-reshaping）"><a href="#张量变形（tensor-reshaping）" class="headerlink" title="张量变形（tensor reshaping）"></a>张量变形（tensor reshaping）</h4><p>　　改变张量的行列，但元素总数不变。<code>x.reshape((2,6))</code><br>　　行列互换称为<strong>转置</strong>（transposition）<code>numpy.transpose(x)</code></p><h4 id="张量运算的几何解释"><a href="#张量运算的几何解释" class="headerlink" title="张量运算的几何解释"></a>张量运算的几何解释</h4><p>　　类似高数中的向量变换以及更高维的延申。</p><h3 id="基于梯度的优化——神经网络的“引擎”"><a href="#基于梯度的优化——神经网络的“引擎”" class="headerlink" title="基于梯度的优化——神经网络的“引擎”"></a>基于梯度的优化——神经网络的“引擎”</h3><p>　　对每个神经层用下述方法对输入数据进行变换。<br>　　<code>output = relu(dot(W, input) + b)</code><br>　　在这个表达式中，W 和b 都是张量，均为该层的属性。它们被称为该层的<strong>权重</strong>（weight）或<strong>可训练参数</strong>（trainable parameter），分别对应kernel 和bias 属性。这些权重包含网络从观察训练数据中学到的信息。<br>　　一开始，这些权重矩阵取较小的随机值，这一步叫作<strong>随机初始化</strong>（random initialization）。当然，W 和b 都是随机的，relu(dot(W, input) + b) 肯定不会得到任何有用的表示。虽然得到的表示是没有意义的，但这是一个起点。下一步则是根据反馈信号逐渐调节这些权重。这个逐渐调节的过程叫作<strong>训练</strong>，也就是机器学习中的<strong>学习</strong>。<br>　　上述过程发生在一个<strong>训练循环</strong>（training loop）内，其具体过程如下。必要时一直重复这些步骤。</p><ul><li>抽取训练样本x 和对应目标y 组成的数据批量。</li><li>在x 上运行网络［这一步叫作前向传播（forward pass）］，得到预测值y_pred。</li><li>计算网络在这批数据上的损失，用于衡量y_pred 和y 之间的距离。</li><li>更新网络的所有权重，使网络在这批数据上的损失略微下降。</li></ul><p>　　最终得到的网络在训练数据上的损失非常小，即预测值y_pred 和预期目标y 之间的距离非常小。<br><span style="border-bottom:2px solid red">详情参见：<a href="https://www.ituring.com.cn/book/tupubarticle/23177" target="_blank" rel="noopener">https://www.ituring.com.cn/book/tupubarticle/23177</a></span></p><h2 id="Chapter-3-神经网络入门"><a href="#Chapter-3-神经网络入门" class="headerlink" title="Chapter 3 神经网络入门"></a>Chapter 3 神经网络入门</h2><p>　　这里再次引用第一章的深度学习工作原理图。<br><img src="https://i.loli.net/2020/05/16/zomZXBxty67UqEN.png" alt="深度学习工作原理图"></p><h3 id="层：深度学习的基础组件"><a href="#层：深度学习的基础组件" class="headerlink" title="层：深度学习的基础组件"></a>层：深度学习的基础组件</h3><p>　　<strong>层</strong>是神经网络的基本数据结构，层的状态即层的<strong>权重</strong>，权重是利用<strong>随机梯度下降</strong>学到的一个或多个张量。以下是几种不同的层及其应用场景。</p><ul><li><strong>密集连接层</strong>（densely connected layer）：又叫<strong>全连接层</strong>（fully connected layer）和<strong>密集层</strong>（dense layer），用于处理保存简单向量的2D张量，形状为 (samples, features)，对应Keras的Dense类。</li><li><strong>循环层</strong>（recurrent layer）：用于处理保存序列数据的3D张量，形状为 (samples, timesteps, features)，对应Keras的LSTM层。</li><li><strong>二维卷积层</strong>：用于处理保存图像数据的4D张量，形状为 (samples, height, width, channels)，对应Keras的Conv2D。</li></ul><h3 id="模型：层构成的网络"><a href="#模型：层构成的网络" class="headerlink" title="模型：层构成的网络"></a>模型：层构成的网络</h3><p>　　构建深度学习模型就是将相互兼容的多个层拼接在一起，以建立有用的数据变换流程。深度学习模型是层构成的有向无环图。<br>　　这里的层兼容性（layer compatibility）指每一层只接受特定形状的输入张量并返回特定形状的输出张量。<br>　　一些常见的网络拓扑结构如下:<br>　　（1）线性网络<br>　　（2）双分支（two-branch）网络<br>　　（3）多头（multihead）网络<br>　　（4）Inception模块</p><h3 id="损失函数与优化器：配置学习过程的关键"><a href="#损失函数与优化器：配置学习过程的关键" class="headerlink" title="损失函数与优化器：配置学习过程的关键"></a>损失函数与优化器：配置学习过程的关键</h3><ul><li>损失函数(目标函数)：训练过程中将其最小化，能够衡量当前任务是否已成功完成。</li><li>优化器：决定如何根据损失函数对网络进行更新，执行随机梯度下降（SGD： stochastic gradient descent）的某个变体。</li></ul><p>　　注意：具有多个输出的神经网络可能有多个损失函数，但梯度下降过程必须基于单个标量损失值。因此要将所有损失函数取平均变为一个标量值。</p><h3 id="Keras开发流程"><a href="#Keras开发流程" class="headerlink" title="Keras开发流程"></a>Keras开发流程</h3><ul><li>定义训练数据：输入张量和目标张量。</li><li>定义层组成的网络（或模型），将输入映射到目标。</li><li>配置学习过程：选择损失函数，优化器和需要监控的指标。</li><li>调用模型的fit()方法迭代训练数据。</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models,layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Sequential类定义模型</span></span><br><span class="line"><span class="comment"># model = models.Sequential()</span></span><br><span class="line"><span class="comment"># model.add(layers.Dense(32, activation='relu', input_shape=(784,)))</span></span><br><span class="line"><span class="comment"># model.add(layers.Dense(10, activation='softmax'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数式API定义模型</span></span><br><span class="line">input_tensor = layers.Input(shape=(<span class="number">784</span>,))</span><br><span class="line">x = layers.Dense(<span class="number">32</span>, activation=<span class="string">'relu'</span>)(input_tensor)</span><br><span class="line">output_tensor = layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)(x)</span><br><span class="line">model = models.Model(inputs=input_tensor, outputs=output_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">model.compile(optimizer=optimizers.RMSprop(lr=<span class="number">0.001</span>),       <span class="comment">#优化器</span></span><br><span class="line">              loss=<span class="string">'mse'</span>,                                   <span class="comment">#损失函数</span></span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])                         <span class="comment">#评估函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代训练数据</span></span><br><span class="line">model.fit(input_tensor, target_tensor, batch_size=<span class="number">128</span>, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="电影评论分类：二分类问题"><a href="#电影评论分类：二分类问题" class="headerlink" title="电影评论分类：二分类问题"></a>电影评论分类：二分类问题</h3><p>注意：</p><ul><li>隐藏单元越多（更高维的表示空间），网络越能学习更复杂的表示，但这会使网络的计算代价更大，并且可能导致学习到不好的模式（这种模式可以提高训练数据的性能，但不能提高测试数据的性能）。</li><li>sigmoid函数将任意值压缩到[0, 1]区间内。</li><li>relu（rectified linear unit，整流线性单元）函数，将所有负值归零。</li><li>激活函数：也叫非线性，为了得到更丰富的假设空间，充分利用多层表示的优势。</li><li>对于二分类这种最后输出概率值的问题，损失函数最优解为binary_crossentropy（二元交叉熵）。</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分类问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 1 加载数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#train_data和train_labels为评论组成的列表，而每条评论为单词索引组成的列表</span></span><br><span class="line"><span class="comment">#test_data和test_labels为0、1组成的列表，代表负面和正面</span></span><br><span class="line"><span class="comment">#num_words=10000表示仅保留训练数据中前10000个最常出现的单词</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = imdb.load_data(num_words=<span class="number">10000</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># word_index = imdb.get_word_index()                                   #将单词映射为整数索引的字典</span></span><br><span class="line"><span class="comment"># reverse_word_index = dict(                                           #键值颠倒，整数索引映射为单词</span></span><br><span class="line"><span class="comment">#     [(value, key) for (key, value) in word_index.items()])</span></span><br><span class="line"><span class="comment"># decoded_review = ' '.join(                                           #评论解码，索引减去3，</span></span><br><span class="line"><span class="comment">#     [reverse_word_index.get(i - 3, '?') for i in train_data[0]])     #因为0、1、2为保留索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 2 处理数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对列表进行one-hot编码，转化为0、1组成的向量。</span></span><br><span class="line"><span class="comment">#将整数序列编码为二进制矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span><span class="params">(sequences, dimension=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    results = np.zeros((len(sequences), dimension))                    <span class="comment">#创建一个零矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> enumerate(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)                              <span class="comment">#训练数据向量化</span></span><br><span class="line">x_test = vectorize_sequences(test_data)                                <span class="comment">#测试数据向量化</span></span><br><span class="line">y_train = np.asarray(train_labels).astype(<span class="string">'float32'</span>)                   <span class="comment">#训练标签向量化</span></span><br><span class="line">y_test = np.asarray(test_labels).astype(<span class="string">'float32'</span>)                     <span class="comment">#测试标签向量化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#留出10000个样本作验证集</span></span><br><span class="line">x_val = x_train[:<span class="number">10000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">10000</span>:]</span><br><span class="line">y_val = y_train[:<span class="number">10000</span>]</span><br><span class="line">partial_y_train = y_train[<span class="number">10000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 3 定义模型/构建网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#采用3层全连接层，16为隐藏单元个数，即维度，activation为激活函数</span></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 4 编译模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置优化器，损失函数，评估函数</span></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 5 训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用512个样本组成的小批量，对所有样本进行20次迭代，</span></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘图</span></span><br><span class="line"></span><br><span class="line">history_dict = history.history</span><br><span class="line">loss_values = history_dict[<span class="string">'loss'</span>]</span><br><span class="line">val_loss_values = history_dict[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">epochs = range(<span class="number">1</span>, len(loss_values) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss_values, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">plt.plot(epochs, val_loss_values, <span class="string">'b'</span>, label=<span class="string">'Validation loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">acc_values = history_dict[<span class="string">'acc'</span>]</span><br><span class="line">val_acc_values = history_dict[<span class="string">'val_acc'</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc_values, <span class="string">'bo'</span>, label=<span class="string">'Training acc'</span>)</span><br><span class="line">plt.plot(epochs, val_acc_values, <span class="string">'b'</span>, label=<span class="string">'Validation acc'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/20/YTstRf.png" alt="训练损失和验证损失"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/20/YTsgzT.png" alt="训练精度和验证精度"></th></tr></thead></table><p>　　由上图可见，每轮训练损失在降低，训练精度在上升，符合预期，但验证损失和验证精度并非如此，模型在训练数据上表现更好，但不一定在从未见过的数据上表现更好，这种现象成为<strong>过拟合</strong>（overfit），详见Chapter 4。<br>　　下面是一种简单的训练方法：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">results = model.evaluate(x_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">[<span class="number">0.29506705965518953</span>, <span class="number">0.884119987487793</span>]</span><br></pre></td></tr></table></figure><p>　　用训练好的网络进行预测。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.predict(x_test)</span><br><span class="line">array([[ <span class="number">0.98006207</span>]</span><br><span class="line">       [ <span class="number">0.99758697</span>]</span><br><span class="line">       [ <span class="number">0.99975556</span>]</span><br><span class="line">       ...,</span><br><span class="line">       [ <span class="number">0.82167041</span>]</span><br><span class="line">       [ <span class="number">0.02885115</span>]</span><br><span class="line">       [ <span class="number">0.65371346</span>]], dtype=float32)</span><br></pre></td></tr></table></figure><h3 id="新闻分类：多分类问题"><a href="#新闻分类：多分类问题" class="headerlink" title="新闻分类：多分类问题"></a>新闻分类：多分类问题</h3><ul><li>单标签、多分类（single-label，multiclass classification）：每个数据点只能划分到一个类别。</li><li>多标签、多分类（multilabel，multiclass classification）：每个数据点能划分到多个类别。</li></ul><p>注意：</p><ul><li>编码数据中将标签向量化的两种方法：转化为整数张量或进行one-hot编码。注意两种方法所使用的<strong>损失函数</strong>可能会有所差别。<ul><li>通过分类编码（也称为one-hot编码），使用categorical_crossentropy作为损失函数对标签进行编码。</li><li>将标签编码为整数，使用sparse_categorical_crossentropy作为损失函数对标签进行编码。</li></ul></li><li>如果要在N个类别中对数据点进行分类，则网络最后一层应为大小为N的Dense层。</li><li>在单标签，多类分类问题中，网络应以softmax激活结束，这样可以输出在N个类别上的概率分布。</li><li><strong>分类交叉熵</strong>几乎总是针对多分类问题使用的损失函数，它使网络输出的概率分布与目标的真实分布之间的距离最小化。</li><li>如果需要将数据划分为大量类别，则应避免使用较小的中间层，而在网络中导致信息瓶颈（永久地丢失信息）。</li></ul><p>本例使用路透社数据集。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多分类问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> reuters</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = reuters.load_data(</span><br><span class="line">    num_words=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span><span class="params">(sequences, dimension=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    results = np.zeros((len(sequences), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> enumerate(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)</span><br><span class="line">x_test = vectorize_sequences(test_data)</span><br><span class="line"><span class="comment">#分类编码</span></span><br><span class="line">one_hot_train_labels = to_categorical(train_labels)</span><br><span class="line">one_hot_test_labels = to_categorical(test_labels)</span><br><span class="line"><span class="comment">#将标签转化为整数张量</span></span><br><span class="line"><span class="comment"># y_train = np.array(train_labels)</span></span><br><span class="line"><span class="comment"># y_test = np.array(test_labels)</span></span><br><span class="line"></span><br><span class="line">x_val = x_train[:<span class="number">1000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">1000</span>:]</span><br><span class="line">y_val = one_hot_train_labels[:<span class="number">1000</span>]</span><br><span class="line">partial_y_train = one_hot_train_labels[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,      <span class="comment">#分类交叉熵</span></span><br><span class="line">              metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line">loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">epochs = range(<span class="number">1</span>, len(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">'b'</span>, label=<span class="string">'Validation loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">'acc'</span>]</span><br><span class="line">val_acc = history.history[<span class="string">'val_acc'</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">'bo'</span>, label=<span class="string">'Training acc'</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">'b'</span>, label=<span class="string">'Validation acc'</span>)</span><br><span class="line">plt.title(<span class="string">'Training and validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/21/YbAsqs.png" alt="训练损失和验证损失"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/21/YbA6Zn.png" alt="训练精度和验证精度"></th></tr></thead></table><p>由上图可见，网络在训练9轮后开始过拟合，重新进行训练并进行评估。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">9</span>,</span><br><span class="line">          batch_size=<span class="number">512</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br><span class="line">results = model.evaluate(x_test, one_hot_test_labels)</span><br></pre></td></tr></table></figure><p>在新数据上进行评估。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">predictions = model.predict(x_test)</span><br></pre></td></tr></table></figure><h3 id="预测房价：回归问题"><a href="#预测房价：回归问题" class="headerlink" title="预测房价：回归问题"></a>预测房价：回归问题</h3><p>前面两种分类问题目标是预测输入数据点所对应的单一离散的标签，而回归问题预测一个连续值而不是离散的标签，如根据气象数据预测明天的气温。<br>本例采用波士顿房价数据集，每个样本有多个数据特征，如犯罪率、每个住宅的平均房间数等。目标是房屋价格的中位数，单位千美元。<br>注意：</p><ul><li>本例的每个特征几乎都有不同的取值范围，应当对每个特征值做标准化，如减去特征平均值再除以标准差。</li><li>回归问题常用的损失函数为均方误差（MSE，mean squared error），预测值与目标值之差的平方。</li><li>回归问题使用的评估指标（metrics）为平均绝对误差（MAE，mean absolute error）预测值与目标值之差的绝对值。</li><li>若可用数据很少，使用K折验证可以可靠地评估模型。</li><li>若可用的训练数据很少，最好使用隐藏层较少（1到2个）的网络，避免严重的过拟合</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回归问题</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> boston_housing</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">(train_data, train_targets), (test_data, test_targets) = boston_housing.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment">#特征值标准化</span></span><br><span class="line">mean = train_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">train_data -= mean</span><br><span class="line">std = train_data.std(axis=<span class="number">0</span>)</span><br><span class="line">train_data /= std</span><br><span class="line"></span><br><span class="line">mean1 = test_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">test_data -= mean1</span><br><span class="line">std1 = test_data.std(axis=<span class="number">0</span>)</span><br><span class="line">test_data /= std1</span><br><span class="line"></span><br><span class="line"><span class="comment">#因为要将同一个模型多次实例化，故用一个函数来构建模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = models.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>,</span><br><span class="line">                           input_shape=(train_data.shape[<span class="number">1</span>],)))</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))                                      <span class="comment">#线性层，标量回归</span></span><br><span class="line">    model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'mse'</span>, metrics=[<span class="string">'mae'</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">#K折验证</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">num_val_samples = len(train_data) // k</span><br><span class="line"><span class="comment"># num_epochs = 100</span></span><br><span class="line"><span class="comment"># all_scores = []</span></span><br><span class="line">num_epochs = <span class="number">500</span></span><br><span class="line">all_mae_histories = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    print(<span class="string">'processing fold #'</span>, i)</span><br><span class="line">    <span class="comment">#准备验证数据：第k个分区的数据</span></span><br><span class="line">    val_data = train_data[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    val_targets = train_targets[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#准备训练数据：其他所有分区的数据</span></span><br><span class="line">    partial_train_data = np.concatenate(</span><br><span class="line">        [train_data[:i * num_val_samples],</span><br><span class="line">         train_data[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    partial_train_targets = np.concatenate(</span><br><span class="line">        [train_targets[:i * num_val_samples],</span><br><span class="line">         train_targets[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    model = build_model()</span><br><span class="line">    <span class="comment"># model.fit(partial_train_data, partial_train_targets,</span></span><br><span class="line">    <span class="comment">#           epochs=num_epochs, batch_size=1, verbose=0)</span></span><br><span class="line">    <span class="comment"># val_mse, val_mae = model.evaluate(val_data, val_targets, verbose=0)</span></span><br><span class="line">    <span class="comment"># all_scores.append(val_mae)</span></span><br><span class="line">    <span class="comment"># mean_scores = np.mean(all_scores)</span></span><br><span class="line"></span><br><span class="line">    history = model.fit(partial_train_data, partial_train_targets,</span><br><span class="line">                        validation_data=(val_data, val_targets),</span><br><span class="line">                        epochs=num_epochs, batch_size=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    print(history.history.keys())</span><br><span class="line">    mae_history = history.history[<span class="string">'val_mae'</span>]</span><br><span class="line">    all_mae_histories.append(mae_history)</span><br><span class="line"></span><br><span class="line">average_mae_history = [</span><br><span class="line">    np.mean([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> all_mae_histories]) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_epochs)]</span><br><span class="line"></span><br><span class="line">plt.plot(range(<span class="number">1</span>, len(average_mae_history) + <span class="number">1</span>), average_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Validation MAE'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#将每个数据点替换为前面数据点的指数移动平均值，以得到光滑曲线。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth_curve</span><span class="params">(points, factor=<span class="number">0.9</span>)</span>:</span></span><br><span class="line">  smoothed_points = []</span><br><span class="line">  <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    <span class="keyword">if</span> smoothed_points:</span><br><span class="line">      previous = smoothed_points[<span class="number">-1</span>]</span><br><span class="line">      smoothed_points.append(previous * factor + point * (<span class="number">1</span> - factor))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      smoothed_points.append(point)</span><br><span class="line">  <span class="keyword">return</span> smoothed_points</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除前10个数据点</span></span><br><span class="line">smooth_mae_history = smooth_curve(average_mae_history[<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.plot(range(<span class="number">1</span>, len(smooth_mae_history) + <span class="number">1</span>), smooth_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Validation MAE'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="https://s1.ax1x.com/2020/05/21/YqbxS0.png" alt="每轮的验证MAE"></th><th align="center"><img src="https://s1.ax1x.com/2020/05/21/YqqSyT.png" alt="重绘后的每轮的验证MAE"></th></tr></thead></table><p>由上图可知，验证MAE在80轮后不再显著降低，之后开始过拟合，调整参数在训练数据上训练参数。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model = build_model()</span><br><span class="line">model.fit(train_data, train_targets,</span><br><span class="line">          epochs=<span class="number">80</span>, batch_size=<span class="number">16</span>, verbose=<span class="number">0</span>)</span><br><span class="line">test_mse_score, test_mae_score = model.evaluate(test_data, test_targets)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_mae_score</span><br><span class="line"><span class="number">2.6759588718414307</span></span><br></pre></td></tr></table></figure><h2 id="Chapter-4-机器学习基础"><a href="#Chapter-4-机器学习基础" class="headerlink" title="Chapter 4 机器学习基础"></a>Chapter 4 机器学习基础</h2><h3 id="机器学习的四个分支"><a href="#机器学习的四个分支" class="headerlink" title="机器学习的四个分支"></a>机器学习的四个分支</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>最常见的机器学习类型，给定一组样本（通常由人工标注），学习将输入数据映射到已知目标。主要包括分类和回归问题，如光学字符识别、语音识别、图像分类以及语言翻译。另外包括一些主要的变体如下</p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><h3 id="机器学习通用工作流程"><a href="#机器学习通用工作流程" class="headerlink" title="机器学习通用工作流程"></a>机器学习通用工作流程</h3><h4 id="定义问题，收集数据集"><a href="#定义问题，收集数据集" class="headerlink" title="定义问题，收集数据集"></a>定义问题，收集数据集</h4><h4 id="选择衡量成功的指标"><a href="#选择衡量成功的指标" class="headerlink" title="选择衡量成功的指标"></a>选择衡量成功的指标</h4><h4 id="确定评估方法"><a href="#确定评估方法" class="headerlink" title="确定评估方法"></a>确定评估方法</h4><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><h4 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h4><h4 id="模型正则化与调节超参数"><a href="#模型正则化与调节超参数" class="headerlink" title="模型正则化与调节超参数"></a>模型正则化与调节超参数</h4><h2 id="Chapter-5-卷积神经网络"><a href="#Chapter-5-卷积神经网络" class="headerlink" title="Chapter 5 卷积神经网络"></a>Chapter 5 卷积神经网络</h2><p>一个简单的卷积神经网络示例。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#卷积神经网络</span></span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models, layers</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line">train_images = train_images.reshape((<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">train_images = train_images.astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">test_images = test_images.reshape((<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">test_images = test_images.astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">train_labels = to_categorical(train_labels)</span><br><span class="line">test_labels = to_categorical(test_labels)</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># model.summary()</span></span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">5</span>, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">test_loss, test_acc = model.evaluate(test_images, test_labels)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_acc</span><br><span class="line"><span class="number">0.9919000267982483</span></span><br></pre></td></tr></table></figure><h2 id="Windows下的环境搭建"><a href="#Windows下的环境搭建" class="headerlink" title="Windows下的环境搭建"></a><span id="jump">Windows下的环境搭建</span></h2><p>由于懒得装双系统，虚拟机先不说配置不够，搭起来感觉坑很多，遂直接在Windows系统下搭建。</p><h3 id="安装CUDA和cuDNN"><a href="#安装CUDA和cuDNN" class="headerlink" title="安装CUDA和cuDNN"></a>安装CUDA和cuDNN</h3><blockquote><p>CUDA（Compute Unified Device Architecture）：NVIDIA用于自家GPU的并行计算框架，本质是一个工具包（ToolKit）。</p></blockquote><blockquote><p>cuDNN（CUDA Deep Neural Network library）：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。用GPU训练模型，cuDNN不是必须的，但是一般会采用这个加速库。</p></blockquote><ol><li><p>查看显卡支持的CUDA版本<br>NVIDIA控制面板&gt;帮助&gt;系统信息&gt;组件，如图支持10.2版本<br><img src="https://s1.ax1x.com/2020/05/17/Y20vQK.png" alt=""></p></li><li><p>安装对应版本的CUDA</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></p></blockquote><blockquote><p>安装完成后打开cmd，输入命令：<code>nvcc -V</code>，如图</p><img src="https://s1.ax1x.com/2020/05/17/Y2yrUe.png" style="margin-left:0" alt=""></blockquote></li><li><p>编译CUDA（暂时未编译）</p></li><li><p>安装cuDNN</p><blockquote><p>下载地址：<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p></blockquote><blockquote><p>这里需要注册账户才可以下载，可以看到支持的对应CUDA版本<br>将解压后的文件复制到CUDA安装路径中，这里是默认路径<br><code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1</code></p></blockquote></li></ol><h3 id="安装TensorFlow和Keras"><a href="#安装TensorFlow和Keras" class="headerlink" title="安装TensorFlow和Keras"></a>安装TensorFlow和Keras</h3><p>由于本机已经安装过Python3.7，管理多版本Python有点麻烦，故直接<strong>使用pip安装</strong>而不是Anaconda<br>在用pip安装前，<strong>确保pypi源更换为国内镜像</strong>，否则速度超级慢</p><blockquote><p>方法为在C盘的user目录下新建一个pip文件夹，如：C:\Users\xx\pip，在pip文件夹内新建一个pip.ini文件，内容如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>常用国内镜像：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;   # 清华大学</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;     # 阿里云</span><br><span class="line">https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;             # 豆瓣</span><br><span class="line">https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;    # 中国科学技术大学</span><br><span class="line">https:&#x2F;&#x2F;pypi.hustunique.com&#x2F;                # 华中科技大学</span><br></pre></td></tr></table></figure><p></p></blockquote><ol><li>安装Tensorflow<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>安装完成后在python环境中运行<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tf</span><span class="selector-class">.test</span><span class="selector-class">.is_gpu_available</span>()</span><br></pre></td></tr></table></figure>可以查看到GPU信息即安装成功。<br>Tensorflow作为Keras的后端,TensorFlow与CUDA和cuDNN各版本对应如下：<br><img src="https://s1.ax1x.com/2020/05/17/Y24DV1.png" alt=""></li><li>安装Keras<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> keras</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装其他组件"><a href="#安装其他组件" class="headerlink" title="安装其他组件"></a>安装其他组件</h3><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonic Coding</title>
    <url>/post/Python/effective-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Effective Python》学习笔记<a id="more"></a></p><h2 id="程序风格"><a href="#程序风格" class="headerlink" title="程序风格"></a><center>程序风格</center></h2><h3 id="遵循PEP8风格指南"><a href="#遵循PEP8风格指南" class="headerlink" title="遵循PEP8风格指南"></a>遵循PEP8风格指南</h3><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">《Python Enhancement Proposal #8》</a>，简称PEP8，是针对Python代码格式编订的风格指南。</p><h3 id="bytes、str与unicode区别"><a href="#bytes、str与unicode区别" class="headerlink" title="bytes、str与unicode区别"></a>bytes、str与unicode区别</h3><h4 id="首先区分Python3与Python2的两种表示字符序列的类型"><a href="#首先区分Python3与Python2的两种表示字符序列的类型" class="headerlink" title="首先区分Python3与Python2的两种表示字符序列的类型"></a>首先区分Python3与Python2的两种表示字符序列的类型</h4><ul><li>Python3，bytes与str，前者的实例包含原始的8位值，即原始的字节，包含8个二进制位；后者的实例包含Unicode字符</li><li>Python2，str与unicode，前者的实例包含原始的8位值；后者的实例包含Unicode字符</li></ul><h4 id="二进制数据与Unicode字符相互转换"><a href="#二进制数据与Unicode字符相互转换" class="headerlink" title="二进制数据与Unicode字符相互转换"></a>二进制数据与Unicode字符相互转换</h4><p>常见编码方式为UTF-8<br>Unicode字符 → 二进制数据，encode()方法<br>二进制数据 → Unicode字符，decode()方法</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>Python程序中，编码和解码操作放在程序外围，核心部分使用Unicode字符类型</li><li>在只处理7位ASCII时，Python2的str和unicode类型的实例可以等价，而Python3中bytes与str的实例绝对不等价</li><li>Python3中，使用内置open()函数获取文件句柄，该句柄默认采用UTF-8格式来操作文件，问题在于Python3给open()函数添加了名为encoding的新参数，其默认值为’utf-8’，要求必须传入包含Unicode字符的str实例，而不接受包含二进制数据的bytes实例<br>总结为必须使用二进制写入模式open(path, ‘wb’)来开启待操作文件</li></ul><h3 id="用辅助函数取代复杂表达式"><a href="#用辅助函数取代复杂表达式" class="headerlink" title="用辅助函数取代复杂表达式"></a>用辅助函数取代复杂表达式</h3><p>如，从字典中查询并返回得到的第一个整数值:<br><code>red = my_values.get(&#39;red&#39;, [&#39;&#39;])[0] or 0</code><br>未查询到或值为0为空统一返回0，该表达式不易理解，若要频繁使用，将其总结为辅助函数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_int</span><span class="params">(values, key, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">    found =values.get(key, [<span class="string">''</span>])</span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        found = int(found[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = default</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">red = get_first_int(my_values, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><p>somelist[start:end]，其中start所指元素涵盖在切割后的范围内，end所指元素不包括在切割结果之中。例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start从0开始，end倒数从-1开始</span></span><br><span class="line">a[:]                                    <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line">a[:<span class="number">3</span>]                                   <span class="comment">#[1,2,3]</span></span><br><span class="line">a[<span class="number">2</span>:]                                   <span class="comment">#[3,4,5,6]</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]                                  <span class="comment">#[3,4,5]</span></span><br><span class="line">a[<span class="number">-3</span>:<span class="number">-1</span>]                                <span class="comment">#[4,5]</span></span><br></pre></td></tr></table></figure><p>切割列表时，start和end越界不会出问题，利用该特性可以限定输入序列的最大长度。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">first_nine_items</span> = a[:<span class="number">9</span>]</span><br><span class="line"><span class="attr">last_nine_items</span> = a[<span class="number">9</span>:]</span><br></pre></td></tr></table></figure><p>切片后不影响原列表，对list赋值，若使用切片操作，会把原列表处在相关范围内的值替换为新值，即便长度不同也可以替换。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">1</span>]                          <span class="comment">#[1,2,1,1,6]</span></span><br><span class="line">a[:] = [<span class="number">1</span>,<span class="number">1</span>]                            <span class="comment">#[1,1]</span></span><br></pre></td></tr></table></figure><h4 id="步进式切割"><a href="#步进式切割" class="headerlink" title="步进式切割"></a>步进式切割</h4><p>somelist[start:end:stride]</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">odds = a[::<span class="number">2</span>]</span><br><span class="line">evens = a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">b = <span class="string">b'abc'</span></span><br><span class="line">reverse = b[::<span class="number">-1</span>]                       <span class="comment">#负值为反向步进</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>负步长只对字节串和ASCII字符有效，对已编码成UTF-8字节串的Unicode字符无效</li><li>尽量使用stride为正数，且不带start和end索引</li><li>同一切片操作内，不要同时指定start、end和stride，考虑将其拆解为一条步进切割，一条范围切割</li></ul><h3 id="列表与迭代"><a href="#列表与迭代" class="headerlink" title="列表与迭代"></a>列表与迭代</h3><h4 id="用列表推导取代map和filter"><a href="#用列表推导取代map和filter" class="headerlink" title="用列表推导取代map和filter"></a>用列表推导取代map和filter</h4><p><strong>列表推导</strong>(list comprehension)，根据一份列表来制作另外一份。<br><strong>字典</strong>(dict)与<strong>集</strong>(set)也支持推导表达式</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用map，创建lambda函数，结合filter</span></span><br><span class="line">squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a)</span><br><span class="line">even_squares = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用列表推导</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="列表推导内含的表达式不宜超过两个"><a href="#列表推导内含的表达式不宜超过两个" class="headerlink" title="列表推导内含的表达式不宜超过两个"></a>列表推导内含的表达式不宜超过两个</h4><p>列表推导支持多重循环</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵简化为一维列表</span></span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]                  <span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]          <span class="comment">#[[1, 4, 9], [16, 25, 36], [49, 64, 81]]</span></span><br></pre></td></tr></table></figure><p>每一级循环也支持多重条件</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处在同一循环级别中的多项条件， 彼此之间默认形成and表达式</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#从矩阵中取出本身能被3整除，且其所在行所有元素之和大于等于10的元素</span></span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>] </span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h4 id="用生成器表达式改写数据量较大的列表推导"><a href="#用生成器表达式改写数据量较大的列表推导" class="headerlink" title="用生成器表达式改写数据量较大的列表推导"></a>用生成器表达式改写数据量较大的列表推导</h4><p>首先，列表推导的缺点是：<br>在推导过程中，对于输入序列中的每个值，可能都要创建一个仅含一个元素的新列表，若输入数据量较大，会消耗大量内存。<br>如，读取一份文件并返回每行的字符数，采用列表推导</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file)]</span><br></pre></td></tr></table></figure><p><strong>生成器表达式</strong>(generator expression)：<br>对列表推导和生成器的一种<strong>泛化</strong>(generalization)，生成器表达式运行时，不会呈现整个输出序列，而是估值为<strong>迭代器</strong>(iterator)，该迭代器每次根据生成器表达式产生一项数据。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器表达式，立刻返回一个迭代器</span></span><br><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(file))</span><br><span class="line">next(it)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器表达式可以互相组合</span></span><br><span class="line">roots = ((x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure><h4 id="用enumerate取代range"><a href="#用enumerate取代range" class="headerlink" title="用enumerate取代range"></a>用enumerate取代range</h4><p>enumerate可以把各种迭代器包装为生成器，可以在遍历迭代器时获得每个元素的索引，在同时需要下标和值的时候使用。如range</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_num)):</span><br><span class="line">    num = list_num[i]</span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i+<span class="number">1</span>, num))</span><br></pre></td></tr></table></figure><p>使用enumerate</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerator(list_num, <span class="number">1</span>):                  <span class="comment">#起始下标指定为1</span></span><br><span class="line">    print(<span class="string">'%d:%s'</span>, %(i, num))</span><br></pre></td></tr></table></figure><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><p>Python3中的zip函数，能将两个及以上的迭代器封装为生成器，在遍历过程中逐次产生元组。<br>Python2中，直接产生所有元组，并一次性返回整份列表<br>若提供的迭代器长度不等，zip会提前自动终止</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'adad'</span>, <span class="string">'bob'</span>, <span class="string">'alen'</span>]</span><br><span class="line">letters = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, letter <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    print(name+str(letter))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><center>函数</center></h2><p>函数的问题主要体现在<strong>参数</strong>、<strong>作用域</strong>、<strong>返回值</strong>三个方面</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="在闭包里使用外围作用域中的变量"><a href="#在闭包里使用外围作用域中的变量" class="headerlink" title="在闭包里使用外围作用域中的变量"></a>在闭包里使用外围作用域中的变量</h4><p>注意：</p><ul><li>Python支持闭包（closure）：闭包是定义在某个作用域中的函数，可以引用那个作用域中的变量。</li><li>Python的函数时一级对象，可以直接引用函数、将函数赋给变量或者将函数作为参数传递。</li></ul><p>例如，对一份数字列表进行排序，要求出现的特定数字在其他数字排序之前。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sort_priority(numbers, group)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>稍作修改为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">found = sort_priority2(numbers, group)</span><br><span class="line">print(found)</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>found的输出结果与预期的True不符，这里我们首先要了解，在表达式中引用变量，Python解释器遵循以下顺序遍历各作用域：</p><ul><li>当前函数作用域</li><li>任何外围作用域（如包含当前函数的其他函数）</li><li>包含当前代码的那个模块的作用域（全局作用域，global scope）</li><li>内置作用域（包含str及len等函数的那个作用域）</li><li>未定义过名称相符变量，抛出NameError异常</li></ul><p>sort_priority2函数中将found赋值为True是在闭包函数helper内进行的，实则是在闭包函数的作用域中定义了一个found变量并赋值为True，与其外围函数sort_priority2作用域中定义的found不同，最后返回的是sort_priority2中赋值为False的found变量。<br>因此，我们需要获取闭包内的数据，可使用nonlocal语句，不支持Python2</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found                  <span class="comment">#声明该found为闭包外围作用域中的found</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>而实际开发中，nonlocal容易遭到滥用，且副作用难以追踪，难以理解，不适用于较长较复杂的函数。有以下两个解决办法：</p><ol><li>将相关状态封装为辅助类<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">            self.found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">group = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">66</span>]</span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br><span class="line">print(sorter.found)</span><br></pre></td></tr></table></figure></li><li>用Python的作用域规则，Python2可用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, groups)</span>:</span></span><br><span class="line">    found = [<span class="literal">False</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="尽量用异常表示特殊情况，而非返回None"><a href="#尽量用异常表示特殊情况，而非返回None" class="headerlink" title="尽量用异常表示特殊情况，而非返回None"></a>尽量用异常表示特殊情况，而非返回None</h4>例如，两数相除的情况。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:                              <span class="comment">#这种情况没有问题</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:                                  <span class="comment">#错误情况</span></span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure>当分子为0时not result结果为True，结果应为0，却显示Invalid inputs。用异常来表示这种情况：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Result is %.1f'</span> % result)</span><br></pre></td></tr></table></figure><h4 id="用生成器改写直接返回列表的函数"><a href="#用生成器改写直接返回列表的函数" class="headerlink" title="用生成器改写直接返回列表的函数"></a>用生成器改写直接返回列表的函数</h4>若函数产生一系列结果，最简单的方法是返回一个包含所有结果的列表，此方法主要有两个缺点：</li></ol><ul><li>代码拥挤，不清晰</li><li>返回前将所有结果放在列表里，若输入量非常大，会导致内存耗尽</li></ul><p>例如以下函数返回字符串中每个单词首字母的位置。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            result.append(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = index_words(text)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>用生成器改写：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">yield</span> index+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">'seven years ago'</span></span><br><span class="line">result = list(index_words(text))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python自动化控制鼠标和键盘</title>
    <url>/post/Python/auto-gui-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文档：<a href="https://pyautogui.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/</a><a id="more"></a></p><h2 id="安装pyautogui模块"><a href="#安装pyautogui模块" class="headerlink" title="安装pyautogui模块"></a>安装pyautogui模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure><h2 id="鼠标操作模拟"><a href="#鼠标操作模拟" class="headerlink" title="鼠标操作模拟"></a>鼠标操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">width, height = pyautogui.size()            <span class="comment">#返回屏幕宽高像素数的元组</span></span><br><span class="line">pyautogui.position()                        <span class="comment">#返回鼠标当前位置元组</span></span><br><span class="line"></span><br><span class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置移动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.moveRel(<span class="number">100</span>, <span class="number">-1</span>, duration=<span class="number">1</span>)      <span class="comment">#相对位置移动。参数为右,左,时间可选秒数</span></span><br><span class="line"></span><br><span class="line">pyautogui.click(<span class="number">100</span>, <span class="number">200</span>, button=<span class="string">'middle'</span>)    <span class="comment">#完整的单击.默认鼠标左键单击当前位置</span></span><br><span class="line">pyautogui.mouseDown(button=left)            <span class="comment">#按下鼠标按键</span></span><br><span class="line">pyautogui.mouseUp(<span class="number">100</span>, <span class="number">200</span>)                 <span class="comment">#松开鼠标按键</span></span><br><span class="line">pyautogui.doubleClick()                     <span class="comment">#双击鼠标左键</span></span><br><span class="line">pyautogui.middleClick()                     <span class="comment">#单击鼠标中键</span></span><br><span class="line"></span><br><span class="line">pyautogui.dragTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">1.5</span>)    <span class="comment">#绝对位置拖动，参数为x,y,time可选秒数</span></span><br><span class="line">pyautogui.dragRel(<span class="number">100</span>, <span class="number">-1</span>, button=<span class="string">'middle'</span>) <span class="comment">#相对位置拖动。参数为右,左,button可选默认左键</span></span><br><span class="line"></span><br><span class="line">pyautogui.scroll(<span class="number">-200</span>)                      <span class="comment">#鼠标滚轮上下滚动</span></span><br></pre></td></tr></table></figure><h2 id="处理屏幕"><a href="#处理屏幕" class="headerlink" title="处理屏幕"></a>处理屏幕</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">im = pyautogui.screenshot()                 <span class="comment">#返回包含屏幕快照的Image对象</span></span><br><span class="line">im.getpixel((x,y))                          <span class="comment">#返回坐标处像素颜色的RGB元组</span></span><br><span class="line">pyautogui.pixelMatchesColor(x, y, (R, G, B))<span class="comment">#比较(x,y)处与RGB的颜色是否相同</span></span><br><span class="line"></span><br><span class="line">pyautogui.locateOnScreen(<span class="string">'screenshot.png'</span>)  <span class="comment">#参数或为region=(0,0, 300, 400)</span></span><br><span class="line"><span class="comment">#返回screenshot.png匹配当前屏幕成功的图像左边的x坐标，顶边的y坐标，宽度和高度元组</span></span><br><span class="line">pyautogui.center((<span class="number">0</span>,<span class="number">0</span>, <span class="number">300</span>, <span class="number">400</span>))           <span class="comment">#返回中心坐标</span></span><br><span class="line">pyautogui.click((<span class="number">150</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h2 id="键盘操作模拟"><a href="#键盘操作模拟" class="headerlink" title="键盘操作模拟"></a>键盘操作模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line">pyautogui.typewrite(<span class="string">'test'</span>,<span class="number">0.25</span>)            <span class="comment">#发送单个字符表示的虚拟按键,间隔0.25秒</span></span><br><span class="line">pyautogui.typewrite([<span class="string">'a'</span>, <span class="string">'b'</span>])               <span class="comment">#键名作为参数</span></span><br><span class="line"></span><br><span class="line">pyautogui.keyDown(<span class="string">'ctrl'</span>)</span><br><span class="line">pyautogui.press(<span class="string">'c'</span>)</span><br><span class="line">pyautogui.keyUp(<span class="string">'ctrl'</span>)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><p>键名:<a href="https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys" target="_blank" rel="noopener">https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys</a></p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Auto-GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python处理Excel，CSV和JSON</title>
    <url>/post/Python/excel-csv-json-with-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Python处理Excel，CSV文件和JSON文件<a id="more"></a></p><h2 id="python处理excel"><a href="#python处理excel" class="headerlink" title="python处理excel"></a>python处理excel</h2><p>文档：<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://openpyxl.readthedocs.io/en/stable/</a></p><h3 id="安装openpyxl模块"><a href="#安装openpyxl模块" class="headerlink" title="安装openpyxl模块"></a>安装openpyxl模块</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> openpyxl</span><br></pre></td></tr></table></figure><h3 id="读取excel"><a href="#读取excel" class="headerlink" title="读取excel"></a>读取excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)     <span class="comment">#返回Workbook对象</span></span><br><span class="line">wb.sheetnames                                           <span class="comment">#返回所有工作表名称的字符串列表</span></span><br><span class="line"></span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]                                     <span class="comment">#wb.get_sheet_by_name('Sheet')</span></span><br><span class="line">sheet1 = wb.active</span><br><span class="line"></span><br><span class="line">sheet[<span class="string">'A'</span>]                                              <span class="comment">#返回第一列</span></span><br><span class="line">sheet[<span class="string">'A1'</span>].value                                       <span class="comment">#.row .column .coordinate(r+c)</span></span><br><span class="line">sheet.cell(row=<span class="number">1</span>, column=<span class="number">1</span>).value</span><br><span class="line">sheet.max_row                                           <span class="comment">#返回一个整数.max_column</span></span><br><span class="line"></span><br><span class="line">openpyxl.cell.column_index_from_string()                <span class="comment">#列字母转换为数字，A→1</span></span><br><span class="line">openpyxl.cell.get_column_letter()                       <span class="comment">#数字转换为列字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切片，遍历</span></span><br><span class="line"><span class="keyword">for</span> rowObj <span class="keyword">in</span> sheet[<span class="string">'A1'</span>:<span class="string">'D14'</span>]:                        <span class="comment">#每个元组代表一行，按行遍历整个区域</span></span><br><span class="line">    <span class="keyword">for</span> cellObj <span class="keyword">in</span> rowObj:                              <span class="comment">#遍历行中的每个单元格</span></span><br><span class="line">        print(cellObj.coordinate, cellObj.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cellObj <span class="keyword">in</span> list(sheet.rows)[<span class="number">0</span>]:                     <span class="comment">#按行按列遍历,或者 sheet[1] | sheet['A']</span></span><br><span class="line">    print(cellObj.value)</span><br></pre></td></tr></table></figure><h3 id="写入excel"><a href="#写入excel" class="headerlink" title="写入excel"></a>写入excel</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">wb = openpyxl.Workbook()                                <span class="comment">#新建一个空的Workbook对象</span></span><br><span class="line">sheet = wb.active</span><br><span class="line">sheet.title = <span class="string">'test'</span></span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'test'</span>                                    <span class="comment">#将值写入单元格</span></span><br><span class="line"></span><br><span class="line">wb.create_sheet(index=<span class="number">0</span>, title=<span class="string">'ttest'</span>)                 <span class="comment">#新建一个工作表，返回Worksheet对象</span></span><br><span class="line">wb.remove(wb[<span class="string">'Sheet'</span>])                                  <span class="comment">#接受一个Worksheet对象作为其参数</span></span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test.xlsx'</span>)                         <span class="comment">#保存变更，不同名或不同位置会创建副本</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="更新excel表"><a href="#更新excel表" class="headerlink" title="更新excel表"></a>更新excel表</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line">update_data = &#123;<span class="string">'apple'</span>:<span class="number">5</span>,</span><br><span class="line">               <span class="string">'lemon'</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="string">'orange'</span>:<span class="number">2</span>&#125;                              <span class="comment">#待更新数据保存在字典中</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'C:\\Users\\test.xlsx'</span>)</span><br><span class="line">sheet = wb[<span class="string">'Sheet'</span>]</span><br><span class="line"><span class="keyword">for</span> rowNum <span class="keyword">in</span> range(<span class="number">2</span>, sheet.max_row+<span class="number">1</span>):</span><br><span class="line">    updatedName = sheet.cell(row=rowNum, column=<span class="number">1</span>).value</span><br><span class="line">    <span class="keyword">if</span> updatedName <span class="keyword">in</span> update_data:</span><br><span class="line">        sheet.cell(row=rowNum, column=<span class="number">2</span>).value = update_data[updatedName]</span><br><span class="line">wb.save(<span class="string">'C:\\Users\\test_updated.xlsx'</span>)</span><br></pre></td></tr></table></figure><h4 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font</span><br><span class="line">fontObj = Font(name=<span class="string">'Calibri'</span>, size=<span class="number">12</span>, bold=true, italic=true)</span><br><span class="line">sheet[<span class="string">'A1'</span>].font = fontObj</span><br></pre></td></tr></table></figure><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="行高列宽"><a href="#行高列宽" class="headerlink" title="行高列宽"></a>行高列宽</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">0</span><span class="number">-409</span></span><br><span class="line">sheet.column_dimensions[<span class="string">'A'</span>].width = <span class="number">0</span><span class="number">-255</span></span><br></pre></td></tr></table></figure><h4 id="合并拆分冻结"><a href="#合并拆分冻结" class="headerlink" title="合并拆分冻结"></a>合并拆分冻结</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sheet.merge_cells(<span class="string">'A1:D3'</span>)</span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'merged'</span>                                    <span class="comment">#合并后单元格的值</span></span><br><span class="line"></span><br><span class="line">sheet.unmerge_cells(<span class="string">'A1:A2'</span>)</span><br><span class="line"></span><br><span class="line">sheet.freeze_panes = <span class="string">'A2'</span>                                 <span class="comment">#冻结左上部分</span></span><br></pre></td></tr></table></figure><h2 id="python处理CSV文件"><a href="#python处理CSV文件" class="headerlink" title="python处理CSV文件"></a>python处理CSV文件</h2><h3 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h3><p>csv全称’Comma-Separated Values‘，每行对应电子表格中的一行，单元格之间用逗号分隔。</p><ul><li>值没有类型，全为字符串</li><li>无多个工作表</li><li>不能嵌入图像或图表</li><li>无字体大小和颜色设置</li><li>无法操作单元格，宽高合并等</li></ul><h3 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>)                               <span class="comment">#返回一个File对象</span></span><br><span class="line">fileReader = csv.reader(openFile)                         <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileData = list(fileReader)                               <span class="comment">#fileData[0][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> fileReader:</span><br><span class="line">    print(<span class="string">'row'</span>+str(fileReader.line_num)+str(row))        <span class="comment">#对于大型CSV文件，避免将文件一次性装入内存</span></span><br></pre></td></tr></table></figure><h3 id="Write对象"><a href="#Write对象" class="headerlink" title="Write对象"></a>Write对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">openFile = open(<span class="string">'test.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>)              <span class="comment">#返回一个File对象</span></span><br><span class="line">fileWrite = csv.writer(openFile)                          <span class="comment">#返回一个Reader对象，按行读取</span></span><br><span class="line">fileWrite.writerow([<span class="number">1</span>, <span class="string">'a,b'</span>, <span class="number">2</span>, <span class="string">'b'</span>])</span><br><span class="line">openfile.close()</span><br><span class="line"></span><br><span class="line">fileWrite = csv.writer(openFile, delimiter=<span class="string">'\t'</span>, lineterminator=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="comment">#delimiter指定分隔符 lineterminator指定行终止符，默认\n</span></span><br></pre></td></tr></table></figure><h2 id="python处理JSON文件"><a href="#python处理JSON文件" class="headerlink" title="python处理JSON文件"></a>python处理JSON文件</h2><p>JSON文件，全称JavaScript Object Notation，是JavaScript程序编写数据结构的原生方式，<br>JSON不能表示Pyton特有的对象，可以存储：字符串、整型、浮点型、布尔型、列表、字典和NoneType。</p><h3 id="loads"><a href="#loads" class="headerlink" title="loads()"></a>loads()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">jsonString = <span class="string">'&#123;"name":"asher", "isCat":true, "num":1&#125;'</span></span><br><span class="line">jsonData = json.loads(jsonString)                         <span class="comment">#返回一个Python字典</span></span><br></pre></td></tr></table></figure><h3 id="dumps"><a href="#dumps" class="headerlink" title="dumps()"></a>dumps()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">pythonData = <span class="string">'&#123;'</span>name<span class="string">':'</span>ashe<span class="string">r', '</span>isCat<span class="string">':True, '</span>num<span class="string">':1&#125;'</span></span><br><span class="line">jsonString = json.dumps(json)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Excel</tag>
        <tag>CSV</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式复习</title>
    <url>/post/tech/regex-review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式复习<a id="more"></a></p><h2 id="常用方法-参数"><a href="#常用方法-参数" class="headerlink" title="常用方法,参数"></a>常用方法,参数</h2><h3 id="group-and-findall"><a href="#group-and-findall" class="headerlink" title="group() and findall()"></a>group() and findall()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexDemo = re.compile(<span class="string">r'(\d)-(\d)'</span>) <span class="comment">#返回Regex对象, </span></span><br><span class="line">                                     <span class="comment">#r为原始字符串\不转义, </span></span><br><span class="line">                                     <span class="comment">#匹配括号须转义\(</span></span><br><span class="line">demo = regexDemo.search(<span class="string">''</span>) <span class="comment">#返回Match对象,仅包含第一次出现的文本</span></span><br><span class="line">demo1 = regexDemo.findall(<span class="string">''</span>) <span class="comment">#无分组返回一个字符串列表，有分组返回一个包含元组的列表，</span></span><br><span class="line">                              <span class="comment">#每一个元组对应一个字符串</span></span><br><span class="line">demo.group(<span class="number">0</span>) <span class="comment">#0 all but one, 1 first group, .groups() all</span></span><br></pre></td></tr></table></figure><h3 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">regexDemo</span><span class="selector-class">.sub</span>(<span class="string">'sub'</span>,<span class="string">'subed'</span>) <span class="selector-id">#sub</span>替换<span class="selector-tag">subed</span>里匹配的字符串</span><br></pre></td></tr></table></figure><h3 id="re-DOTALL"><a href="#re-DOTALL" class="headerlink" title="re.DOTALL"></a>re.DOTALL</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.DOTALL) <span class="comment">#可以匹配换行符</span></span><br></pre></td></tr></table></figure><h3 id="re-IGNORECASE-I"><a href="#re-IGNORECASE-I" class="headerlink" title="re.IGNORECASE/I"></a>re.IGNORECASE/I</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.*'</span>, re.I) <span class="comment">#不区分大小写</span></span><br></pre></td></tr></table></figure><h3 id="re-VERBOSE"><a href="#re-VERBOSE" class="headerlink" title="re.VERBOSE"></a>re.VERBOSE</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'''</span></span><br><span class="line"><span class="string">            .*  #test</span></span><br><span class="line"><span class="string">            \d+ #test1</span></span><br><span class="line"><span class="string">            '''</span>, re.VERBOSE) <span class="comment">#忽略regex中的空白符和注释 组合参数用 |</span></span><br></pre></td></tr></table></figure><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><h3><a href="#" class="headerlink" title="|"></a>|</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'a | b'</span>) <span class="comment">#匹配a或者b，同时出现匹配前者</span></span><br><span class="line">re.compile(<span class="string">r'a(aple | nchor)'</span>) <span class="comment">#匹配同一前缀</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)?man'</span>) <span class="comment">#匹配?前的分组wo零次或一次</span></span><br><span class="line">re.compile(<span class="string">r'bat(wo&#123;,5&#125;?)man'</span>) <span class="comment">#后加?表示非贪心匹配,最少0次</span></span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="*"></a>*</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配*前的分组wo零次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="+"></a>+</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)*man'</span>) <span class="comment">#匹配+前的分组wo一次或多次</span></span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title="{}"></a>{}</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'bat(wo)&#123;,5&#125;man'</span>) <span class="comment">#匹配&#123;&#125;前的分组wo指定次数(范围), 例中为0到5次 默认贪心匹配</span></span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title="^,$"></a>^,$</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[^bat]'</span>) <span class="comment">#匹配不包含^后的任意字符,如batman匹配mn</span></span><br><span class="line">re.compile(<span class="string">r'^\d+$'</span>) <span class="comment">#匹配从开始到结束都是数字的字符串</span></span><br></pre></td></tr></table></figure><h2 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h2><p>自定义</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'[0-9a-z]'</span>) <span class="comment">#[]内不需要转义</span></span><br></pre></td></tr></table></figure><h3 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="string">r'.at'</span>) <span class="comment">#匹配除换行外的任意一个字符，如cat，bat</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><tbody><tr><td>\d 0-9的任何数字</td><td align="center">\D 除0-9外的任何字符</td></tr><tr><td>\w 任何字母、数字和下划线</td><td align="center">\W 类比</td></tr><tr><td>\s 空格、制表符或换行符</td><td align="center">\S类比</td></tr></tbody></table></div><h2 id="常用Regex"><a href="#常用Regex" class="headerlink" title="常用Regex"></a>常用Regex</h2><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">emailRegex</span> = re.compile(r<span class="string">'''(</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9._%+-]+</span></span><br><span class="line"><span class="string">    @</span></span><br><span class="line"><span class="string">    [a-zA-Z0-9.-]+</span></span><br><span class="line"><span class="string">    \.[a-zA-Z]&#123;2,4&#125;</span></span><br><span class="line"><span class="string">    )'''</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Re-从零开始的Python学习</title>
    <url>/post/Python/Python-basis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python基础</p><a id="more"></a><p>学习Python之前，最好熟悉一下Python的语言和风格规范<br><a href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html" target="_blank" rel="noopener">https://google-styleguide.readthedocs.io/zh_CN/latest/google-python-styleguide/contents.html</a><br>原项目：<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">https://github.com/google/styleguide</a></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>指数:<code>2**3=8</code><br>取整:<code>22/8=2</code> <code>22/8=2.75</code><br>表达式=操作符+值（可归约为一个值）<code>！=</code>语句<br>布尔操作符:and,or,not</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整型(int),<br>浮点型(float),<br>字符串(str) ,<br><code>&#39;a&#39;+&#39;b&#39;=&#39;ab&#39;</code><br><code>&#39;a&#39;*3=&#39;aaa&#39;</code><br>布尔(Boolean),</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><code>spam = input() //返回字符串类型</code><br><code>len(&#39;&#39;) //返回整型</code><br><code>str(),int(),float() //只能进行一次类型转换，如int(&#39;0.1&#39;)不正确 int(0.1)=0</code></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line"><span class="built_in">os</span>.getcwd()                         #当前工作目录</span><br><span class="line"><span class="built_in">os</span>.chdir(<span class="string">'C:\\users'</span>)               #更改路径</span><br><span class="line"><span class="built_in">os</span>.makedirs(<span class="string">'C:\\users\\test'</span>)      #创建目录</span><br><span class="line"><span class="built_in">os</span>.listdir(<span class="string">''</span>)                      #返回路径中包含的所有文件及文件夹的字符串列表</span><br><span class="line"></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'usr'</span>,<span class="string">'bin'</span>,<span class="string">'spam'</span>)    #usr\bin\spam</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">'C:\\users'</span>,<span class="string">'a.txt'</span>)   #C:\users\a.txt</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.abspath(<span class="string">''</span>)                 #返回参数的绝对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isabs(<span class="string">''</span>)                   #参数为绝对路径返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.relpath(<span class="built_in">path</span>, start)        #返回从start路径到<span class="built_in">path</span>的相对路径的字符串形式</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.dirname(<span class="string">''</span>) </span><br><span class="line">+ <span class="built_in">os</span>.<span class="built_in">path</span>.basename(<span class="string">''</span>)              #<span class="string">'C:\\users'</span>+<span class="string">'test.exe'</span></span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.split(<span class="string">''</span>)                   #返回包含dirname和basename的字符串元组</span><br><span class="line"><span class="string">''</span>.split(<span class="built_in">os</span>.<span class="built_in">path</span>.sep)               #返回一个包含路径中各文件夹名称的字符串列表</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.getsize(<span class="string">''</span>)                 #返回文件的字节数</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.exists(<span class="string">''</span>)                  #文件或文件夹存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isfile(<span class="string">''</span>)                  #文件存在，返回True</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">path</span>.isdir(<span class="string">''</span>)                   #文件夹存在，返回True</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">file1</span> = open(<span class="string">''</span>，<span class="string">'w'</span>)               <span class="comment">#返回一个File对象，w写模式，a添加模式，r读模式</span></span><br><span class="line"><span class="attr">fileContent</span> = file1.read()</span><br><span class="line"><span class="attr">fileContent</span> = file1readlines()</span><br></pre></td></tr></table></figure><h3 id="文件复制删除"><a href="#文件复制删除" class="headerlink" title="文件复制删除"></a>文件复制删除</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import shutil,<span class="built_in">os</span></span><br><span class="line">shutil.copy(source, destination)    #复制单个文件，destination为文件名则复制后改名，下同</span><br><span class="line">shutil.copytree(source, destination)#复制整个文件夹及其包含的文件和文件夹</span><br><span class="line">shutil.move(source, destination)    #移动单个文件，同名会复写</span><br><span class="line"><span class="built_in">os</span>.unlink(<span class="built_in">path</span>)                     #永久删除<span class="built_in">path</span>处的文件</span><br><span class="line"><span class="built_in">os</span>.rmdir(<span class="built_in">path</span>)                      #永久删除<span class="built_in">path</span>出的文件夹，必须为空</span><br><span class="line">shutil.rmtree(<span class="built_in">path</span>)                 #永久删除<span class="built_in">path</span>处的文件夹及其包含的文件及文件夹，可用send2trash</span><br><span class="line"><span class="built_in">os</span>.<span class="built_in">rename</span>(oldname,newname)          #用<span class="built_in">os</span>模块中的<span class="built_in">rename</span>方法对文件改名</span><br></pre></td></tr></table></figure><h3 id="变量保存"><a href="#变量保存" class="headerlink" title="变量保存"></a>变量保存</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import shelve, pprint</span><br><span class="line">shelfFile = shelve.<span class="built_in">open</span>(<span class="string">''</span>)         <span class="comment">#用shelve模块保存变量</span></span><br><span class="line"><span class="built_in">value</span> = [<span class="string">''</span>,<span class="string">''</span>]</span><br><span class="line">shelfFile[<span class="string">'keys'</span>] = <span class="built_in">value</span>           <span class="comment">#将value列表保存在shelfFile中，关联keys键值</span></span><br><span class="line"><span class="comment">#pprint.pformat(value)              #将value列表转换为字符串写入文件</span></span><br><span class="line"><span class="comment">#shelfFile.write('')                </span></span><br><span class="line">shelfFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><h3 id="文件夹遍历"><a href="#文件夹遍历" class="headerlink" title="文件夹遍历"></a>文件夹遍历</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">os</span>.walk(path)                       <span class="comment">#返回path的当前文件夹名称的字符串，foldername</span></span><br><span class="line">                                    <span class="comment">#当前文件夹子文件夹字符串列表，subfoldernames</span></span><br><span class="line">                                    <span class="comment">#当前文件夹中的文件的字符串列表,filename</span></span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h3><p>异常发生时finally块的代码必定执行，可用于异常发生时执行清理工作，如确保程序能可靠的关闭文件句柄。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">handle = open(file)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = handle.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    handle.close()</span><br></pre></td></tr></table></figure><h3 id="else块"><a href="#else块" class="headerlink" title="else块"></a>else块</h3><p>try块没有发生异常，就执行else块的代码。如从字符串中加载JSON数据，返回字典中某个键对应的值。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_json_key</span><span class="params">(data, key)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_dict = json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> KeyError <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result_dict[key]</span><br></pre></td></tr></table></figure><h3 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test = <span class="string">'ok'</span></span><br><span class="line"><span class="keyword">assert</span> test == <span class="string">'ok'</span>, <span class="string">'The test need to be ok'</span>           <span class="comment">#解决赋值出错的定位问题</span></span><br></pre></td></tr></table></figure><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging                                          <span class="comment">#等级：DEBUG &lt;INFO &lt;WARNING &lt;ERROR &lt;CRITICAL</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">''</span>,level=logging.DEBUG, format=<span class="string">' %(asctime)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">logging.debug(<span class="string">'debug'</span>)</span><br><span class="line">logging.info(<span class="string">'info'</span>)</span><br><span class="line">logging.disable(logging.CRITICAL)                       <span class="comment">#禁用CRITICAL及以下等级的所有消息</span></span><br></pre></td></tr></table></figure><h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><h3 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h3><p>返回自Unix纪元，即协调世界时间（UTC）：1970年1月1日0点 以来的秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#简单测试程序执行时间</span></span><br><span class="line">startTime = time.time()</span><br><span class="line">function()</span><br><span class="line">endTime = time.time()</span><br></pre></td></tr></table></figure><h3 id="time-sleep"><a href="#time-sleep" class="headerlink" title="time.sleep()"></a>time.sleep()</h3><p>参数为秒数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#for循环中sleep，按下CTRL+C可以停止并抛出KeyboardInterrupt异常</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.125</span>, <span class="number">2</span>)                                         <span class="comment">#四舍五入至两位小数，不填则到整数</span></span><br></pre></td></tr></table></figure><h3 id="datetime-datetime"><a href="#datetime-datetime" class="headerlink" title="datetime.datetime()"></a>datetime.datetime()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.year&gt;dt.microsecond                                  <span class="comment">#datetime对象支持四则和比较操作符</span></span><br><span class="line">datetime.datetime.fromtimestamp(time.time())</span><br></pre></td></tr></table></figure><h3 id="datetime-timedelta"><a href="#datetime-timedelta" class="headerlink" title="datetime.timedelta()"></a>datetime.timedelta()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">daysAfter = datetime.timedelta(days=<span class="number">13</span>)</span><br><span class="line">print(dt+daysAfter)                                     <span class="comment">#13天后的日期</span></span><br></pre></td></tr></table></figure><h3 id="datetime-strftime-和strptimr"><a href="#datetime-strftime-和strptimr" class="headerlink" title="datetime.strftime()和strptimr()"></a>datetime.strftime()和strptimr()</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()                            <span class="comment">#返回一个datetime对象</span></span><br><span class="line">dt.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>)                        <span class="comment">#datetime对象转换成字符串</span></span><br><span class="line">datetime.datetime.strptime(<span class="string">'2015/10/21 16:29:00'</span>, <span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/02/17/3C1sYt.jpg" alt=""></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line">print(<span class="string">'Start of program.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeANap</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'Wake up!'</span>)</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=takeANap)</span><br><span class="line">threadObj.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'End of program.'</span>)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Start of program.</span><br><span class="line">End of program.</span><br><span class="line">Wake up!</span><br></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">threadObj = threading.Thread(target=<span class="keyword">print</span>, args=[<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>],kwargs=&#123;<span class="string">'sep'</span>: <span class="string">' &amp; '</span>&#125;)</span><br><span class="line">threadObj.start()</span><br><span class="line">print(<span class="string">'Cats'</span>, <span class="string">'Dogs'</span>, <span class="string">'Frogs'</span>, sep=<span class="string">' &amp; '</span>)                <span class="comment">#args常规参数，kwargs关键字参数</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="批量有序重命名文件"><a href="#批量有序重命名文件" class="headerlink" title="批量有序重命名文件"></a>批量有序重命名文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,re</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">path = <span class="string">'C:\\Users\\Desktop\\test\\'</span></span><br><span class="line">prefix = <span class="string">'picture'</span></span><br><span class="line">suffix = <span class="string">'.py'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    fileregex = re.compile(<span class="string">r'\.\w*'</span>)                    <span class="comment">#取得后缀名</span></span><br><span class="line">    extension = <span class="string">''</span>.join(fileregex.findall(file)[<span class="number">-1</span>:])   <span class="comment">#列表转换为字符串</span></span><br><span class="line">    <span class="keyword">if</span> suffix:</span><br><span class="line">        newName = prefix+str(num)+suffix</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newName = prefix+str(num)+extension</span><br><span class="line">    <span class="keyword">if</span> extension == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span>                                        <span class="comment">#过滤掉文件夹</span></span><br><span class="line">    os.rename(path+file, path+newName)</span><br><span class="line">    print(file+<span class="string">' to '</span>+newName+<span class="string">' rename succeed!'</span>)</span><br><span class="line">    num = num+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT解决点进文章自动下滑到&lt;!-- more --&gt;后面</title>
    <url>/post/Hexo/hexo_issues/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hexo 版本v4.0.0 | 主题 – NexT.Gemini v7.6.0<br>若使用<code>&lt;!-- more --&gt;</code>标签来截取文章概要，当点击全文时，文章链接后会加上#more使页面自动下滑到<code>&lt;!-- more --&gt;</code>的后面<a id="more"></a><br>不想使用这一特性，有以下2个办法<br>1.找到<code>themes\next\layout\_macro</code>下的post.swig文件，将</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;#more"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里的#more删除，即</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.将主题配置文件中的<code>scroll_to_more: true</code>改为<code>scroll_to_more: false</code>这个方法对我没用，可能NexT在新版本中移除了这项配置<br>其他问题可以参考<a href="https://github.com/theme-next/hexo-theme-next/issues" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues</a>以及官方文档<a href="https://hexo-theme-next.netlify.app/" target="_blank" rel="noopener">https://hexo-theme-next.netlify.app/</a></p>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>死亡日记</title>
    <url>/post/Life/daliy/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="3ee71bc45f84975ce4030da589382a5a5d10d12d2e69e471ab3b76980460399b">5052a65d98f5b2298cedff0f1d1d501bed1f97ef5ba2db09796c0adabdfaf78d7998413a1efd8358221496574e82442b8b0805c0ca28a1ee879362a9df93da3759869d196edf3f9ffb342c2802ffb3bd60647af6801905232ed3203de2c3bb334205863506e0eb36b26ef15c79e7d7a7491d14b0142570f29fd4327ae5d05cd09510e14b0ba50f1a8ab65cadf8844434c357ed39b1dbe3e01ac5e9b3c9fcac5645d6c840497e9bc78eae94b637d51f2ba24ad46defcc424bb02975ec596a3bf2d00d86fc115752c5558200dd1f7d18dd6585f19f5914e7214fd77ac830b7a2c030989a27d3533529b91e24a943d0aba28b12e980e609ea13131659b328e2ed1dd39acfa72d7154062e165d98f7518f8dee61aa98cbe82ee65327ca359959b9510f5db4dcbf39b3f885fdf49e2244b4f0efe82bd5317bbc7102394ec7d36a5b37d5a702f59ee5ecb751c5d094ece39a6f17f9f581d8fe3114541fb5a58193f3e79e943575087504904f30452476c0254a1f3fec649008e01152765d2962eba3dc729cde30d0e7cbaba0de0638ae709fdcb1e612934c62d6e452aed9ac9ef83ce6f3ac26c344f18d1a4fe4043b3c4fdb4a3208a8bfc7760fcfb90fa9a966d45c1f1b9f0b8c51efc406a20bae1f8db6e495623ec5d2ba5fd75a7631a77ff6b2bba6c9fdc11b92bd764a67dcb0e60c7010d22594b0b4139588211ae054bdaf6e0128cc5eb9ffdcff259c42984dc8b3635c268008bc40043310d652c090a8365a83164004d553c2e364b691fd7c01817f7ddacff1adb28b3725819a318e19e168efcdc8b42781d3278956d3ab7586ae4be8c2ca8f15aa47fe1195fea214b0ce310367b783f75a0f3c46915f743d38d43ff4c00b2e33291daddb67ddacc23329530059fc79eeaabe608678b504842477c2509d1753bc9f5ec70ce42d2cadaa6265aa1804250cbc5e2944cc37534cb6fd43923c147abe1fde0477f540ba07e221be3454c6f83c64f397d1fb0180fc97ac071fc4639f79e38fed2832c4418ad7b0dc27800782b8e3f25508108d128b7095596150288d170d0abfbaa8862f09e76dee2582b05f3c937e16f892dc9559fbd49b40cafe7f3ad7e0848d9cffd8663cb28f6c5e24b6c3f2c689a953e6c6ca645eea6e3199a3378038f4842d5303c2248995a08e5956d5aeef70dfdf8e864f5197f1a00c920644fa362d6bdddbdc291839a3ad101ce770a36d8b1ba3e220a2b2ada093b8a8ba8988c3d3000e602d223726651fca2e7eb095ac2b54e2208e0e7b353c95cd9eadbaf9f2055ecf865b713ad7ef1e13e2f442dce4b2724b92bc501a5514bed297fbba8be6bd767a9e79522376c45bf214295e98289ac78fa5e401d3f3c22a3577d79c94633108775281b788dfc06ecd05ceb5bbe73c22423e6e1815bad3697786fbf748d02e207c63938ca0ee814791b7f08d1b55be81815e47acbea56b95bf4a4e2af24547544dc2c799d1277cf01472afbec24c96c2d24e0a1884f8183c4f9c631e2efae2d648f59ce60f0fb09b22dd1eab2881af1068f1935b828f4d450edc267af436d7f0fef7636e822ca0c9b739c1a9c5cf0d9850f6a07b901f7041322b11af7318ea1a688bfa52a579bbb54edb1955ce18229c2d14c4de20a82975cce0c4edef9e04ed1effb6739c1f6069a73073a0795159b24ea7deacbda9f90d358c55de29d161d5786f350b360de9d167ea99320aebc695c7c64f84204a9d2f63d5795064592114fe77e1256e35d724257a06e1d3d455a3a033674eae67c72b633b8ea71b98b889c1ca6581baba73dcedc6bf5be458a31ae7660f108b3845e8fc01ec63396fd11b709165d8db6a7220cdba400ec19dc3c63f0326a720af299d7bd3006ee50b6ed7bd70f7d0fe283fb9906b94c10c3bd3f3253094da265b848dec7477bef4d1ac6f87258e16979ee6fcf2ac60473487f6b3cb27e2799e1d547caec7e738659372a1157ce2c921f3baf5ae44ade3814622a2ec041e176dce0efe43a87baaf37b418aca0ee5b5f65e6e11f206dd4c42c6d5540078d4b63830689056bac191e084641bc8db8d2d3432eab9212e6a14fbc3568d66806ee85cda3c0329acdb0d1c86d66efa44e1e6cee8c51b910f0225c39e1878aaa3af2a75e6aa1c05dda6159ed2cea32b8541c30f430cf6737cfa40f175d383463bdd9d7cc6e9582a9348be3e6f6f56d07a86fda34a9b728565168a02a943abf2d94751646438040893a16310d5fdcfc7b971c3836f58cb5e7033598402af22eaf176087fcfe8626f9434464a556480393836070c614f6168e7db326f50106e07988db58eaccf45b765cfb3b2030778575a7b0775a0f61c397094106e58bd8df783b452c1a4efdceb0be4e4a901de8fb04a0ec299825f48aefabd94c66eb6d06fbbf0e91002fb9e255014a3b9eebbc0361edecae7a9e0637adae9df825eb5928eaa31fb92450125c7cad35ebccc016fbc07c79cdd1ae7e7373d3a9b3b9af34f00b0376944b72938b38e537fab25b1a0537854bb5fc67d239ff3fd72485ac43963e73ada1d253e5be6900b93915f7c723227a677bb63455ddfd1050cda4d3b2d2313523e98eae41ee435502fb8fb5a3a85a6cd2938be47a566a7f35c5a191feb1bbf1c6de15d4564c6ccc72ed1cfed05b2a27137dde49f5dd5cd4fa7cc0eed76fe31620b0ec6998dc1d1b9cddb7550499c5124ce5582e7b9096a52d69fc2f0719eb9a847b4b3ad8733b3d899fd8c6acf3da5bdb893297a886eb4843a4de32481c1743265c80e0fd51869f5d7fe52f375c81e901bc4c520414189b50dfa6233f2dd1431f1e010bc039ad5f590bc368dcf75d472296ff39a6e8faa6a12acb17ace983ef54a80636a77429c90d5a610301d301c626f119f22b874d228dee91aa6efb550eee9edcdf0a6eb652236a6a6f67c0fecaf4d6ec7ebb3c4ceab91520ede7aff3ac8034e7f58ee2fed40e7558b6f5daa480fa51c7c8810846b5454ee8f3d70c745d406f0d5156abe355f51418d4f267b644be346d4601ef1fd57a3c3ea53dc6a2f7c092e59663f7717753968c2b9485f28b6409b22be17c35e0ced24fa69f4edbda82c7fa3977029a958966b16f7ef198914e58479d79d836ecc30fb29c63b2d09b76d8dcb4d3c439968792ef7a0927b8758eae70c1be3b0dff6fd7c53eba914513ffe29acf4ca0323b84e7240db74126293effda20592112369f45980e11b94dbb26132c20d9de2da53729496b6efc6996a719c9d2a726043957b9e3cba17ac0a18df33965db51b336d27c9af298fe8ccd19d358b22fe51b7722ca216d3546203bf1cfc04eb9286df15c1258fdf4238321f1823e62bb7e8841b9ca3440191e624fafcdeb61fae98eb5b7e375c91c99cb135bb6a09eec95f66ef81c1e35c38cbe972bd3c51c7c777e5b18605ce68b01802eaae9429c994fb00c0e19ff682f9a1f90fe59e7faa4309b8f5a3db31a5a944d3cafaa45895e675675c162fc583fdbf0610259258b167ebd3f0af7773481cc538bb4ac5ee31c31e9786cdf3d55c94caf38921385e56dda6c03739c874a5b138be0117bc21059bdad64efb2cbd5ce7a0e07c797f83340a9b0edd06973f2676c8506838d46d3881181565567062315747c1602082348a2905c8a54f7716b6aad528ef561ef667990155ebd15c3d6050d6b4beaa8a731b406215a8cb5482a674c4b362a2ba68dfe83c8d11133c662865cd60b71918c3b0aaa7484214ba2129e582b99e196a28a095e22a78d9a308c1025174126b088414f56d922c369a9aca29b4958ea55d012e355c0cf0b51324bdd598c587e47f6279f94e9cf81a895f82ef270023327d126941669f02905aad17ab98a1aa5275cf9a4fe821ce1968ef62a88aa41a74ef5a48e2d354224229bf65db74f3f670e56e32e76b78352324c6d97c482aa750b5253b3aede48256bb6a14860694dffc0010a567e695b2344bbc99a75d19993a4b10371a2eef6e23907f4e147ddbac763805ba55f0834d71a79fd43cee52684254bec2ce6763ab1c2443f62ca09f126804daef8722d59d03b011c2380bba8ee099270ca470cc708031eba431a631507248a44af4531bc47193f18e72d98a2d6a64734f96a0575a319c61b0394eb602fbd622e553283891d7865ca7c47d3b7479dcbb52d8e0c12db4985ec85060d0b2da66699c2e1efd976d997dccb37e58d090d27c12f7964d0e3b6e68e487cd6491c030ca861d8076f2e00c07136a457de6a3a5e6ac01a9919723f5404310186d334e460e60697b54f57e86fb05ba6392c08c7129b7b3bac8178ed033ffd175bcff136660dfd2388e35b9eedd2f1e1b4c246c96a39397596c49d82d7e204e3e449250cca76c33e959e83dbab0fc8b6c904de91cc525d7632da237d245372eb0c9a77393a0bab71a3440cf3bfd891e3061b48816c7677a98ceab22400c617ea86df3a5c591f3a1251f9c89e85266f49f1065ef120325e038db2d58e486209f37f2e38c6b6b9c7116511cef7e19c8def72407d9c12ba8d6e48233001e4d9e9c9c6eb05768d68db77e4bd82247fff05422294a3b2313d8c2484f64112c4feaff721649835c1b82a161a1ade1d475c271fd9654d2fab41e42764aa11c4b2189c4c0607ba85a142ad736e9aa957d6da499172be25bf1c7b042f44068820d8aced16211d84b40c7e89456acbdaf5880b0798e7dbef7b7afa6c1802c116272853b5765cc1cdf7e592a8b26b3a5b7274b5c83ece03de88563a25da092fe5be15ca71989f14273d1a44e793a87e2193e39399bf97fd1aec58b0c995789fc64fe55c0ddc78691d4c849f9d40096c7d6fc1e767674d9da3faab26d9d54066535c8f01609420bf84834ebe0319620b09529672f51da3ea83d205d00451695b19721c96cb81f6acf38e9155089d74f9bee83a21b1bf9b894f650ecf5815579e050b2af530ad3ecf25e9597ceccdef87e729d56dc15d672e8b59b51e6c85d13b234fe8421fdd2ad027820daea47362f49f76c1a2fb80e5e002ac94f84e9654bd6730183a8dc7a9b688f69dba224bc64c99e60f68450bc345a90c08efdcca6ece6651cce83004944d80a2ad7c9ed62f314138d0d1b72bbc61cda8b7bc94c56e742a56fd98a4e3cb2ec11d2f7d1aaadf1e40080eb9285d924e1ff6446aae8dc804c1306660ceb2e4261bf58226d556dfa7a2432b803ea4e69f122a5157721bd8e466dea1500a3ea9fb7632bfea9b758c07890201c31f4c0b227f8f2a2bf96f0be3505968fe5cafb72d98b181027b106cf1f7b08eddff8c2bcc51b6c514e892741ae94e7f9289f54dda7f3028abbbd4154acc8a608ae5c68566fa70d377757cc4ccd323e11dc14a5d743ace9b51692fdaf01a93345e617dc6c97782d79653241305616511e95d49fad8892fa61ac1b387c917d4370fb297e0006ebb57a6dc17c66f19accac5340422f66a30fcae1a5836eabcf9be47976a36266e9796aaacb0efce20352a114afa7680872d762a766ffdb462f87f21c44297d743472dfba9419af656abf0a58a4da1590186835e01b210a060866644fa696433d7baf15d3f4b423cbf500cc8f1439c091eea28e1995e68e43b50f2904b96bf3cd0e7fb86d06d9835c4467134ac835328cf957d797daff5af8de97955bb5d215b449f5e5a27233520775b8d82170894e7074fac8346dc43bc23d6d5b6e14389fd18cae148c43b1957302bf26aad3cb6893840bc3165e00a806fe50c795f134410f57dbbdc3cd7a2e54f62f58e54507a78d2e2cb1f09f83a30c6b41faea50cdfc09904253332b879a08cc99dff0dad1ba688c335a847b69f263ab009fa81b53f43cc1647b433a9110f16bfa240c55e96807538c23e1cfd36598cffdc3690fee73de434b8be417876333f45230314d6b854dedda25590cb048cb7065eba35e4b318d9a425861d432e94cb2587fc6b5b0751bb378904c916db0ad27f84d592b3f216ae8f1051551d85b19add35ba5b0932d2385ee501a675cada31dde47e8d111b840b116590870fea220a60a0d0735636eafbfb82bec4b1a633c20ac4e822951cb038867a4f20baadb1781cb9e0daafff09768d6015d38ba7b4b95a3688041187094a5075be5463ea978cf4e7734f11207d1f34997613445ab7f583bd68ef54e242005b4874dec27402260a26adaf8c23f4c37516f82ab3a03abf91cf8b2910e89e772c2b453482e422f7d02cbf0edbc1bd63991c4dc2af8ff24baa39bbd08ae92ec3bc456a45eedaad6c8b13297e0045b4ee714ccc7f1e24db2db959b4650f01f0df6072d31edab8e6236f5306042a116d67139de33e49422622ef78c87e5e7c827733b7ddfe82d4442103d7c578460709ee763c2fb653bed7c8ed62374999132361d84b268451a2fd8d644d1316fcb8ac5649ae69d7c1d4cfd5721d411ba072405f640ee577b1e4d922ae791d1af579caeed182d14893c820f2ad6059cdba73233ddf1dc9633183406c0af64f0e449554197ba0ec3c8f1c12c0a16e7a22c2e9bed82974c1f9c3fe9e1ce10bfe80344c5651bbce90f3be43107d7343ace2af6da894ca6264b56291bd56813e688b252093038fb830bfbe6776c3d08daa1d6ff71f4775a41a4dcffc3b5a549cff40161318df9a8b2e32d2dd9ff46e584ce03bcb8d4e855c9a81f2c4b53a6d882815a8eb017ca0dc845354dcafeccccbee09d360a2e6cbb80b97dac16f7ada3d808bc074452c89c1eec4d597957318104bee33a67401e08cf807d48d503a4061ef1e8cc3d1192f5a8f96c9baebb6695d3effaff9830dfae1bad7dafff935aaf194be6424ba56c40ed4c107c1e6875c43fcdbe48265c60795c9fd828cbb27b4071a01dc57b2a514a673d03f293f85305f3fa1a3cf8a7361d57750af6874282034430b5a3e3a1f497d8ad8b0c94bd0ca61e510db74acc4bbf4729a09448286ce16ae939c09963dd13299f65e551e0866c0c930d41cd4d6903cb2e584c8216ffa664c4916e45053d4a615456826b0f1b9ac85b7428b925605d4c41fb7eb80474c2fa0a1e31f14b8c34348f87bb80a677ef0a42a868376c25a6eaa0c519ff957b5d850bc6d3401e34e33adde634ca28897b613a75e5eeadf4ff84e6bd5496a5cd1b2d2e1bf0adfb6e71c27cb07e5616a4747630f0df2c7c5becf0bef0e3f5483f3a1026139ea614a3de2a6e26ff974848e9444a72e4d32a3fd25d5ede42fa43a68655a79ec0f0455621b3393a5aeb852ace32b71a4b78b48be83491925639acea362eb2905b5a7a99f6574126545aa53368a98a6506b9cd7c5e8ea47ecdc421b259a3dc7e79f1a79ddcb9c31680b263558492f3e319dde1eb4beecc8b38a2f4af7eff5745945bff61d352c8bd4ac56e74e1afa1457a7d1b884c7e57695301f1da5b2974c15af086c174de35dfd55e9352dff4a0a2f9c4be822fe75797ca3636af89d1f240a8ce46dc34405e908a9cda25099cff1ec44207099c3a944d2127883f59e0d966725e6825aaec4efbb084edb1530f2e286f983753fca075851aa6dbb6d5c9cf0a2b0aec5e8682e010adebe0a69e946f5e270d8bb637ec07a38a657080b134c52b7367f174863068507a3bb267616a526b791000961da6e6c467b761852618d54fac8f550d23cef43a723988f70e683186cbaaa843f52bbb3e02624c246d4aafafd7db98d3be99d5615ae5c37273a947652a5b772db5e766f94fbdda0eb60e1c74587f61dd23f30365474e6e4affef0ddf097a5876c8d49967f115de45475cc08d7d708407efa1eeff7d77c972cbbbd07b3c3f90a735cc6e61b6197f95cfac8ca345e1c19642c536b31ad617aca92b582c7d7da7134542eab6a1eb7a1448bddfe310dcb4b77d77cf43a8d3362df58bacdbe45e1ee4506175fbc19fb4fc21268736648b39335dfb91d44e7355943e0c5aae6459d19f8fd3030ed43f7448d54ac90b9ef5261aaba07d619643d47319da64bc476e85a6f4ba2eec17b21be69b8ef6658242314745a648aa7ce5a3e094b5df1c8e87e68d3d846206b141409e3ea8549d9c574547321ea4e8f8</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
</search>
